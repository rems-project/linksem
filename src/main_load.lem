open import Basic_classes
open import Bool
open import List
open import Num
open import Show
open import String

open import Error
open import Maybe

open import Abi_utilities
open import Abis
open import Assert_extra
open import Auxv
open import Byte_pattern
open import Byte_sequence
open import Elf_dynamic
open import Elf_file
open import Elf_header
open import Elf_interpreted_section
open import Elf_interpreted_segment
open import Elf_memory_image_of_elf64_file
open import Elf_note
open import Elf_program_header_table
open import Elf_relocation
open import Elf_section_header_table
open import Elf_symbol_table
open import Elf_types_native_uint
open import Filesystem
open import Gnu_ext_abi
open import Gnu_ext_dynamic
open import Gnu_ext_program_header_table
open import Gnu_ext_section_header_table
open import Gnu_ext_symbol_versioning
open import Harness_interface
open import Ldconfig
open import Memory_image
open import Missing_pervasives

open import Abi_mips64
open import Abi_mips64_dynamic
open import Abi_mips64_relocation

open import Abi_amd64
open import Abi_amd64_relocation

(** A mmap table entry suitable for both Linux and FreeBSD. *)
type mmap_entry = <|
  mmap_entry_start : natural;
  mmap_entry_end : natural;
  mmap_entry_offset : natural;
  mmap_entry_path : string
|>

let get_file_abi f =
  let guessed_abi = List.find (fun abi ->
    abi.is_valid_elf_header f.elf64_file_header
  ) Abis.all_abis in
  match guessed_abi with
    | Just abi -> Gnu_ext_abi.gnu_extend (Abis.tls_extend abi)
    | Nothing -> failwith "output file does not conform to any known ABI"
  end

let load_memory_image f =
  let abi = get_file_abi f in
  elf_memory_image_of_elf64_file abi "<input file>" f

let load_memory_image_with_sections f =
  let f_without_phdr = <|
    elf64_file_header = f.elf64_file_header;
    elf64_file_program_header_table = [];
    elf64_file_section_header_table = f.elf64_file_section_header_table;
    elf64_file_interpreted_segments = f.elf64_file_interpreted_segments;
    elf64_file_interpreted_sections = f.elf64_file_interpreted_sections;
    elf64_file_bits_and_bobs = f.elf64_file_bits_and_bobs
  |> in
  load_memory_image f_without_phdr

let load_memory_image_with_annotations f =
  (* TODO: this is a hack *)
  let raw = load_memory_image f in
  let annotated = load_memory_image_with_sections f in
  <|
    elements = raw.elements;
    by_range = annotated.by_range;
    by_tag = annotated.by_tag
  |>

let print_elf64_phdr f =
  let _ = Missing_pervasives.errln "Program header:" in
  let _ = List.map (fun pent ->
    Missing_pervasives.errln (
      "  offset=0x" ^
      (hex_string_of_natural (natural_of_elf64_off pent.elf64_p_offset))
      ^ " addr=0x" ^
      (hex_string_of_natural (natural_of_elf64_addr pent.elf64_p_vaddr))
      ^ " filesz=0x" ^
      (hex_string_of_natural (natural_of_elf64_xword pent.elf64_p_filesz))
      ^ " memsz=0x" ^
      (hex_string_of_natural (natural_of_elf64_xword pent.elf64_p_memsz))
      ^ " flags=" ^
      (string_of_elf_segment_permissions (natural_of_elf64_word pent.elf64_p_flags))
    )
  ) f.elf64_file_program_header_table in
  ()

let get_load_segment_at f addr =
  let l = List.filter (fun seg ->
    seg.elf64_segment_type = Elf_program_header_table.elf_pt_load &&
      addr >= seg.elf64_segment_base &&
      addr < seg.elf64_segment_base + seg.elf64_segment_size
  ) f.elf64_file_interpreted_segments in
  match l with
    | [seg] -> return seg
    | [] -> Error.fail ("get_load_segment_at: no segment found at 0x" ^ (hex_string_of_natural addr))
    | _ -> Error.fail ("get_load_segment_at: multiple segments found at 0x" ^ (hex_string_of_natural addr))
  end

val get_mmap_entry_at : list mmap_entry -> natural -> maybe mmap_entry
let get_mmap_entry_at mmap_table addr =
  let l = List.filter (fun e ->
    addr >= e.mmap_entry_start && addr < e.mmap_entry_end
  ) mmap_table in
  match l with
    | [e] -> Just e
    | [] -> Nothing
    | _ -> failwith ("get_mmap_entry_at: multiple mmap entries found at 0x" ^ (hex_string_of_natural addr))
  end

let read_nt_file_entries endian note_segs =
  Error.foldM (fun acc note_seg ->
    let note_name = name_string_of_elf64_note note_seg in
    let note_type = natural_of_elf64_word note_seg.elf64_note_type in
    if note_name = "CORE" && note_type = Elf_note.nt_file then
      Elf_note.read_elf64_nt_file endian note_seg.elf64_note_desc >>= fun nt_file ->
      let entries = List.map (fun e ->
        let _ = Missing_pervasives.errln (
          "NT_FILE"
          ^ " start=0x" ^ (hex_string_of_natural (natural_of_elf64_xword e.elf64_nt_file_entry_start))
          ^ " end=0x" ^ (hex_string_of_natural (natural_of_elf64_xword e.elf64_nt_file_entry_end))
          ^ " offset=0x" ^ (hex_string_of_natural (natural_of_elf64_xword e.elf64_nt_file_entry_offset))
          ^ " filename=`" ^ e.elf64_nt_file_entry_filename ^ "`"
        ) in
        <|
          mmap_entry_start = natural_of_elf64_xword e.elf64_nt_file_entry_start;
          mmap_entry_end = natural_of_elf64_xword e.elf64_nt_file_entry_end;
          mmap_entry_offset = natural_of_elf64_xword e.elf64_nt_file_entry_offset;
          mmap_entry_path = e.elf64_nt_file_entry_filename
        |>
      ) nt_file.elf64_nt_file_entries in
      return (acc ++ entries)
    else
      return acc
  ) [] note_segs

let read_nt_procstat_vmmap endian note_segs =
  Error.foldM (fun acc note_seg ->
    let note_name = name_string_of_elf64_note note_seg in
    let note_type = natural_of_elf64_word note_seg.elf64_note_type in
    if note_name = "FreeBSD" && note_type = Elf_note.nt_procstat_vmmap then
      let struct_size = natural_of_hex "0x488" in (* sizeof(struct kinfo_vmentry) *)
      read_elf64_freebsd_note_desc endian note_seg struct_size >>= fun bs ->
      Elf_note.read_elf64_nt_procstat_vmmap endian bs >>= fun entries ->

      let entries = List.map (fun e ->
        let _ = Missing_pervasives.errln (
          "NT_PROCSTAT_VMMAP"
          ^ " start=0x" ^ (hex_string_of_natural (natural_of_elf64_xword e.elf64_nt_procstat_vmentry_start))
          ^ " end=0x" ^ (hex_string_of_natural (natural_of_elf64_xword e.elf64_nt_procstat_vmentry_end))
          ^ " offset=0x" ^ (hex_string_of_natural (natural_of_elf64_xword e.elf64_nt_procstat_vmentry_offset))
          ^ " path=`" ^ e.elf64_nt_procstat_vmentry_path ^ "`"
        ) in
        <|
          mmap_entry_start = natural_of_elf64_xword e.elf64_nt_procstat_vmentry_start;
          mmap_entry_end = natural_of_elf64_xword e.elf64_nt_procstat_vmentry_end;
          mmap_entry_offset = natural_of_elf64_xword e.elf64_nt_procstat_vmentry_offset;
          mmap_entry_path = e.elf64_nt_procstat_vmentry_path
        |>
      ) entries in

      return (acc ++ entries)
    else
      return acc
  ) [] note_segs

let read_nt_auxv_value endian note_segs f auxv_type =
  Error.foldM (fun value note_seg ->
    let note_name = name_string_of_elf64_note note_seg in
    let note_type = natural_of_elf64_word note_seg.elf64_note_type in
    if (note_name = "CORE" && note_type = Elf_note.nt_auxv)
        || (note_name = "FreeBSD" && note_type = Elf_note.nt_procstat_auxv) then
      let bs = note_seg.elf64_note_desc in
      let bs_res = if note_name = "FreeBSD" then
        read_elf64_freebsd_note_desc endian note_seg 16 (* sizeof(Elf_Auxvinfo) *)
      else
        return bs
      in
      bs_res >>= fun bs ->
      Auxv.read_all_elf64_auxv endian bs >>= fun note_auxv_list ->
      Error.foldM (fun value auxv ->
        if (natural_of_elf64_xword auxv.elf64_auxv_type) = auxv_type then
          let v = natural_of_elf64_xword auxv.elf64_auxv_value in
          match value with
            | Nothing -> return (Just v)
            | Just _ -> Error.fail ("read_nt_auxv_value: duplicate value for type " ^ (show auxv_type))
          end
        else
          return value
      ) value note_auxv_list
    else
      return value
  ) Nothing note_segs

let get_segment_byte_sequence_at f addr =
  get_load_segment_at f addr >>= fun seg ->
  Byte_sequence.dropbytes (addr - seg.elf64_segment_base) seg.elf64_segment_body

let read_nt_auxv_execfn endian note_segs f =
  read_nt_auxv_value endian note_segs f Auxv.at_execfn >>= fun addr ->
  match addr with
    | Just addr ->
      get_segment_byte_sequence_at f addr >>= fun value_bs ->
      Elf_note.read_string value_bs >>= fun (s, _) ->
      return (Just s)
    | Nothing -> return Nothing
  end

let read_nt_procstat_psstrings_argv0 endian note_segs f =
  Error.foldM (fun value note_seg ->
    let note_name = name_string_of_elf64_note note_seg in
    let note_type = natural_of_elf64_word note_seg.elf64_note_type in
    if (note_name = "FreeBSD") && note_type = Elf_note.nt_procstat_psstrings then
      let item_size = 8 in (* Size of an address *)
      read_elf64_freebsd_note_desc endian note_seg item_size >>= fun bs ->
      (* Triple indirection, just because we like it *)
      Elf_note.read_elf64_nt_procstat_psstrings endian bs >>= fun psstrings_addr ->
      let psstrings_addr = natural_of_elf64_addr psstrings_addr in
      get_segment_byte_sequence_at f psstrings_addr >>= fun psstrings_bs ->
      Elf_note.read_elf64_psstrings endian psstrings_bs >>= fun psstrings ->
      let argvstr_addr = natural_of_elf64_addr psstrings.elf64_psstrings_argvstr in
      get_segment_byte_sequence_at f argvstr_addr >>= fun argvstr_bs ->
      read_elf64_addr endian argvstr_bs >>= fun (argv0_addr, _) ->
      let argv0_addr = natural_of_elf64_addr argv0_addr in
      get_segment_byte_sequence_at f argv0_addr >>= fun argv0_bs ->
      Elf_note.read_string argv0_bs >>= fun (argv0str, _) ->
      return (Just argv0str)
    else
      return value
  ) Nothing note_segs

let load_file filename =
  let endian = Endianness.default_endianness in
  Byte_sequence.acquire filename >>= fun bs ->
  let read_uchar = Elf_types_native_uint.read_unsigned_char endian in
  Error.repeatM' Elf_header.ei_nident bs read_uchar >>= fun (ident, _) ->
  match List.index ident 4 with
    | Nothing -> Assert_extra.failwith "ELF ident transcription error"
    | Just c ->
      let c = Elf_types_native_uint.natural_of_unsigned_char c in
      if c = Elf_header.elf_class_64 then
        Elf_file.read_elf64_file bs >>= fun f ->
        return (bs, f)
      else
        Assert_extra.failwith "Unknown ELF ident"
  end

let print_memory_image img =
  let _ = Missing_pervasives.errln "Memory image:" in
  Map.mapi (fun k e ->
    let start = assert_unwrap_maybe e.startpos in
    let len = assert_unwrap_maybe e.length in
    Missing_pervasives.errln ("  element: " ^ k ^ " start=0x" ^ (hex_string_of_natural start) ^ " len=0x" ^ (hex_string_of_natural len) ^ " contents_len=0x" ^ (hex_string_of_natural (naturalFromNat (List.length e.contents))))
  ) img.elements

let memory_image_element_at img addr =
  let elements = Map_extra.toList img.elements in
  let maybe_tuple = List.find (fun (_, e) ->
    let start = assert_unwrap_maybe e.startpos in
    let len = assert_unwrap_maybe e.length in
    addr >= start && addr < start + len
  ) elements in
  Maybe.map (fun (_, e) -> e) maybe_tuple

type byte_pattern_compare_result =
  | BytePatternMatch
  | BytePatternMismatch of (natural * string)

let rec compare_byte_pattern' offset core_bp binary_bp =
  match (core_bp, binary_bp) with
    | (_, []) ->
      BytePatternMatch
    | ((Just core_b)::core_bp, (Just binary_b)::binary_bp) ->
      if core_b <> binary_b then
        let err_msg = "compare_byte_pattern: mismatch at offset 0x" ^ (hex_string_of_natural offset) ^ ": byte " ^ (show core_b) ^ " vs. " ^ (show binary_b) in
        BytePatternMismatch (offset, err_msg)
      else
        compare_byte_pattern' (offset + 1) core_bp binary_bp
    | (_::core_bp, Nothing::binary_bp) ->
      compare_byte_pattern' (offset + 1) core_bp binary_bp
    | (maybe_core_b::_, maybe_binary_b::_) ->
      let err_msg = "compare_byte_pattern: mismatch at offset 0x" ^ (hex_string_of_natural offset) ^ ": " ^ (show maybe_core_b) ^ " vs. " ^ (show maybe_binary_b) in
      BytePatternMismatch (offset, err_msg)
    | (_, _) ->
      let err_msg = "compare_byte_pattern: mismatch at offset 0x" ^ (hex_string_of_natural offset) ^ ": length mismatch" in
      BytePatternMismatch (offset, err_msg)
  end

val compare_byte_pattern : byte_pattern -> byte_pattern -> byte_pattern_compare_result
let compare_byte_pattern = compare_byte_pattern' 0

val print_byte_pattern_line' : natural -> natural -> byte_pattern -> unit
let rec print_byte_pattern_line' offset len bp =
  if len = 0 then () else
  let (s, bp) = match bp with
    | [] -> ("  ", [])
    | maybe_b::bp ->
      let s = match maybe_b with
        | Nothing -> "--"
        | Just b -> show b
      end in
      (s, bp)
  end in
  let s = if offset mod 2 = 1 && (len - 1) > 0 then s ^ " " else s in
  let _ = Missing_pervasives.errs s in
  print_byte_pattern_line' (offset + 1) (len - 1) bp

val print_byte_pattern_line : natural -> byte_pattern -> unit
let print_byte_pattern_line = print_byte_pattern_line' 0

val fixed_hex_string_of_natural : natural -> natural -> string
let rec fixed_hex_string_of_natural len n =
    if len = 0 then ""
    else (fixed_hex_string_of_natural (len - 1) (n / 16)) ^ (toString [Missing_pervasives.hex_char_of_nibble (n mod 16)])

let print_byte_pattern_addr_size : natural = 12
let print_byte_pattern_line_size : natural = 16

val print_byte_pattern : natural -> byte_pattern -> unit
let rec print_byte_pattern start bp =
  if bp = [] then () else
  let _ = Missing_pervasives.errs ((fixed_hex_string_of_natural print_byte_pattern_addr_size start) ^ " ") in
  let (line, bp) = List.splitAt (natFromNatural print_byte_pattern_line_size) bp in
  let _ = print_byte_pattern_line print_byte_pattern_line_size line in
  let _ = Missing_pervasives.errs "\n" in
  print_byte_pattern (start + print_byte_pattern_line_size) bp

val print_two_byte_patterns : natural -> byte_pattern -> byte_pattern -> unit
let rec print_two_byte_patterns start bp1 bp2 =
  if bp1 = [] && bp2 = [] then () else
  let was_bp1_empty = bp1 = [] in (* If only bp1 is empty, print one extra line *)
  let _ = Missing_pervasives.errs ((fixed_hex_string_of_natural print_byte_pattern_addr_size start) ^ " | ") in
  let (line1, bp1) = List.splitAt (natFromNatural print_byte_pattern_line_size) bp1 in
  let (line2, bp2) = List.splitAt (natFromNatural print_byte_pattern_line_size) bp2 in
  let _ = print_byte_pattern_line print_byte_pattern_line_size line1 in
  let _ = Missing_pervasives.errs " | " in
  let _ = print_byte_pattern_line print_byte_pattern_line_size line2 in
  let _ = match compare_byte_pattern line2 line1 with
    | BytePatternMatch -> ()
    | BytePatternMismatch (_, err_msg) -> Missing_pervasives.errs " X" (* Missing_pervasives.errs (" " ^ err_msg) *)
  end in
  let _ = Missing_pervasives.errs "\n" in
  if was_bp1_empty then
    Missing_pervasives.errln "             |                                         |                   [â€¦]                  "
  else
    print_two_byte_patterns (start + print_byte_pattern_line_size) bp1 bp2

let get_section_at_offset f offset =
  let l = List.filter (fun sec ->
    offset >= sec.elf64_section_offset &&
      offset < sec.elf64_section_offset + sec.elf64_section_size
  ) f.elf64_file_interpreted_sections in
  match l with
    | [] -> Nothing
    | [sec] -> Just sec
    | _ -> failwith ("get_section_at_offset: multiple sections at offset 0x" ^ (hex_string_of_natural offset))
  end

let print_elf64_section sec =
  Missing_pervasives.errln (sec.elf64_section_name_as_string
    ^ " offset=0x" ^ (hex_string_of_natural sec.elf64_section_addr)
    ^ " addr=0x" ^ (hex_string_of_natural sec.elf64_section_addr)
    ^ " len=0x" ^ (hex_string_of_natural sec.elf64_section_size))

let get_section_at_addr f addr =
  if addr = 0 then Nothing else (* TODO: is this the right thing to do? *)
  let l = List.filter (fun sec ->
    addr >= sec.elf64_section_addr &&
      addr < sec.elf64_section_addr + sec.elf64_section_size
  ) f.elf64_file_interpreted_sections in
  match l with
    | [] -> Nothing
    | [sec] -> Just sec
    | sec::_ -> Just sec (* TODO: remove me *)
    (* | _ ->
      let _ = List.map print_elf64_section l in
      failwith ("get_section_at_addr: " ^ (show (List.length l)) ^ " sections at address 0x" ^ (hex_string_of_natural addr)) *)
  end

let show_section_at_addr f addr =
  match get_section_at_addr f addr with
    | Just section ->
      let offset_in_section = addr - section.elf64_section_addr in
      "[section at " ^ section.elf64_section_name_as_string ^ "+0x" ^ (hex_string_of_natural offset_in_section) ^ "]"
    | Nothing ->
      "[unknown section at 0x" ^ (hex_string_of_natural addr) ^ "]"
  end

val show_section_at : list mmap_entry -> elf64_file -> natural -> string
let show_section_at mmap_table f addr =
  match get_mmap_entry_at mmap_table addr with
    | Just e ->
      let entry_offset = e.mmap_entry_offset in
      let offset_in_entry = addr - e.mmap_entry_start in
      let file_offset = entry_offset + offset_in_entry in
      match get_section_at_offset f file_offset with
        | Just section ->
          let offset_in_section = file_offset - section.elf64_section_offset in
          "[section at 0x" ^ (hex_string_of_natural addr) ^ ", " ^ section.elf64_section_name_as_string ^ "+0x" ^ (hex_string_of_natural offset_in_section) ^ "]"
        | Nothing ->
          "[unknown section at 0x" ^ (hex_string_of_natural addr) ^ " with NT_FILE at 0x" ^ (hex_string_of_natural e.mmap_entry_start) ^ "]"
      end
    | Nothing ->
      "[unknown section at 0x" ^ (hex_string_of_natural addr) ^ " without NT_FILE]"
  end

let rec extract_memory_image_byte_pattern img start len =
  if len = 0 then return [] else
  let err_msg = "extract_memory_image_byte_pattern: no core image element at 0x" ^ (hex_string_of_natural start) ^ ", it may be missing from the core file" in
  Error.of_maybe err_msg (memory_image_element_at img start) >>= fun el ->
  let el_start = assert_unwrap_maybe el.startpos in
  let el_len = assert_unwrap_maybe el.length in
  let _ = Missing_pervasives.errln ("  Matching with core image element at 0x" ^ (hex_string_of_natural el_start) ^ ", length 0x" ^ (hex_string_of_natural el_len)) in
  let _ = Missing_pervasives.errln ("  Available for checking: 0x" ^ (hex_string_of_natural (naturalFromNat (List.length el.contents))) ^ " bytes") in
  let offset = start - el_start in
  (* let _ = Missing_pervasives.errln ("Skipping 0x" ^ (hex_string_of_natural offset) ^ " bytes") in *)
  let bp = byte_pattern_skip offset el.contents in
  let stop = start + len in
  let el_stop = el_start + el_len in
  if stop > el_stop then
    extract_memory_image_byte_pattern img el_stop (stop - el_stop) >>= fun next ->
    return (bp ++ next)
  else
    return bp

let compare_memory_image core_img binary_img (* for debugging: *) (mmap_table, binary_file, binary_base) =
  let binary_elements = Map_extra.toList binary_img.elements in
  let results = List.map (fun (_, binary_el) ->
    let start = assert_unwrap_maybe binary_el.startpos in
    (* let len = assert_unwrap_maybe binary_el.length in *)
    let len = naturalFromNat (List.length binary_el.contents) in
    if len = 0 then return () else
    let _ = Missing_pervasives.errln ("Comparing memory element at 0x" ^ (hex_string_of_natural start) ^ ", length 0x" ^ (hex_string_of_natural len)) in

    let binary_bp = binary_el.contents in
    match extract_memory_image_byte_pattern core_img start len with
      | Success core_bp ->
        match compare_byte_pattern core_bp binary_bp with
          | BytePatternMatch ->
            let _ = Missing_pervasives.errln ("  Memory image element at 0x" ^ (hex_string_of_natural start) ^ " matches!") in
            return ()
          | BytePatternMismatch (mismatch_offset, err_msg) ->
            let mismatch_addr = start + mismatch_offset in
            let _ = Missing_pervasives.errln err_msg in
            let _ = Missing_pervasives.errln ("  Memory image element at 0x" ^ (hex_string_of_natural start) ^ " mismatches at offset 0x" ^ (hex_string_of_natural mismatch_addr) ^ " in " ^ (show_section_at mmap_table binary_file mismatch_addr) ^ " :(") in
            let _ = Missing_pervasives.errln "Addr         | Binary                                  | Core                                   " in
            let _ = print_two_byte_patterns start binary_bp core_bp in
            Error.fail "Mismatch"
        end
      | Fail err ->
        (* FreeBSD doesn't include read-only mmapped regions in coredumps *)
        (* TODO: check mmap table too? *)
        get_load_segment_at binary_file (start - binary_base) >>= fun seg ->
        let (r, w, x) = seg.elf64_segment_flags in
        if not w then
          let _ = Missing_pervasives.errln ("  Warning: memory image element at 0x" ^ (hex_string_of_natural start) ^ " is not included in the core file") in
          let _ = Missing_pervasives.errln ("  Skipping because it is read-only") in
          return ()
        else
          Error.fail err
    end
  ) binary_elements in
  let _ = List.map (fun res ->
    match res with
      | Success _ -> ()
      | Fail err -> Missing_pervasives.errln err
    end
  ) results in
  Error.foldM (fun _ res -> res) () results

let is_data_section sec =
  false
  || sec.elf64_section_name_as_string = ".data"
  || sec.elf64_section_name_as_string = ".sdata" (* initialized short data *)
  || sec.elf64_section_name_as_string = ".sbss" (* uninitialized short data *)
  || sec.elf64_section_name_as_string = ".tdata" (* initialized thread-local data *)
  || sec.elf64_section_name_as_string = ".tbss" (* uninitialized thread-local data *)
  || sec.elf64_section_name_as_string = ".dynamic"
  || sec.elf64_section_name_as_string = ".data.rel.ro" (* TODO: remove me? *)
  || sec.elf64_section_name_as_string = ".rld_map" (* TODO: remove me *)

let mask_data_sections f img =
  let data_sections = List.filter is_data_section f.elf64_file_interpreted_sections in
  List.foldl (fun img sec ->
    let _ = Missing_pervasives.errln ("Masking " ^ sec.elf64_section_name_as_string ^ " at 0x" ^ (hex_string_of_natural sec.elf64_section_addr) ^ ", size 0x" ^ (hex_string_of_natural sec.elf64_section_size)) in
    mask_memory_image img sec.elf64_section_addr sec.elf64_section_size
  ) img data_sections

let mask_relocations f img =
  let all_relocs = Elf_memory_image.extract_all_relocs "<input file>" f in
  let abi = get_file_abi f in
  List.foldl (fun img (scn, rel_idx, rel_src_scn, rel) ->
    let addr = natural_of_elf64_addr rel.elf64_ra_offset in
    let (rel_type, _) = abi.parse_reloc_info rel.elf64_ra_info in
    let (is_absolute, applyfn) = abi.reloc rel_type in
    let (width, calcfn) = applyfn img addr Memory_image.null_symbol_reference_and_reloc_site in
    let _ = Missing_pervasives.errln ("Masking relocation of type 0x" ^ (hex_string_of_natural rel_type) ^ " at 0x" ^ (hex_string_of_natural addr) ^ ", size 0x" ^ (hex_string_of_natural width) ^ " in " ^ (show_section_at_addr f addr)) in
    (* let _ = Missing_pervasives.errln ("Relocation info: " ^ (show rel.elf64_ra_info)) in *)
    mask_memory_image img addr width
  ) img all_relocs

let extract_all_relocs_as_symbol_references abi f =
  let all_relocs = Elf_memory_image.extract_all_relocs "<input file>" f in
  let all_symtab_triples_by_scnidx = mapMaybei (fun scnidx -> (fun isec ->
    if isec.elf64_section_type = sht_symtab || isec.elf64_section_type = sht_dynsym then
      match find_elf64_symbols_by_symtab_idx scnidx f with
        | Fail _ -> Nothing
        | Success triple -> Just (scnidx, triple)
      end
    else Nothing
  )) f.elf64_file_interpreted_sections in
  let (all_extracted_symtabs_by_scnidx : (Map.map natural (list (string * elf64_symbol_table_entry * natural (* scnidx *) * natural (* symidx *))))) =
    List.foldl (fun acc ->
      (fun (scnidx, triple) ->
        Map.insert scnidx (Elf_memory_image.extract_all_symbols triple) acc
      )
    ) Map.empty all_symtab_triples_by_scnidx
  in
  (* let _ = Missing_pervasives.errln ("All extracted symtabs by scnidx: " ^ (show (Set_extra.toList (Map.toSet all_extracted_symtabs_by_scnidx)))) in *)
  let ref_for_relocation_a_in_section_index = fun rel_scn_idx -> (fun rel_idx -> (fun rela ->
    let rela_isec = match Missing_pervasives.index rel_scn_idx f.elf64_file_interpreted_sections with
      | Just x -> x
      | Nothing -> failwith "relocation references nonexistent section"
    end in
    let symtab_idx = rela_isec.elf64_section_link in
    (* TODO: some relocations don't have a symbol. We detect those with a NULL symtab_idx, but there might be a better way to do it? *)
    if symtab_idx = 0 then null_symbol_reference else
    match Map.lookup symtab_idx all_extracted_symtabs_by_scnidx with
      | Nothing -> failwith ("referenced symtab does not exist: " ^ (show symtab_idx))
      | Just quads ->
        let (_, sym_idx) = abi.parse_reloc_info rela.elf64_ra_info in
        let maybe_quad = Missing_pervasives.index sym_idx quads in
        match maybe_quad with
          | Just(symname, syment, scnidx, symidx) ->
            <|
              ref_symname = symname;
              ref_syment = syment;
              ref_sym_scn = symtab_idx;
              ref_sym_idx = sym_idx
            |>
          | Nothing ->
            failwith ("reloc references symbol that does not exist: 0x" ^ (hex_string_of_natural sym_idx))
            (*("reloc at index " ^ (show rel_idx) ^ " references symbol (index " ^ (show sym_idx) ^
            ") that does not exist: symtab (index " ^ (show symtab_idx) ^ ") has " ^ (show (length quads)) ^ " entries")*)
        end
    end
  )) in
  (*let _ = Missing_pervasives.errs ("Extracted " ^ (show (length all_relocs)) ^ " reloc references (rel_scn, rel_idx, src_scn): "
      ^ (show (List.map (fun (rel_scn, rel_idx, srcscn, rela) -> (rel_scn, rel_idx, srcscn)) all_relocs)) ^ "\n")
  in*)
  List.map (fun (scn, idx, srcscn, rela) ->
    <|
      (* NOTE that a reference is not necessarily to an undefined symbol! *)
      ref = ref_for_relocation_a_in_section_index scn idx rela;
      maybe_reloc = Just <|
        ref_relent = rela;
        ref_rel_scn = scn;
        ref_rel_idx = idx;
        ref_src_scn = srcscn (* what section does the reference come from? it's the 'info' link of the rel section header *)
      |>;
      maybe_def_bound_to = Nothing
    |>
  ) all_relocs

type dynamic_symbol = <|
  dynamic_symbol_name : string;
  dynamic_symbol_entry : elf64_symbol_table_entry;
  dynamic_symbol_value : natural;
  dynamic_symbol_version : maybe string;
  dynamic_symbol_version_base : bool
|>

let find_sym syms name version =
  let matches = List.filter (fun sym -> sym.dynamic_symbol_name = name) syms in
  let version_matches = List.filter (fun sym -> sym.dynamic_symbol_version = version) matches in
  match version_matches with
    | [] ->
      match version with
        | Just _ ->
          (* Reference requested a specific version, we don't have it *)
          Nothing
        | Nothing ->
          (* Reference without version *)
          match matches with
            | [] -> Nothing
            | [sym] ->
              (* If there is exactly one version for which this symbol is
                 defined, then this version is accepted. *)
              Just sym
            | _ ->
              (* Multiple results with different versions, fallback to base
                 definition *)
              (* TODO: add support for: 2 is the name given later to the
                 baseline of symbols once the library started using symbol
                 versioning *)
              List.find (fun sym -> sym.dynamic_symbol_version_base) matches
          end
      end
    | [sym] ->
      Just sym
    | _ ->
      failwith ("find_sym: multiple symbols for `" ^ name ^ "` version " ^ (show version))
  end

let is_unsupported_relocation_type f rel_type =
  (* TODO: add support for TLS relocs *)
  if Abi_amd64.header_is_amd64 f.elf64_file_header then
    rel_type = r_x86_64_irelative || rel_type = r_x86_64_tpoff64
      || rel_type = r_x86_64_dtpoff64 || rel_type = r_x86_64_dtpmod64
  else if Abi_mips64.header_is_mips64 f.elf64_file_header then
    rel_type = r_mips_tls_tprel64
  else
    false

val apply_relocation : forall 'abifeature. abi 'abifeature -> elf64_file -> annotated_memory_image 'abifeature -> natural -> elf64_relocation_a -> symbol_reference_and_reloc_site -> natural -> annotated_memory_image 'abifeature
let apply_relocation abi f img base reloc symref_and_reloc_site sym_addr =
  let (rel_type, _) = abi.parse_reloc_info reloc.elf64_ra_info in
  let offset = natural_of_elf64_addr reloc.elf64_ra_offset in
  let addend = integer_of_elf64_sxword reloc.elf64_ra_addend in
  let addr = base + offset in
  (* TODO: support is_absolute? *)
  let (is_absolute, applyfn) = abi.reloc rel_type in
  let (width, calcfn) = applyfn img addr symref_and_reloc_site in
  let _ = Missing_pervasives.errln ("Relocation of type 0x" ^ (hex_string_of_natural rel_type) ^ " at 0x" ^ (hex_string_of_natural addr) ^ " (offset 0x" ^ (hex_string_of_natural offset) ^ "), size 0x" ^ (hex_string_of_natural width) ^ " in " ^ (show_section_at_addr f offset)) in

  (* TODO: is there a way to make this nicer? *)
  if rel_type = 0 then
    let _ = Missing_pervasives.errln "  Skipping NONE relocation" in
    img
  else

  let is_in_data_section = match get_section_at_addr f offset with
    | Just sec -> is_data_section sec
    | Nothing -> false
  end in
  if is_in_data_section then
    let _ = Missing_pervasives.errln "  Relocation inside a data section, ignoring" in
    img
  else
    if is_unsupported_relocation_type f rel_type then
      let _ = Missing_pervasives.errln ("  Giving up on this one") in
      mask_memory_image img addr width
    else
      let existing_bytes = assert_unwrap_maybe (read_memory_image img addr width) in
      (* TODO: don't hardcode little endian *)
      let existing_value = Memory_image.natural_of_le_byte_list existing_bytes in
      let new_value = calcfn sym_addr addend existing_value in
      (* TODO: don't hardcode little endian *)
      let field_bytes = Memory_image.natural_to_le_byte_list_padded_to width new_value in
      let field_bp = List.map (fun b -> Just b) field_bytes in
      let _ = Missing_pervasives.errln ("  Relocating `" ^ symref_and_reloc_site.ref.ref_symname ^ "` (existing=0x" ^ (hex_string_of_natural existing_value) ^ " addend=" ^ (show addend) ^ ") to 0x" ^ (hex_string_of_natural new_value) ^ " (symbol address 0x" ^ (hex_string_of_natural sym_addr) ^ ")") in
      write_memory_image img addr field_bp

let get_sym_ref_version dynsym_scnidx maybe_versym_table sym_name sym_scn sym_idx =
  if dynsym_scnidx <> sym_scn then Nothing else
  match maybe_versym_table with
    | Just versym_table ->
      (* TODO: unify get_gnu_ext_interpreted_verneed and get_gnu_ext_interpreted_verdef *)
      match get_gnu_ext_interpreted_verneed versym_table sym_idx with
        | Success Nothing -> Nothing
        | Success (Just vernaux) ->
          (* TODO: handle vernaux.gnu_ext_interpreted_vernaux_verneed.gnu_ext_interpreted_verneed_file *)
          Just vernaux.gnu_ext_interpreted_vernaux_name
        | Fail errmsg ->
          (* TODO: failwith errmsg *)
          (* No verneed found, maybe this DSO is defining the symbol and has a reloc bound to it *)
          match get_gnu_ext_interpreted_verdef versym_table sym_idx with
            | Success (GnuExtInterpretedVerdefVersion verdef) ->
              Just verdef.gnu_ext_interpreted_verdef_name
            | _ ->
              Nothing
          end
      end
    | Nothing ->
      Nothing
  end

let apply_all_relocations f img base syms dynsym_scnidx maybe_versym_table =
  let abi = get_file_abi f in
  let symbol_refs_and_reloc_sites = extract_all_relocs_as_symbol_references abi f in
  (* let tags_and_ranges = Multimap.lookupBy Memory_image_orderings.tagEquiv (SymbolRef(null_symbol_reference_and_reloc_site)) img.by_tag in *)
  let _ = Missing_pervasives.errln ("Number of symbol refs: " ^ (show (List.length symbol_refs_and_reloc_sites))) in
  (* let _ = List.map (fun (tag, maybe_range) -> *)
  List.foldl (fun img symref_and_reloc_site ->
    let reloc_site = match symref_and_reloc_site.maybe_reloc with
      | Nothing -> failwith "impossible: no reloc site during relocation"
      | Just rs -> rs
    end in

    let sym_name = symref_and_reloc_site.ref.ref_symname in
    let maybe_sym =
      if sym_name <> "" then
        let sym_scn = symref_and_reloc_site.ref.ref_sym_scn in
        let sym_idx = symref_and_reloc_site.ref.ref_sym_idx in
        let maybe_sym_version = get_sym_ref_version dynsym_scnidx maybe_versym_table sym_name sym_scn sym_idx in
        let _ = Missing_pervasives.errln ("Searching for symbol `" ^ sym_name ^ "`, version " ^ (show maybe_sym_version)) in
        find_sym syms sym_name maybe_sym_version
      else
        Nothing
    in

    (* TODO: hard fail if symbol name is non-empty but find_sym returns Nothing? *)
    let sym_addr = match maybe_sym with
      | Just sym -> sym.dynamic_symbol_value
      | Nothing -> 0 (* This isn't pretty, but doing something else would be complicated *)
    end in

    apply_relocation abi f img base reloc_site.ref_relent symref_and_reloc_site sym_addr
  (* ) tags_and_ranges in *)
  ) img symbol_refs_and_reloc_sites

let amd64_address_size : natural = 8

let init_amd64_pltgot img base dyns =
  let maybe_pltgot_offset = List.find (fun (tag, _) ->
    tag = Elf_dynamic.dt_pltgot
  ) dyns in
  match maybe_pltgot_offset with
    | Just (_, Address pltgot_offset) ->
      let pltgot_addr = base + natural_of_elf64_addr pltgot_offset in
      let _ = Missing_pervasives.errln ("Initializing PLTGOT at 0x" ^ (hex_string_of_natural pltgot_addr)) in
      (* The second entry contains a linker-specific value. FreeBSD's rtld-elf
         uses it to store ta pointer to an internal data structure, glibc's
         linker leaves it zeroed. *)
      let img = mask_memory_image img (pltgot_addr + amd64_address_size) amd64_address_size in
      (* The third entry contains the dynamic linker entry point *)
      let img = mask_memory_image img (pltgot_addr + 2 * amd64_address_size) amd64_address_size in
      img
    | Nothing ->
      let _ = Missing_pervasives.errln ("No DT_PLTGOT in .dynamic, skipping PLTGOT initialization") in
      img
  end

let mips64_address_size : natural = 8

val apply_mips64_local_got_relocations : forall 'abifeature. annotated_memory_image 'abifeature -> natural -> natural -> natural -> (annotated_memory_image 'abifeature * natural)
let rec apply_mips64_local_got_relocations img base got_entry_addr local_gotno =
  if local_gotno = 0 then (img, got_entry_addr) else
  let _ = Missing_pervasives.errln ("MIPS local .got relocation at 0x" ^ (hex_string_of_natural got_entry_addr) ^ " (remaining: " ^ (show local_gotno) ^ ")") in
  let width = mips64_address_size in
  let existing_bytes = assert_unwrap_maybe (read_memory_image img got_entry_addr width) in
  (* TODO: don't hardcode little endian *)
  let existing_value = Memory_image.natural_of_le_byte_list existing_bytes in
  let new_value = base + existing_value in
  (* TODO: don't hardcode little endian *)
  let field_bytes = Memory_image.natural_to_le_byte_list_padded_to width new_value in
  let field_bp = List.map (fun b -> Just b) field_bytes in
  let _ = Missing_pervasives.errln ("  Relocating MIPS64 local .got entry from 0x" ^ (hex_string_of_natural existing_value) ^ " to 0x" ^ (hex_string_of_natural new_value)) in
  let img = write_memory_image img got_entry_addr field_bp in
  apply_mips64_local_got_relocations img base (got_entry_addr + width) (local_gotno - 1)

let rec apply_mips64_global_got_relocations' abi f img dynsyms syms dynsym_scnidx maybe_versym_table base got_entry_addr (symtabno : natural) =
  if symtabno = 0 then (img, got_entry_addr) else
  match syms with
    | (sym_name, sym_entry, scnidx, symidx) :: syms ->
      let reloc = <|
        elf64_ra_offset = elf64_addr_of_natural (got_entry_addr - base);
        elf64_ra_info = elf64_xword_lshift (elf64_xword_of_natural Abi_mips64_relocation.r_mips_jump_slot) 56;
        elf64_ra_addend = elf64_sxword_of_integer 0
      |> in

      (* TODO: unify this with normal relocs *)
      let maybe_sym =
        (* TODO: remove these special cases, especially the last one *)
        if sym_name <> "" then
          let maybe_sym_version = get_sym_ref_version dynsym_scnidx maybe_versym_table sym_name scnidx symidx in
          let _ = Missing_pervasives.errln ("Searching for symbol `" ^ sym_name ^ "`, version " ^ (show maybe_sym_version)) in
          find_sym dynsyms sym_name maybe_sym_version
        else
          Nothing
      in

      let sym_addr = match maybe_sym with
        | Just sym -> sym.dynamic_symbol_value
        | Nothing -> 0 (* This isn't pretty, but doing something else would be complicated *)
      end in

      (* let sym_addr = base + natural_of_elf64_addr sym_entry.elf64_st_value in *)
      let symref_and_reloc_site = null_symbol_reference_and_reloc_site in
      let img = apply_relocation abi f img base reloc symref_and_reloc_site sym_addr in

      apply_mips64_global_got_relocations' abi f img dynsyms syms dynsym_scnidx maybe_versym_table base (got_entry_addr + mips64_address_size) (symtabno - 1)
    | _ -> failwith "apply_mips64_global_got_relocations': not enough symbols"
  end

let apply_mips64_global_got_relocations f img dynsyms dynsym_scnidx maybe_versym_table base got_entry_addr symtab_addr gotsym symtabno =
  let symtab_triples = mapMaybei (fun scnidx isec ->
    if isec.elf64_section_addr = natural_of_elf64_addr symtab_addr then
      match find_elf64_symbols_by_symtab_idx scnidx f with
        | Fail _ -> Nothing
        | Success triple -> Just triple
      end
    else
      Nothing
  ) f.elf64_file_interpreted_sections in
  let (syms : list (string * elf64_symbol_table_entry * natural (* scnidx *) * natural (* symidx *))) =
    match symtab_triples with
      | [triple] -> Elf_memory_image.extract_all_symbols triple
      | [] -> failwith "apply_mips64_global_got_relocations: no .symtab found"
      | _ -> failwith "apply_mips64_global_got_relocations: multiple .symtab sections not supported for MIPS64"
    end
  in
  let syms = List.drop (natFromNatural gotsym) syms in
  let abi = get_file_abi f in
  apply_mips64_global_got_relocations' abi f img dynsyms syms dynsym_scnidx maybe_versym_table base got_entry_addr (symtabno - gotsym)

(* MIPS uses an ugly packed form for GOT relocations. See musl's do_mips_relocs
   function. *)
let apply_mips64_got_relocations f img dynsyms base dyns dynsym_scnidx maybe_versym_table =
  let maybe_got_offset = List.find (fun (tag, _) -> tag = Elf_dynamic.dt_pltgot) dyns in
  let got_offset = match maybe_got_offset with
    | Just (_, Address got) -> got
    | Nothing -> failwith "apply_mips64_got_relocations: missing DT_PLTGOT in .dynamic"
  end in
  let got_addr = base + natural_of_elf64_addr got_offset in
  let got_entry_addr = got_addr in

  (* Apply local .got relocs *)
  let maybe_local_gotno = List.find (fun (tag, _) ->
    tag = Abi_mips64_dynamic.abi_mips64_dt_local_gotno
  ) dyns in
  let (img, got_entry_addr) = match maybe_local_gotno with
    | Just (_, Numeric local_gotno) ->
      (* The first entry is reserved to hold the address of the entry point in
         the dynamic linker to call when lazy resolving text symbols. The second
         entry is reserved by DSOs linked with GNU's ld to hold the base address
         of the loaded DSO. GNU DSOs have the MSB of the second entry set to 1.
         IRL, some ld.so implementations skip both (uclibc), some relocate both
         (musl), so we'll just don't check those two.
         TODO: check the MSB of the second entry and only mask it if it's GNU. *)
      let reserved_num = 2 in
      let img = mask_memory_image img got_entry_addr (reserved_num * mips64_address_size) in
      let got_entry_addr = got_addr + reserved_num * mips64_address_size in
      let local_gotno = local_gotno - reserved_num in

      let _ = Missing_pervasives.errln ("Applying " ^ (show local_gotno) ^ " MIPS64 local .got relocations") in
      apply_mips64_local_got_relocations img base got_entry_addr local_gotno
    | Nothing ->
      let _ = Missing_pervasives.errln "Not applying MIPS64 .got relocations: missing DT_LOCAL_GOTNO" in
      (img, got_addr)
  end in

  (* Apply R_MIPS_JUMP_SLOT relocs *)
  let maybe_symtab_addr = List.find (fun (tag, _) ->
    tag = Elf_dynamic.dt_symtab
  ) dyns in
  let symtab_addr = match maybe_symtab_addr with
    | Just (_, Address symtab_addr) -> symtab_addr
    | Nothing -> failwith "apply_mips64_got_relocations: missing DT_SYMTAB in .dynamic"
  end in
  let maybe_gotsym = List.find (fun (tag, _) ->
    tag = Abi_mips64_dynamic.abi_mips64_dt_gotsym
  ) dyns in
  let gotsym = match maybe_gotsym with
    | Just (_, Numeric gotsym) -> gotsym
    | Nothing -> failwith "apply_mips64_got_relocations: missing DT_MIPS_GOTSYM in .dynamic"
  end in
  let maybe_symtabno = List.find (fun (tag, _) ->
    tag = Abi_mips64_dynamic.abi_mips64_dt_symtabno
  ) dyns in
  let symtabno = match maybe_symtabno with
    | Just (_, Numeric symtabno) -> symtabno
    | Nothing -> failwith "apply_mips64_got_relocations: missing DT_MIPS_SYMTABNO in .dynamic"
  end in
  let (img, got_entry_addr) = apply_mips64_global_got_relocations f img dynsyms dynsym_scnidx maybe_versym_table base got_entry_addr symtab_addr gotsym symtabno in

  img

let get_first_mapped_address mmap_table filename =
  List.foldl (fun first e ->
    if e.mmap_entry_path <> filename then first else
    let start = e.mmap_entry_start in
    let len = e.mmap_entry_end - start in
    if len = 0 then first else
    match first with
      | Just first -> Just (if start < first then start else first)
      | Nothing -> Just start
    end
  ) Nothing mmap_table

let get_first_memory_image_address img =
  let elements = Map_extra.toList img.elements in
  List.foldl (fun first (_, e) ->
    if assert_unwrap_maybe e.length = 0 then first else
    let start = assert_unwrap_maybe e.startpos in
    match first with
      | Just first -> Just (if start < first then start else first)
      | Nothing -> Just start
    end
  ) Nothing elements

let get_load_segment_at_offset f offset =
  let l = List.filter (fun seg ->
    seg.elf64_segment_type = Elf_program_header_table.elf_pt_load &&
      offset >= seg.elf64_segment_offset &&
      offset < seg.elf64_segment_offset + seg.elf64_segment_size
  ) f.elf64_file_interpreted_segments in
  match l with
    | [seg] -> Just seg
    | [] -> Nothing
    | _ -> failwith ("get_load_segment_at_offset: multiple segments found at offset 0x" ^ (hex_string_of_natural offset))
  end

(** Check that the offsets between sections are preserved.

    For each LOAD segment in the binary, compute the virtual address where it
    should have been loaded, check that a page has been mmapped there, and check
    that the mmapped file offset is correct. *)
let check_mmaped_memory_image mmap_table binary_filename binary_file binary_delta =
  (* TODO: check the file has been mmaped at only one place? *)
  Error.foldM (fun () seg ->
    if seg.elf64_segment_type <> Elf_program_header_table.elf_pt_load then return () else
    let seg_addr = seg.elf64_segment_base + binary_delta in
    (* let _ = Missing_pervasives.errln ("Checking LOAD segment at 0x" ^ (hex_string_of_natural seg.elf64_segment_base) ^ ", virtual address 0x" ^ (hex_string_of_natural seg_addr)) in *)
    match get_mmap_entry_at mmap_table seg_addr with
      | Just e ->
        if e.mmap_entry_path = binary_filename then
          let page_start = e.mmap_entry_start in
          let page_file_offset = e.mmap_entry_offset in
          (* let _ = Missing_pervasives.errln ("  Matching page has virtual address 0x" ^ (hex_string_of_natural page_start) ^ " and offset 0x" ^ (hex_string_of_natural page_file_offset)) in *)
          let seg_offset_in_page = seg_addr - page_start in
          (* let _ = Missing_pervasives.errln ("  Segment offset in page: 0x" ^ (hex_string_of_natural seg_offset_in_page)) in *)
          let expected_seg_file_offset = page_file_offset + seg_offset_in_page in
          if seg.elf64_segment_offset = expected_seg_file_offset then
            return ()
          else
            Error.fail ("check_mmaped_memory_image: LOAD segment at 0x" ^ (hex_string_of_natural seg.elf64_segment_base) ^ " has invalid offset: has 0x" ^ (hex_string_of_natural seg.elf64_segment_offset) ^ ", expected 0x" ^ (hex_string_of_natural expected_seg_file_offset))
        else
          Error.fail ("check_mmaped_memory_image: LOAD segment at 0x" ^ (hex_string_of_natural seg.elf64_segment_base) ^ " has been mmapped to another file: `" ^ e.mmap_entry_path ^ "`")
      | Nothing ->
        Error.fail ("check_mmaped_memory_image: LOAD segment at 0x" ^ (hex_string_of_natural seg.elf64_segment_base) ^ " has not been mmapped at 0x" ^ (hex_string_of_natural seg_addr))
    end
  ) () binary_file.elf64_file_interpreted_segments

let get_memory_image_delta img addr =
  let img_addr = assert_unwrap_maybe (get_first_memory_image_address img) in
  addr - img_addr

let translate_memory_image img offset =
  let elements = Map.map (fun e ->
    let start = assert_unwrap_maybe e.startpos in
    <|
      startpos = Just (start + offset);
      length = e.length;
      contents = e.contents
    |>
  ) img.elements in
  <|
    elements = elements;
    by_range = img.by_range;
    by_tag = img.by_tag
  |>

val get_memory_image_stats : forall 'abifeature. annotated_memory_image 'abifeature -> (natural * natural)
let get_memory_image_stats img =
  List.foldl (fun stats (_, el) ->
    List.foldl (fun (n_bytes, n_masked) maybe_b ->
      let masked = match maybe_b with
        | Just _ -> false
        | Nothing -> true
      end in
      (n_bytes + 1, if masked then n_masked + 1 else n_masked)
    ) stats el.contents
  ) (0, 0) (Map_extra.toList img.elements)

let read_dynamic bs f =
  let endian = get_elf64_header_endianness f.elf64_file_header in
  let sht = f.elf64_file_section_header_table in
  let shared_object = is_elf64_shared_object_file f.elf64_file_header in
  let os_additional_ranges = gnu_ext_os_additional_ranges in
  let os = gnu_ext_tag_correspondence_of_tag in
  let os_dyn = gnu_ext_elf64_value_of_elf64_dyn in
  (* TODO: do not hardcode these *)
  let (proc, proc_dyn) =
    if Abi_mips64.header_is_mips64 f.elf64_file_header then
      (
        Abi_mips64_dynamic.abi_mips64_tag_correspondence_of_tag,
        Abi_mips64_dynamic.abi_mips64_elf64_value_of_elf64_dyn
      )
    else
      (* These are no-ops *)
      (
        (fun _ -> Error.fail "tag_correspondence_of_tag: unknown tag"),
        (fun _ _ -> Error.fail "elf64_value_of_elf64_dyn: unknown tag")
      )
  in
  obtain_elf64_dynamic_section_contents f os_additional_ranges os proc bs >>= fun dyns ->
  get_string_table_of_elf64_dyn_section endian dyns sht bs >>= fun stbl ->
  Error.mapM (fun dyn ->
    let tag = naturalFromInteger (integer_of_elf64_sxword dyn.elf64_dyn_tag) in
    get_value_of_elf64_dyn shared_object dyn os_additional_ranges os_dyn proc_dyn stbl >>= fun dyn_value ->
    return (tag, dyn_value)
  ) dyns

let has_dynamic_section f =
  let dyn_secs = List.filter (fun sec ->
    natural_of_elf64_word sec.elf64_sh_type = Elf_section_header_table.sht_dynamic
  ) f.elf64_file_section_header_table in
  dyn_secs <> []

let sym_add_verdef sym verdef =
  (* let _ = Missing_pervasives.errln ("Symbol `" ^ sym.dynamic_symbol_name ^ "`, version `" ^ verdef_aux ^ "`") in *)
  <|
    dynamic_symbol_name = sym.dynamic_symbol_name;
    dynamic_symbol_entry = sym.dynamic_symbol_entry;
    dynamic_symbol_value = sym.dynamic_symbol_value;
    dynamic_symbol_version = Just verdef.gnu_ext_interpreted_verdef_name;
    dynamic_symbol_version_base =
      (* TODO: what's the difference between those two? *)
      verdef.gnu_ext_interpreted_verdef_ndx = gnu_ext_verdef_base_unspecified
      || verdef.gnu_ext_interpreted_verdef_ndx = gnu_ext_verdef_base_versioned
  |>

let extract_dynsyms f base existing_syms symtab_scnidx maybe_versym_table =
  let symtab_scn = assert_unwrap_maybe (List.index f.elf64_file_interpreted_sections (natFromNatural symtab_scnidx)) in

  find_elf64_symbols_by_symtab_idx symtab_scnidx f >>= fun triple ->
  let syms = Elf_memory_image.extract_all_symbols triple in
  let syms = List.filter (fun (sym_name, sym_entry, scnidx, symidx) ->
    let sym_binding = get_elf64_symbol_binding sym_entry in
    let sym_value = natural_of_elf64_addr sym_entry.elf64_st_value in
    (sym_binding = Elf_symbol_table.stb_global || sym_binding = Elf_symbol_table.stb_weak)
      (* We're only interested in symbols defined in this DSO *)
      && natural_of_elf64_half sym_entry.elf64_st_shndx <> 0
  ) syms in
  let syms = List.map (fun (sym_name, sym_entry, scnidx, symidx) ->
    let _ = Missing_pervasives.errln ("Library exports dynamic symbol: " ^ sym_name) in
    let sym_value = base + natural_of_elf64_addr sym_entry.elf64_st_value in
    let sym = <|
      dynamic_symbol_name = sym_name;
      dynamic_symbol_entry = sym_entry;
      dynamic_symbol_value = sym_value;
      dynamic_symbol_version = Nothing;
      dynamic_symbol_version_base = false
    |> in
    (sym, symidx)
  ) syms in

  match maybe_versym_table with
    | Just versym_table ->
      if List.length versym_table.gnu_ext_interpreted_versym_table_entries < List.length syms then
        Error.fail "extract_dynsyms: versym table too short"
      else
        return ()
      >>= fun () ->
      Error.foldM (fun syms (sym, symidx) ->
        get_gnu_ext_interpreted_verdef versym_table symidx >>= fun verdef_lookup ->
        let versioned_sym = match verdef_lookup with
          | GnuExtInterpretedVerdefVersion verdef ->
            sym_add_verdef sym verdef
          | GnuExtInterpretedVerdefHidden verdef ->
            (* TODO: symbol is hidden and cannot be referenced outside of this object *)
            sym_add_verdef sym verdef
          | _ -> sym (* TODO: ignore local dynsyms? *)
        end in
        return (versioned_sym :: syms)
      ) [] syms
    | Nothing ->
      let syms = List.map (fun (sym, symidx) -> sym) syms in
      return syms
  end >>= fun syms ->

  let syms = List.foldl (fun syms sym ->
    let sym_name = sym.dynamic_symbol_name in
    let sym_entry = sym.dynamic_symbol_entry in
    let sym_addr = sym.dynamic_symbol_value in
    let sym_version = sym.dynamic_symbol_version in
    let sym_binding = get_elf64_symbol_binding sym_entry in
    let _ = Missing_pervasives.errln ("Processing symbol `" ^ sym_name ^ "`, 0x" ^ (hex_string_of_natural sym_addr) ^ ", binding=" ^ (show sym_binding) ^ ", version=" ^ (show sym_version)) in
    let maybe_existing = List.find (fun sym -> sym.dynamic_symbol_name = sym_name && sym.dynamic_symbol_version = sym_version) existing_syms in
    match maybe_existing with
      | Just existing ->
        let existing_entry = existing.dynamic_symbol_entry in
        let existing_addr = existing.dynamic_symbol_value in
        if get_elf64_symbol_binding existing_entry = Elf_symbol_table.stb_weak && sym_binding <> Elf_symbol_table.stb_weak then
          (* Existing symbol is weak and the new one isn't, replace it *)
          let _ = Missing_pervasives.errln ("Overriding weak symbol `" ^ sym_name ^ "`, 0x" ^ (hex_string_of_natural existing_addr) ^ " -> 0x" ^ (hex_string_of_natural sym_addr)) in
          sym :: syms
        else if natural_of_elf64_half existing_entry.elf64_st_shndx = 0 && natural_of_elf64_half sym_entry.elf64_st_shndx <> 0 then
          (* Existing symbol has an undefined ndx and the new one has a defined one, replace it *)
          (* TODO: why is this the right thing to do? *)
          let _ = Missing_pervasives.errln ("Overriding symbol with undefined ndx `" ^ sym_name ^ "`, 0x" ^ (hex_string_of_natural existing_addr) ^ " -> 0x" ^ (hex_string_of_natural sym_addr)) in
          sym :: syms
        else
          let _ = Missing_pervasives.errln ("Multiple definitions of `" ^ sym_name ^ "` version " ^ (show sym_version) ^ ", only keeping the first one") in
          syms
      | Nothing ->
        sym :: syms
    end
  ) [] syms in
  return syms

let rec find_library root_path ld_library_paths soname =
  match ld_library_paths with
    | [] ->
      Error.fail ("find_library: cannot find library `" ^ soname ^ "`")
    | dir :: ld_library_paths ->
      (* TODO: this is a hack to skip 32-bit library dirs. Instead we should load the DSO and check its header *)
      if Missing_pervasives.string_contains dir "32" then find_library root_path ld_library_paths soname else
      let filename = dir ^ "/" ^ soname in
      if Filesystem.file_exists (root_path ^ filename) then
        return filename
      else
        find_library root_path ld_library_paths soname
  end

let get_dynsym_section_index f dyns =
  let maybe_dt_symtab = List.find (fun (tag, _) -> tag = Elf_dynamic.dt_symtab) dyns in
  match maybe_dt_symtab with
    | Just (_, Address dt_symtab) ->
      let dt_symtab = natural_of_elf64_addr dt_symtab in
      let maybe_symtab_scnidx = List.findIndex (fun scn ->
        scn.elf64_section_addr = dt_symtab
      ) f.elf64_file_interpreted_sections in
      match maybe_symtab_scnidx with
        | Just scnidx -> return (naturalFromNat scnidx)
        | Nothing -> Error.fail ("get_dynsym_section: no symtab section at 0x" ^ (hex_string_of_natural dt_symtab))
      end
    | Nothing ->
      Error.fail "get_dynsym_section: missing DT_SYMTAB in .dynamic"
  end

let rec check_binary ldconfig_paths core_file core_img is_loaded root_path mmap_table dynsyms binary_filename is_root =
  Filesystem.realpath_in root_path (root_path ^ binary_filename) >>= fun binary_filepath ->
  let _ = Missing_pervasives.errln ("Resolved symlinks: " ^ (root_path ^ binary_filename) ^ " -> " ^ binary_filepath) in
  let binary_filename = assert_unwrap_maybe (Missing_pervasives.string_suffix (naturalFromNat (String.stringLength root_path)) binary_filepath) in

  let _ = Missing_pervasives.errln ("Loading binary from " ^ binary_filepath) in
  load_file binary_filepath >>= fun (binary_bs, binary_file) ->
  let _ = Missing_pervasives.errln "Binary file:" in
  let _ = print_elf64_phdr binary_file in

  let binary_img = load_memory_image binary_file in
  let _ = Missing_pervasives.errln "Binary image:" in
  let _ = print_memory_image binary_img in

  let binary_img =
    if is_loaded then
      let binary_img = mask_data_sections binary_file binary_img in
      binary_img
    else
      let _ = Missing_pervasives.errln "Not masking memory image" in
      binary_img
  in

  let (n_bytes, n_masked) = get_memory_image_stats binary_img in
  let _ = Missing_pervasives.errln ((show n_bytes) ^ " bytes, " ^ (show n_masked) ^ " masked bytes after masking") in

  let _ = Missing_pervasives.errln ("Searching binary " ^ binary_filename ^ " in mmap table") in
  let errmsg = "check_binary: cannot find `" ^ binary_filename ^ "` in the mmap table" in
  Error.of_maybe errmsg (get_first_mapped_address mmap_table binary_filename) >>= fun binary_addr ->
  let _ = Missing_pervasives.errln ("Binary has been mapped at 0x" ^ (hex_string_of_natural binary_addr)) in
  let binary_delta = get_memory_image_delta binary_img binary_addr in
  let _ = Missing_pervasives.errln ("Binary has delta 0x" ^ (hex_string_of_natural binary_delta)) in
  check_mmaped_memory_image mmap_table binary_filename binary_file binary_delta >>= fun () ->
  let _ = Missing_pervasives.errln "Translating binary image" in
  let binary_img = translate_memory_image binary_img binary_delta in
  let _ = Missing_pervasives.errln "Binary image after translation:" in
  let _ = print_memory_image binary_img in

  let maybe_dyns_res =
    if has_dynamic_section binary_file then
      let _ = Missing_pervasives.errln ("Reading .dynamic section") in
      read_dynamic binary_bs binary_file >>= fun dyns ->
      return (Just dyns)
    else
      return Nothing
  in
  maybe_dyns_res >>= fun maybe_dyns ->

  match maybe_dyns with
    | Just dyns ->
      get_dynsym_section_index binary_file dyns >>= fun dynsym_scnidx ->
      let _ = Missing_pervasives.errln ("Extracting dynamic symbol version info from " ^ binary_filename ^ " (if any)") in
      obtain_gnu_ext_elf64_interpreted_versym_table binary_file dyns >>= fun maybe_versym_table ->
      let _ = Missing_pervasives.errln ("Extracting dynamic symbols from " ^ binary_filename) in
      extract_dynsyms binary_file binary_delta dynsyms dynsym_scnidx maybe_versym_table >>= fun binary_dynsyms ->
      let _ = Missing_pervasives.errln ("Binary exports " ^ (show (List.length binary_dynsyms)) ^ " dynamic symbols") in
      return (dynsym_scnidx, binary_dynsyms, maybe_versym_table)
    | Nothing ->
      return (0, [], Nothing)
  end >>= fun (dynsym_scnidx, binary_dynsyms, maybe_versym_table) ->

  let dynsyms = dynsyms ++ binary_dynsyms in

  let maybe_interp_seg =
    if is_root then
      List.find (fun seg ->
        seg.elf64_segment_type = Elf_program_header_table.elf_pt_interp
      ) binary_file.elf64_file_interpreted_segments
    else
      Nothing (* libraries' INTERP should be ignored *)
  in
  match maybe_interp_seg with
    | Just interp_seg ->
      Elf_note.read_string interp_seg.elf64_segment_body >>= fun (interp, _) ->
      (* TODO: these are glibc's ld.so. They need special treatement because
         they expect their relocations to be linked to libc.so even if they
         don't depend on it. There's probably a special pre-linker code that
         runs in ld.so to do this - should investigate this. *)
      if interp = "/lib64/ld-linux-x86-64.so.2" || interp = "/lib64/ld.so.1" then
        let _ = Missing_pervasives.errln ("Ignoring requested interpreter " ^ interp) in
        return Nothing
      else
        return (Just interp)
    | Nothing ->
      return Nothing
  end >>= fun maybe_interp ->
  let dynsyms_res = match maybe_interp with
    | Just interp ->
      let _ = Missing_pervasives.errln ("Requesting program interpreter: " ^ interp) in
      check_binary ldconfig_paths core_file core_img is_loaded root_path mmap_table dynsyms interp false
    | Nothing ->
      return dynsyms
  end in
  dynsyms_res >>= fun dynsyms ->

  (* Result contains the number of linked libraries *)
  let linked_libs_res =
    if not is_loaded then
      let _ = Missing_pervasives.errln "Core file hasn't been loaded; not checking linked libraries" in
      return (0, [], [])
    else
      match maybe_dyns with
        | Nothing ->
          let _ = Missing_pervasives.errln "Binary doesn't have a .dynamic section; not checking linked libraries" in
          return (0, [], [])
        | Just dyns ->
          let _ = Missing_pervasives.errln "Checking linked libraries" in
          read_dynamic binary_bs binary_file >>= fun dyns ->

          let dyn_dt_needed = List.filter (fun (tag, _) -> tag = Elf_dynamic.dt_needed) dyns in
          let _ = Missing_pervasives.errln ("Found " ^ (show (List.length dyn_dt_needed)) ^ " linked libraries") in
          let dt_needed_res = Error.mapM (fun (_, dyn_value) ->
            match dyn_value with
              | Library soname ->
                (* TODO: remove this hack. This probably just means keeping a list
                   of loaded SONAME strings and check it's not already loaded now
                   that we support INTERP segments. *)
                let paths =
                  if soname = "libc.so" && Abi_mips64.header_is_mips64 binary_file.elf64_file_header && Missing_pervasives.string_contains binary_filepath "musl" then
                    ["/lib/mips64el-linux-musl"]
                  else
                    ldconfig_paths
                in
                let _ = Missing_pervasives.errln ("Searching needed library `" ^ soname ^ "`") in
                find_library root_path paths soname
              | _ -> Error.fail "got a DT_NEEDED with something else than a Library"
            end
          ) dyn_dt_needed in
          dt_needed_res >>= fun dt_needed ->
          let check_res = Error.foldM (fun dynsyms library_filepath ->
            check_binary ldconfig_paths core_file core_img is_loaded root_path mmap_table dynsyms library_filepath false
          ) dynsyms dt_needed in
          check_res >>= fun dynsyms ->
          return (naturalFromNat (List.length dyn_dt_needed), dynsyms, dyns)
      end
  in

  linked_libs_res >>= fun (libs_count, dynsyms, dyns) ->
  let _ = if libs_count > 0 then
    Missing_pervasives.errln ("OK: " ^ (show libs_count) ^ " libraries linked to " ^ binary_filepath ^ " match!")
  else () in

  let binary_img =
    if is_loaded then
      let _ = Missing_pervasives.errln ("Applying relocations in " ^ binary_filename) in
      let binary_img = apply_all_relocations binary_file binary_img binary_delta dynsyms dynsym_scnidx maybe_versym_table in
      let binary_img =
        if Abi_mips64.header_is_mips64 binary_file.elf64_file_header &&
            has_dynamic_section binary_file then
          apply_mips64_got_relocations binary_file binary_img dynsyms binary_delta dyns dynsym_scnidx maybe_versym_table
        else if Abi_amd64.header_is_amd64 binary_file.elf64_file_header &&
            has_dynamic_section binary_file then
          init_amd64_pltgot binary_img binary_delta dyns
        else
          binary_img
      in
      binary_img
    else
      binary_img
  in

  let (n_bytes, n_masked) = get_memory_image_stats binary_img in
  let _ = Missing_pervasives.errln ((show n_bytes) ^ " bytes, " ^ (show n_masked) ^ " masked bytes") in

  let _ = Missing_pervasives.errln ("Checking memory image of " ^ binary_filename) in
  let comparison_res = compare_memory_image core_img binary_img (mmap_table, binary_file, binary_delta) in

  match comparison_res with
    | Success () ->
      let _ = Missing_pervasives.errln ("OK: " ^ binary_filepath ^ " matches!") in
      return dynsyms
    | Fail msg ->
      Error.fail (binary_filepath ^ " mismatches: " ^ msg)
  end

let process_file core_filepath maybe_root_path maybe_binary_filename =
  let root_path = match maybe_root_path with
    | Just root_path -> root_path ^ "/"
    | Nothing -> ""
  end in

  Ldconfig.read_ldconfig_paths root_path >>= fun ldconfig_paths ->

  load_file core_filepath >>= fun (core_bs, core_file) ->
  let elf_type = natural_of_elf64_half core_file.elf64_file_header.elf64_type in
  if elf_type <> Elf_header.elf_ft_core then Error.fail ("process_file: `" ^ core_filepath ^ "` is not a core file") else
  let endian = get_elf64_header_endianness core_file.elf64_file_header in
  Elf_note.obtain_elf64_note_segments endian core_file.elf64_file_program_header_table core_bs >>= fun note_segs ->

  read_nt_file_entries endian note_segs >>= fun nt_file_entries ->
  read_nt_procstat_vmmap endian note_segs >>= fun nt_procstat_vmmap ->
  (* TODO: don't allow both mmap table types to be present at the same time *)
  let mmap_table = nt_file_entries ++ nt_procstat_vmmap in
  if List.null mmap_table then Error.fail ("process_file: mmap table of core file `" ^ core_filepath ^ "` is empty") else

  read_nt_auxv_execfn endian note_segs core_file >>= fun maybe_execfn ->
  read_nt_procstat_psstrings_argv0 endian note_segs core_file >>= fun maybe_psstrings_argv0 ->
  let maybe_detected_binary_filename = match maybe_execfn with
    | Just _ -> maybe_execfn
    | Nothing -> maybe_psstrings_argv0
  end in
  let _ = Missing_pervasives.errln ("Detected binary filename: " ^ (show maybe_detected_binary_filename)) in

  let binary_filename_res = match (maybe_binary_filename, maybe_detected_binary_filename) with
    | (Just binary_filename, Just detected_binary_filename) ->
      let _ =
        if binary_filename <> detected_binary_filename then
          Missing_pervasives.errln ("warning: binary filename `" ^ binary_filename ^ "` mismatches detected filename `" ^ detected_binary_filename ^ "`")
        else
          ()
      in
      return binary_filename
    | (Just binary_filename, Nothing) -> return binary_filename
    | (Nothing, Just detected_binary_filename) -> return detected_binary_filename
    | (Nothing, Nothing) ->
      Error.fail "process_file: cannot detect binary filename in ELF notes, please provide it"
  end in
  binary_filename_res >>= fun binary_filename ->

  let _ = Missing_pervasives.errln "Core file:" in
  let _ = print_elf64_phdr core_file in

  let core_img = load_memory_image core_file in
  let _ = Missing_pervasives.errln "Core image:" in
  let _ = print_memory_image core_img in

  (* Data sections have to be masked if coredump has been generated after _start *)
  (* TODO: add a flag instead of this hacky thing *)
  let is_loaded = not (Missing_pervasives.string_contains core_filepath "start") in

  check_binary ldconfig_paths core_file core_img is_loaded root_path mmap_table [] binary_filename true >>= fun _ ->

  return ()

let _ =
  let args = match Missing_pervasives.argv with
    | _::args -> args
    | _ -> []
  end in
  let (core_filepath, maybe_root_path, maybe_binary_filename) = match args with
    | [core_filepath] -> (core_filepath, Nothing, Nothing)
    | [core_filepath; root_path] -> (core_filepath, Just root_path, Nothing)
    | [core_filepath; root_path; binary_filename] -> (core_filepath, Just root_path, Just binary_filename)
    | _ -> Assert_extra.failwith "usage: main_load <core-file> [root] [binary-filename]"
  end in
  match process_file core_filepath maybe_root_path maybe_binary_filename with
    | Fail err -> failwith err
    | Success () -> Missing_pervasives.errln "OK: ALL GREEN"
  end
