(* -*-tuareg-*- *)
open import Basic_classes
open import Bool
open import Function
open import Maybe
open import Num
open import String

open import List (* TODO: check why this is not imported in ELF *)

open import Byte_sequence
open import Error
open import Hex_printing
open import Missing_pervasives
open import Show

open import Default_printing

open import Endianness
open import String_table

open import Elf_dynamic
open import Elf_file
open import Elf_header
open import Elf_program_header_table
open import Elf_relocation
open import Elf_section_header_table
open import Elf_symbol_table
open import Elf_types_native_uint


(** ***************** experimental DWARF reading *********** *)
 
(*

This defines a representation of some of the DWARF debug information,
with parsing functions to extract it from the byte sequences of the
relevant ELF sections, and pretty-printing function to dump it in a
human-readable form, similar to that of readelf.  The main functions
for this are:

  val extract_dwarf : elf64_file -> maybe dwarf
  val pp_dwarf : dwarf -> string

It also defines evaluation of DWARF expressions and analysis functions
to convert the variable location information to a form suitable for
looking up variable names from machine addresses that arise during
execution, including the call frame address calculation.  The main
types and functions for this are:

  type analysed_location_data
  val analyse_locations : dwarf -> analysed_location_data

  type evaluated_frame_info
  val evaluate_frame_info : dwarf -> evaluated_frame_info

  type dwarf_static
  val extract_dwarf_static : elf64_file -> maybe dwarf_static

The last collects all the above - information that can be computed statically.

Then to do lookup from addresses to source-code names, we have:

  type analysed_location_data_at_pc
  val analysed_locations_at_pc : evaluation_context -> dwarf_static -> natural -> analysed_location_data_at_pc
  val names_of_address : dwarf -> analysed_location_data_at_pc -> natural -> list string

The definitions are deliberately simple-minded, to be quick to write,
easy to see the correspondence to the DWARF text specification, and
potentially support generation of theorem-prover definitions in
future.  They are in a pure functional style, making the information
dependencies explicit.  They are not written for performance, though
they may be efficient enough for small examples as-is.  They are
written in Lem, and compiled from that to executable OCaml.

The development follows the DWARF 4 pdf specification at http://www.dwarfstd.org/
though tweaked in places where our examples use earlier versions.  It doesn't
systematically cover all the DWARF versions.
It doesn't cover the GNU extensions
(at https://fedorahosted.org/elfutils/wiki/DwarfExtensions).
The representation, parsing, and pretty printing are mostly complete for the
data in these DWARF ELF sections:

.debug_abbrev
.debug_info
.debug_types
.debug_loc
.debug_str
.debug_ranges
.debug_frame (without augmentations)
.debug_line

The following DWARF ELF sections are not covered:

.debug_aranges
.debug_macinfo
.debug_pubnames
.debug_pubtypes

The evaluation of DWARF expressions covers only some of the operations
- probably enough for common cases.

The analysis of DWARF location data should be enough to look up names
from the addresses of variables and formal parameters.  It does not
currently handle the DWARF type data, so will not be useful for accesses
strictly within the extent of a variable or parameter.

The 'dwarf' type gives a lightly parsed representation of some of the
dwarf information, with the byte sequences of the above .debug_*
sections parsed into a structured representation.  That makes the list
and tree structures explicit, and converts the various numeric types
into just natural, integer, and byte sequences.  The lem natural and
integer could be replaced by unsigned and signed 64-bit types; that'd
probably be better for execution but not for theorem-prover use.

*)

(* some spec ambiguities (more in comments in-line below): *)
(*  can a location list be referenced from multiple compilation units, with different base addresses? *)


(** debug *)

(* workaround debug.lem linking *)
val print_endline : string -> unit
declare ocaml target_rep function print_endline = `print_endline`

let my_debug s = () (*print_endline s*)
let my_debug2 s = () (*print_endline s*)
let my_debug3 s = () (*print_endline s*)
let my_debug4 s = print_endline s
let my_debug5 s = print_endline s


(** ************************************************************ *)
(** **  dwarf representation types  **************************** *)
(** ************************************************************ *)


type dwarf_attribute_classes =
  | DWA_7_5_3
  | DWA_address
  | DWA_block
  | DWA_constant
  | DWA_dash
  | DWA_exprloc
  | DWA_flag
  | DWA_lineptr
  | DWA_loclistptr
  | DWA_macptr
  | DWA_rangelistptr
  | DWA_reference
  | DWA_string

(* operations and expression evalution *)

type operation_argument_type =
  | OAT_addr
  | OAT_dwarf_format_t
  | OAT_uint8
  | OAT_uint16
  | OAT_uint32
  | OAT_uint64
  | OAT_sint8
  | OAT_sint16
  | OAT_sint32
  | OAT_sint64
  | OAT_ULEB128
  | OAT_SLEB128
  | OAT_block

type operation_argument_value =
  | OAV_natural of natural
  | OAV_integer of integer
  | OAV_block of natural * byte_sequence

type operation_stack = list natural

type arithmetic_context =
  <|
  ac_bitwidth: natural;
  ac_half: natural;  (* 2 ^ (ac_bitwidth -1) *)
  ac_all: natural;   (* 2 ^ ac_bitwidth      *)
  ac_max: natural;   (* (2 ^ ac_bitwidth) -1 *) (* also the representation of -1 *)
|>

type operation_semantics =
  | OpSem_lit
  | OpSem_deref
  | OpSem_stack of (arithmetic_context -> operation_stack -> list operation_argument_value -> maybe operation_stack)
  | OpSem_not_supported
  | OpSem_binary of (arithmetic_context -> natural -> natural -> maybe natural)
  | OpSem_unary of (arithmetic_context -> natural -> maybe natural)
  | OpSem_opcode_lit of natural
  | OpSem_reg
  | OpSem_breg
  | OpSem_bregx
  | OpSem_fbreg
  | OpSem_deref_size
  | OpSem_nop
  | OpSem_piece
  | OpSem_bit_piece
  | OpSem_implicit_value
  | OpSem_stack_value
  | OpSem_call_frame_cfa

type operation =
    <|
    op_code: natural;
    op_string: string;
    op_argument_values: list operation_argument_value;
    op_semantics: operation_semantics;
  |>


(* the result of a location expression evaluation is a single_location  (or failure) *)

type simple_location =
  | SL_memory_address of natural
  | SL_register of natural
  | SL_implicit of byte_sequence  (* used for implicit and stack values *)
  | SL_empty

type composite_location_piece =
  | CLP_piece of natural * simple_location
  | CLP_bit_piece of natural * natural * simple_location

type single_location =
  | SL_simple of simple_location
  | SL_composite of list composite_location_piece

(* location expression evaluation is a stack machine operating over the following state *)

type state =
    <|
    s_stack: operation_stack;
    s_value: simple_location;
    s_location_pieces: list composite_location_piece;
  |>

(* location expression evaluation can involve register and memory reads, via the following interface *)

type register_read_result 'a =
  | RRR_result of natural
  | RRR_not_currently_available
  | RRR_bad_register_number

type memory_read_result 'a =
  | MRR_result of natural
  | MRR_not_currently_available
  | MRR_bad_address

type evaluation_context =
    <|
    read_register: natural -> register_read_result natural;
    read_memory: natural -> natural -> memory_read_result natural;
  |>


(* dwarf sections *)

type dwarf_format =
  | Dwarf32
  | Dwarf64

(* .debug_abbrev section *)

type abbreviation_declaration =
    <|
    ad_abbreviation_code: natural;
    ad_tag: natural;
    ad_has_children: bool;
    ad_attribute_specifications: list (natural * natural);
  |>

type abbreviations_table =
  <|
    at_offset: natural;
    at_table: list abbreviation_declaration;
|>

(* .debug_info section *)

type attribute_value =  (* following Figure 3 *)
  | AV_addr of natural
  | AV_block of natural * byte_sequence
  | AV_constantN of natural * byte_sequence
  | AV_constant_SLEB128 of integer
  | AV_constant_ULEB128 of natural
  | AV_exprloc of natural * byte_sequence
  | AV_flag of bool
  | AV_ref of natural
  | AV_ref_addr of natural (* dwarf_format dependent *)
  | AV_ref_sig8 of natural
  | AV_sec_offset of natural
  | AV_string of byte_sequence (* not including terminating null *)
  | AV_strp of natural (* dwarf_format dependent *)


type die =
    <|
    die_offset: natural;
    die_abbreviation_code: natural;
    die_abbreviation_declaration: abbreviation_declaration;
    die_attribute_values: list (natural (*pos*) * attribute_value);
    die_children: list die;
  |>

type die_index = Map.map natural (list die * die)

type compilation_unit_header =
    <|
    cuh_offset: natural;
    cuh_dwarf_format: dwarf_format;
    cuh_unit_length: natural;
    cuh_version: natural;
    cuh_debug_abbrev_offset: natural;
    cuh_address_size: natural;
  |>

type compilation_unit =
    <|
    cu_header: compilation_unit_header;
    cu_abbreviations_table: abbreviations_table;
    cu_die: die;
    cu_index: die_index
  |>

type compilation_units = list compilation_unit

(* .debug_type section *)

type type_unit_header =
    <|
    tuh_cuh: compilation_unit_header;
    tuh_type_signature: natural;
    tuh_type_offset: natural;
  |>

type type_unit =
    <|
    tu_header: type_unit_header;
    tu_abbreviations_table: abbreviations_table;
    tu_die: die;
  |>

type type_units = list type_unit

(* .debug_loc section *)

type single_location_description = byte_sequence

type location_list_entry =
    <|
    lle_beginning_address_offset: natural;
    lle_ending_address_offset: natural;
    lle_single_location_description: single_location_description;
  |>

type base_address_selection_entry =
    <|
    base_address: natural;
  |>

type location_list_item =
  | LLI_lle of location_list_entry
  | LLI_base of base_address_selection_entry

type location_list = natural (*offset*) * list location_list_item

type location_list_list = list location_list

(* .debug_ranges section *)

type range_list_entry =
    <|
    rle_beginning_address_offset: natural;
    rle_ending_address_offset: natural;
  |>

type range_list_item =
  | RLI_rle of range_list_entry
  | RLI_base of base_address_selection_entry

type range_list = natural (*offset (of range_list from start of .debug_ranges section?) *) * list range_list_item

type range_list_list = list range_list

(* .debug_frame section: call frame instructions *)

type cfa_address = natural
type cfa_block = byte_sequence
type cfa_delta = natural
type cfa_offset = natural
type cfa_register = natural
type cfa_sfoffset = integer

type call_frame_argument_type =
  | CFAT_address
  | CFAT_delta1
  | CFAT_delta2
  | CFAT_delta4
  | CFAT_delta_ULEB128
  | CFAT_offset   (*ULEB128*)
  | CFAT_sfoffset (*SLEB128*)
  | CFAT_register (*ULEB128*)
  | CFAT_block

type call_frame_argument_value =
  | CFAV_address of cfa_address
  | CFAV_block of cfa_block
  | CFAV_delta of cfa_delta
  | CFAV_offset of cfa_offset
  | CFAV_register of cfa_register
  | CFAV_sfoffset of cfa_sfoffset

type call_frame_instruction =
  | DW_CFA_advance_loc         of cfa_delta
  | DW_CFA_offset              of cfa_register * cfa_offset
  | DW_CFA_restore             of cfa_register
  | DW_CFA_nop
  | DW_CFA_set_loc             of cfa_address
  | DW_CFA_advance_loc1        of cfa_delta
  | DW_CFA_advance_loc2        of cfa_delta
  | DW_CFA_advance_loc4        of cfa_delta
  | DW_CFA_offset_extended     of cfa_register * cfa_offset
  | DW_CFA_restore_extended    of cfa_register
  | DW_CFA_undefined           of cfa_register
  | DW_CFA_same_value          of cfa_register
  | DW_CFA_register            of cfa_register * cfa_register
  | DW_CFA_remember_state
  | DW_CFA_restore_state
  | DW_CFA_def_cfa             of cfa_register * cfa_offset
  | DW_CFA_def_cfa_register    of cfa_register
  | DW_CFA_def_cfa_offset      of cfa_offset
  | DW_CFA_def_cfa_expression  of cfa_block
  | DW_CFA_expression          of cfa_register * cfa_block
  | DW_CFA_offset_extended_sf  of cfa_register * cfa_sfoffset
  | DW_CFA_def_cfa_sf          of cfa_register * cfa_sfoffset
  | DW_CFA_def_cfa_offset_sf   of cfa_sfoffset
  | DW_CFA_val_offset          of cfa_register * cfa_offset
  | DW_CFA_val_offset_sf       of cfa_register * cfa_sfoffset
  | DW_CFA_val_expression      of cfa_register * cfa_block
  | DW_CFA_AARCH64_negate_ra_state
  | DW_CFA_unknown             of byte

(* .debug_frame section: top-level *)

type cie =
    <|
    cie_offset: natural;
    cie_length: natural;
    cie_id: natural;
    cie_version: natural;
    cie_augmentation: byte_sequence; (* not including terminating null *)
    cie_address_size: maybe natural;
    cie_segment_size: maybe natural;
    cie_code_alignment_factor: natural;
    cie_data_alignment_factor: integer;
    cie_return_address_register: cfa_register;
    cie_initial_instructions_bytes: byte_sequence;
    cie_initial_instructions: list call_frame_instruction;
  |>

type fde =
    <|
    fde_offset: natural;
    fde_length: natural;
    fde_cie_pointer: natural;
    fde_initial_location_segment_selector: maybe natural;
    fde_initial_location_address: natural;
    fde_address_range: natural;
    fde_instructions_bytes: byte_sequence;
    fde_instructions: list call_frame_instruction;
  |>

type frame_info_element =
  | FIE_cie of cie
  | FIE_fde of fde

type frame_info = list frame_info_element


(* evaluated cfa data *)

type cfa_rule =
  | CR_undefined
  | CR_register of cfa_register * integer
  | CR_expression of single_location_description

type register_rule =
  | RR_undefined (*A register that has this rule has no recoverable value in the previous frame.
         (By convention, it is not preserved by a callee.)*)
  | RR_same_value (*This register has not been modified from the previous frame. (By convention,
          it is preserved by the callee, but the callee has not modified it.)*)
  | RR_offset of integer (* The previous value of this register is saved at the address CFA+N where CFA
         is the current CFA value and N is a signed offset.*)
  | RR_val_offset of integer (* The previous value of this register is the value CFA+N where CFA is the
             current CFA value and N is a signed offset.*)
  | RR_register of natural (* The previous value of this register is stored in another register numbered R.*)
  | RR_expression of single_location_description (* The previous value of this register is located at the address produced by
             executing the DWARF expression E.*)
  | RR_val_expression of single_location_description (* The previous value of this register is the value produced by executing the
DWARF expression E.*)
  | RR_architectural (*The rule is defined externally to this specification by the augmenter*)

type register_rule_map = list (cfa_register * register_rule)

type cfa_table_row =
    <|
    ctr_loc: natural;
    ctr_cfa: cfa_rule;
    ctr_regs: register_rule_map;
  |>

type cfa_state =
    <|
    cs_current_row: cfa_table_row;
    cs_previous_rows: list cfa_table_row;
    cs_initial_instructions_row: cfa_table_row;
    cs_row_stack: list cfa_table_row;
  |>


type evaluated_frame_info =
    list (fde * list cfa_table_row)


(* line number *)

type line_number_argument_type =
  | LNAT_address
  | LNAT_ULEB128
  | LNAT_SLEB128
  | LNAT_uint16
  | LNAT_string

type line_number_argument_value =
  | LNAV_address of natural
  | LNAV_ULEB128 of natural
  | LNAV_SLEB128 of integer
  | LNAV_uint16 of natural
  | LNAV_string of byte_sequence (* not including terminating null *)

type line_number_operation =
  (* standard *)
  | DW_LNS_copy
  | DW_LNS_advance_pc of natural
  | DW_LNS_advance_line of integer
  | DW_LNS_set_file of natural
  | DW_LNS_set_column of natural
  | DW_LNS_negate_stmt
  | DW_LNS_set_basic_block
  | DW_LNS_const_add_pc
  | DW_LNS_fixed_advance_pc of natural
  | DW_LNS_set_prologue_end
  | DW_LNS_set_epilogue_begin
  | DW_LNS_set_isa of natural
  (* extended *)
  | DW_LNE_end_sequence
  | DW_LNE_set_address of natural
  | DW_LNE_define_file of byte_sequence * natural * natural * natural
  | DW_LNE_set_discriminator of natural
  (* special *)
  | DW_LN_special of natural (* the adjusted opcode *)

type line_number_file_entry =
    <|
    lnfe_path: byte_sequence;
    lnfe_directory_index: natural;
    lnfe_last_modification: natural;
    lnfe_length: natural;
  |>

type line_number_header =
    <|
    lnh_offset: natural;
    lnh_dwarf_format: dwarf_format;
    lnh_unit_length: natural;
    lnh_version: natural;
    lnh_header_length: natural;
    lnh_minimum_instruction_length: natural;
    lnh_maximum_operations_per_instruction: natural;
    lnh_default_is_stmt: bool;
    lnh_line_base: integer;
    lnh_line_range: natural;
    lnh_opcode_base: natural;
    lnh_standard_opcode_lengths: list natural;
    lnh_include_directories: list (byte_sequence);
    lnh_file_entries: list line_number_file_entry;
    lnh_comp_dir: maybe string; (* passed down from cu DW_AT_comp_dir *)
  |>

type line_number_program =
    <|
    lnp_header: line_number_header;
    lnp_operations: list line_number_operation;
  |>

(* line number evaluation *)

type line_number_registers =
    <|
    lnr_address: natural;
    lnr_op_index: natural;
    lnr_file: natural;
    lnr_line: natural;
    lnr_column: natural;
    lnr_is_stmt: bool;
    lnr_basic_block: bool;
    lnr_end_sequence: bool;
    lnr_prologue_end: bool;
    lnr_epilogue_begin: bool;
    lnr_isa: natural;
    lnr_discriminator: natural;
  |>

type unpacked_file_entry = (maybe string (*comp_dir*)) * (maybe string (*dir*)) * string (*file*)    
    
type unpacked_decl = unpacked_file_entry * nat(*line*) * string(*subprogram name*)


(* top-level collection of dwarf data *)

type dwarf =
    <|
    d_endianness: Endianness.endianness; (* from the ELF *)
    d_str: byte_sequence;
    d_compilation_units: compilation_units;
    d_type_units: type_units;
    d_loc: location_list_list;
    d_ranges: range_list_list;
    d_frame_info: frame_info;
    d_line_info: list line_number_program;
  |>

(* analysed location data *)

type analysed_location_data       = list ((compilation_unit * (list die) * die) * maybe (list (natural * natural * single_location_description)))

type analysed_location_data_at_pc = list ((compilation_unit * (list die) * die) *             (natural * natural * single_location_description * error single_location))

(* evaluated line data *)

type evaluated_line_info = list (line_number_header * list line_number_registers)

(* all dwarf static data *)
                      
type dwarf_static =
    <|
    ds_dwarf: dwarf;
    ds_analysed_location_data: analysed_location_data;
    ds_evaluated_frame_info: evaluated_frame_info;
    ds_evaluated_line_info: evaluated_line_info;
    ds_subprogram_line_extents: list (unpacked_file_entry * list (string * unpacked_file_entry * natural) );
    |>

type dwarf_dynamic_at_pc = analysed_location_data_at_pc

(** context for parsing and pp functions *)

type p_context =
    <|
    endianness: Endianness.endianness;
  |>



(* type descriptions *)
(* NB these do not cover all the DWARF-expressible types; only some common C cases *)
(* ignore base type DW_endianity and DW_bitsize for now *)
type cupdie = compilation_unit * (list die) * die

type decl =
  <|
  decl_file: maybe string;
  decl_line: maybe natural;
  |>

type array_dimension 't = maybe natural(*count*) * maybe 't(*subrange type*)

type struct_union_member 't = cupdie * (maybe string)(*mname*) * 't * maybe natural(*data_member_location, non-Nothing for structs*)

type struct_union_type_kind =
  | Atk_structure
  | Atk_union

type enumeration_member = cupdie * (maybe string)(*mname*) * integer(*const_value*)

type c_type_top 't =
  | CT_missing of cupdie
  | CT_base of cupdie * string(*name*) * natural(*encoding*) * (maybe natural)(*byte_size*)
  | CT_pointer of cupdie * maybe 't
  | CT_const of cupdie * maybe 't
  | CT_volatile of cupdie * 't
  | CT_restrict of cupdie * 't
  | CT_typedef of cupdie * string(*name*) * 't * decl
  | CT_array of cupdie * 't * list (array_dimension 't)
  | CT_struct_union of cupdie * struct_union_type_kind * (maybe string)(*mname*) * (maybe natural)(*byte_size*) * decl * maybe (list (struct_union_member 't)(*members*))
  | CT_enumeration of cupdie * (maybe string)(*mname*) * (maybe 't)(*mtyp*) * (maybe natural)(*mbyte_size*) * decl * maybe (list (enumeration_member)(*members*))
  | CT_subroutine of cupdie * (bool)(*prototyped*) * (maybe 't)(*mresult_type*) * (list 't)(*parameter_types*) * (bool)(*variable_parameter_list*)
                   
(* In the CT_struct_union and C_enumeration cases, the final maybe(list(...member)) is Nothing if the analysis has not been recursed into the members, and Just ... if it has - which will typically be only one level deep *)

type c_type =
  | CT of (c_type_top c_type)

(* simple die tree *)

(* this unifies variables and formal parameters, and also subprograms
   and inlined_subroutines (but not lexical_blocks).  Debatable what's
   best *)
(* not including DW_AT_low_pc/DW_AT_high_pc or DW_AT_ranges - might want that*)
(* also not including per-instruction line number info *)

type variable_or_formal_parameter_kind =
  | SVPK_var
  | SVPK_param

type sdt_unspecified_parameter = unit



type sdt_variable_or_formal_parameter =
  <|
  svfp_cupdie : cupdie;
  svfp_name : string;
  svfp_kind : variable_or_formal_parameter_kind;
  svfp_type : maybe c_type;
  svfp_abstract_origin : maybe sdt_variable_or_formal_parameter;  (* invariant: non-Nothing iff inlined *)
  svfp_const_value : maybe integer;
  svfp_external : bool;
  svfp_declaration : bool;
  svfp_locations : maybe (list (natural * natural * list operation (*the parsed single_location_description*)));
  svfp_decl : maybe unpacked_decl;
|>

type sdt_subroutine_kind =
  | SSK_subprogram
  | SSK_inlined_subroutine

type sdt_subroutine = (* subprogram or inlined subroutine *)
  <|
  ss_cupdie : cupdie;
  ss_name : maybe string;
  ss_kind : sdt_subroutine_kind;
  ss_call_site : maybe unpacked_decl;
  ss_abstract_origin : maybe sdt_subroutine;  (* invariant: non-Nothing iff inlined *)
  ss_type : maybe c_type;
  ss_vars : list sdt_variable_or_formal_parameter;
  ss_pc_ranges : maybe (list (natural*natural));
  ss_entry_address : maybe natural;
  ss_unspecified_parameters : list sdt_unspecified_parameter;
  ss_subroutines : list sdt_subroutine;  (* invariant: all inlined*)
  ss_lexical_blocks : list sdt_lexical_block;
  ss_decl : maybe unpacked_decl;
  ss_noreturn : bool;
  ss_external : bool;
  |>

and sdt_lexical_block =
  <|
  slb_cupdie : cupdie;
  slb_vars : list sdt_variable_or_formal_parameter; (* invariant: all variables *)
  slb_pc_ranges : maybe (list (natural*natural));
  slb_subroutines : list sdt_subroutine; (* invariant: all inlined*)
  slb_lexical_blocks : list sdt_lexical_block;
  |>

type sdt_compilation_unit =
  <|
  scu_cupdie : cupdie;
  scu_name : string;
  scu_subroutines : list sdt_subroutine;   (* invariant: none inlined(?) *)
  scu_vars : list sdt_variable_or_formal_parameter;
  scu_pc_ranges : maybe (list (natural*natural));
  |>

type sdt_dwarf =
  <| sd_compilation_units : list sdt_compilation_unit;
  |>


(* inlined subroutine data *)

type inlined_subroutine_const_param =
  <|
  iscp_abstract_origin: compilation_unit * (list die) * die;
  iscp_value: integer;
  |>

type inlined_subroutine =
  <|
  is_inlined_subroutine: compilation_unit * (list die) * die;
  is_abstract_origin: compilation_unit * (list die) * die;
  is_inlined_subroutine_sdt: sdt_subroutine;
  is_inlined_subroutine_sdt_parents: list sdt_subroutine;
  is_name : string;
  is_call_file: unpacked_file_entry;
  is_call_line: natural;
  is_pc_ranges: list (natural * natural);
  is_const_params : list inlined_subroutine_const_param;
  |>
  (* ignoring the nesting structure of inlined subroutines for now *)

type inlined_subroutine_data       = list inlined_subroutine

type inlined_subroutine_data_by_range_entry =  (natural*natural)(*range*) * (natural*natural) (*range m-of-n*) * inlined_subroutine

type inlined_subroutine_data_by_range = list inlined_subroutine_data_by_range_entry

(*type inlined_subroutine_data_at_pc = list ((compilation_unit * (list die) * die) *             (natural * natural * single_location_description * error single_location))*)








(** ************************************************************ *)
(** **  missing pervasives  ************************************ *)
(** ************************************************************ *)

(* natural version of List.index *)
val index_natural : forall 'a. list 'a -> natural -> maybe 'a
let rec index_natural l n = match l with
  | []      -> Nothing
  | x :: xs -> if n = 0 then Just x else index_natural xs (n-1)
end

let partialNaturalFromInteger (i:integer) : natural =
 if i<0 then Assert_extra.failwith "partialNaturalFromInteger" else naturalFromInteger i

val natural_nat_shift_left : natural -> nat -> natural
declare ocaml    target_rep function natural_nat_shift_left = `Nat_big_num.shift_left`
declare hol      target_rep function natural_nat_shift_left n m = (naturalPow 2 m) * n

val natural_nat_shift_right : natural -> nat -> natural
declare ocaml    target_rep function natural_nat_shift_right = `Nat_big_num.shift_right`
declare hol      target_rep function natural_nat_shift_right n m = n / (naturalPow 2 m)


(** ************************************************************ *)
(** **  endianness       *************************************** *)
(** ************************************************************ *)

let p_context_of_d (d:dwarf) : p_context = <| endianness = d.d_endianness |> 
    
                                                                 

(** ************************************************************ *)
(** **  dwarf encodings  *************************************** *)
(** ************************************************************ *)

(* these encoding tables are pasted from the DWARF 4 specification *)

(* tag encoding *)
let tag_encodings = [
  ("DW_TAG_array_type"               , natural_of_hex "0x01"  );
  ("DW_TAG_class_type"               , natural_of_hex "0x02"  );
  ("DW_TAG_entry_point"              , natural_of_hex "0x03"  );
  ("DW_TAG_enumeration_type"         , natural_of_hex "0x04"  );
  ("DW_TAG_formal_parameter"         , natural_of_hex "0x05"  );
  ("DW_TAG_imported_declaration"     , natural_of_hex "0x08"  );
  ("DW_TAG_label"                    , natural_of_hex "0x0a"  );
  ("DW_TAG_lexical_block"            , natural_of_hex "0x0b"  );
  ("DW_TAG_member"                   , natural_of_hex "0x0d"  );
  ("DW_TAG_pointer_type"             , natural_of_hex "0x0f"  );
  ("DW_TAG_reference_type"           , natural_of_hex "0x10"  );
  ("DW_TAG_compile_unit"             , natural_of_hex "0x11"  );
  ("DW_TAG_string_type"              , natural_of_hex "0x12"  );
  ("DW_TAG_structure_type"           , natural_of_hex "0x13"  );
  ("DW_TAG_subroutine_type"          , natural_of_hex "0x15"  );
  ("DW_TAG_typedef"                  , natural_of_hex "0x16"  );
  ("DW_TAG_union_type"               , natural_of_hex "0x17"  );
  ("DW_TAG_unspecified_parameters"   , natural_of_hex "0x18"  );
  ("DW_TAG_variant"                  , natural_of_hex "0x19"  );
  ("DW_TAG_common_block"             , natural_of_hex "0x1a"  );
  ("DW_TAG_common_inclusion"         , natural_of_hex "0x1b"  );
  ("DW_TAG_inheritance"              , natural_of_hex "0x1c"  );
  ("DW_TAG_inlined_subroutine"       , natural_of_hex "0x1d"  );
  ("DW_TAG_module"                   , natural_of_hex "0x1e"  );
  ("DW_TAG_ptr_to_member_type"       , natural_of_hex "0x1f"  );
  ("DW_TAG_set_type"                 , natural_of_hex "0x20"  );
  ("DW_TAG_subrange_type"            , natural_of_hex "0x21"  );
  ("DW_TAG_with_stmt"                , natural_of_hex "0x22"  );
  ("DW_TAG_access_declaration"       , natural_of_hex "0x23"  );
  ("DW_TAG_base_type"                , natural_of_hex "0x24"  );
  ("DW_TAG_catch_block"              , natural_of_hex "0x25"  );
  ("DW_TAG_const_type"               , natural_of_hex "0x26"  );
  ("DW_TAG_constant"                 , natural_of_hex "0x27"  );
  ("DW_TAG_enumerator"               , natural_of_hex "0x28"  );
  ("DW_TAG_file_type"                , natural_of_hex "0x29"  );
  ("DW_TAG_friend"                   , natural_of_hex "0x2a"  );
  ("DW_TAG_namelist"                 , natural_of_hex "0x2b"  );
  ("DW_TAG_namelist_item"            , natural_of_hex "0x2c"  );
  ("DW_TAG_packed_type"              , natural_of_hex "0x2d"  );
  ("DW_TAG_subprogram"               , natural_of_hex "0x2e"  );
  ("DW_TAG_template_type_parameter"  , natural_of_hex "0x2f"  );
  ("DW_TAG_template_value_parameter" , natural_of_hex "0x30"  );
  ("DW_TAG_thrown_type"              , natural_of_hex "0x31"  );
  ("DW_TAG_try_block"                , natural_of_hex "0x32"  );
  ("DW_TAG_variant_part"             , natural_of_hex "0x33"  );
  ("DW_TAG_variable"                 , natural_of_hex "0x34"  );
  ("DW_TAG_volatile_type"            , natural_of_hex "0x35"  );
  ("DW_TAG_dwarf_procedure"          , natural_of_hex "0x36"  );
  ("DW_TAG_restrict_type"            , natural_of_hex "0x37"  );
  ("DW_TAG_interface_type"           , natural_of_hex "0x38"  );
  ("DW_TAG_namespace"                , natural_of_hex "0x39"  );
  ("DW_TAG_imported_module"          , natural_of_hex "0x3a"  );
  ("DW_TAG_unspecified_type"         , natural_of_hex "0x3b"  );
  ("DW_TAG_partial_unit"             , natural_of_hex "0x3c"  );
  ("DW_TAG_imported_unit"            , natural_of_hex "0x3d"  );
  ("DW_TAG_condition"                , natural_of_hex "0x3f"  );
  ("DW_TAG_shared_type"              , natural_of_hex "0x40"  );
  ("DW_TAG_type_unit"                , natural_of_hex "0x41"  );
  ("DW_TAG_rvalue_reference_type"    , natural_of_hex "0x42"  );
  ("DW_TAG_template_alias"           , natural_of_hex "0x43"  );
  ("DW_TAG_lo_user"                  , natural_of_hex "0x4080");
  ("DW_TAG_hi_user"                  , natural_of_hex "0xffff")
]


(* child determination encoding *)

let vDW_CHILDREN_no  = natural_of_hex "0x00"
let vDW_CHILDREN_yes = natural_of_hex "0x01"


(* attribute encoding *)

let attribute_encodings = [
  ("DW_AT_sibling"              , natural_of_hex "0x01", [DWA_reference])                                   ;
  ("DW_AT_location"             , natural_of_hex "0x02", [DWA_exprloc; DWA_loclistptr])                     ;
  ("DW_AT_name"                 , natural_of_hex "0x03", [DWA_string])                                      ;
  ("DW_AT_ordering"             , natural_of_hex "0x09", [DWA_constant])                                    ;
  ("DW_AT_byte_size"            , natural_of_hex "0x0b", [DWA_constant; DWA_exprloc; DWA_reference])        ;
  ("DW_AT_bit_offset"           , natural_of_hex "0x0c", [DWA_constant; DWA_exprloc; DWA_reference])        ;
  ("DW_AT_bit_size"             , natural_of_hex "0x0d", [DWA_constant; DWA_exprloc; DWA_reference])        ;
  ("DW_AT_stmt_list"            , natural_of_hex "0x10", [DWA_lineptr])                                     ;
  ("DW_AT_low_pc"               , natural_of_hex "0x11", [DWA_address])                                     ;
  ("DW_AT_high_pc"              , natural_of_hex "0x12", [DWA_address; DWA_constant])                       ;
  ("DW_AT_language"             , natural_of_hex "0x13", [DWA_constant])                                    ;
  ("DW_AT_discr"                , natural_of_hex "0x15", [DWA_reference])                                   ;
  ("DW_AT_discr_value"          , natural_of_hex "0x16", [DWA_constant])                                    ;
  ("DW_AT_visibility"           , natural_of_hex "0x17", [DWA_constant])                                    ;
  ("DW_AT_import"               , natural_of_hex "0x18", [DWA_reference])                                   ;
  ("DW_AT_string_length"        , natural_of_hex "0x19", [DWA_exprloc; DWA_loclistptr])                     ;
  ("DW_AT_common_reference"     , natural_of_hex "0x1a", [DWA_reference])                                   ;
  ("DW_AT_comp_dir"             , natural_of_hex "0x1b", [DWA_string])                                      ;
  ("DW_AT_const_value"          , natural_of_hex "0x1c", [DWA_block; DWA_constant; DWA_string])             ;
  ("DW_AT_containing_type"      , natural_of_hex "0x1d", [DWA_reference])                                   ;
  ("DW_AT_default_value"        , natural_of_hex "0x1e", [DWA_reference])                                   ;
  ("DW_AT_inline"               , natural_of_hex "0x20", [DWA_constant])                                    ;
  ("DW_AT_is_optional"          , natural_of_hex "0x21", [DWA_flag])                                        ;
  ("DW_AT_lower_bound"          , natural_of_hex "0x22", [DWA_constant; DWA_exprloc; DWA_reference])        ;
  ("DW_AT_producer"             , natural_of_hex "0x25", [DWA_string])                                      ;
  ("DW_AT_prototyped"           , natural_of_hex "0x27", [DWA_flag])                                        ;
  ("DW_AT_return_addr"          , natural_of_hex "0x2a", [DWA_exprloc; DWA_loclistptr])                     ;
  ("DW_AT_start_scope"          , natural_of_hex "0x2c", [DWA_constant; DWA_rangelistptr])                  ;
  ("DW_AT_bit_stride"           , natural_of_hex "0x2e", [DWA_constant; DWA_exprloc; DWA_reference])        ;
  ("DW_AT_upper_bound"          , natural_of_hex "0x2f", [DWA_constant; DWA_exprloc; DWA_reference])        ;
  ("DW_AT_abstract_origin"      , natural_of_hex "0x31", [DWA_reference])                                   ;
  ("DW_AT_accessibility"        , natural_of_hex "0x32", [DWA_constant])                                    ;
  ("DW_AT_address_class"        , natural_of_hex "0x33", [DWA_constant])                                    ;
  ("DW_AT_artificial"           , natural_of_hex "0x34", [DWA_flag])                                        ;
  ("DW_AT_base_types"           , natural_of_hex "0x35", [DWA_reference])                                   ;
  ("DW_AT_calling_convention"   , natural_of_hex "0x36", [DWA_constant])                                    ;
  ("DW_AT_count"                , natural_of_hex "0x37", [DWA_constant; DWA_exprloc; DWA_reference])        ;
  ("DW_AT_data_member_location" , natural_of_hex "0x38", [DWA_constant; DWA_exprloc; DWA_loclistptr])       ;
  ("DW_AT_decl_column"          , natural_of_hex "0x39", [DWA_constant])                                    ;
  ("DW_AT_decl_file"            , natural_of_hex "0x3a", [DWA_constant])                                    ;
  ("DW_AT_decl_line"            , natural_of_hex "0x3b", [DWA_constant])                                    ;
  ("DW_AT_declaration"          , natural_of_hex "0x3c", [DWA_flag])                                        ;
  ("DW_AT_discr_list"           , natural_of_hex "0x3d", [DWA_block])                                       ;
  ("DW_AT_encoding"             , natural_of_hex "0x3e", [DWA_constant])                                    ;
  ("DW_AT_external"             , natural_of_hex "0x3f", [DWA_flag])                                        ;
  ("DW_AT_frame_base"           , natural_of_hex "0x40", [DWA_exprloc; DWA_loclistptr])                     ;
  ("DW_AT_friend"               , natural_of_hex "0x41", [DWA_reference])                                   ;
  ("DW_AT_identifier_case"      , natural_of_hex "0x42", [DWA_constant])                                    ;
  ("DW_AT_macro_info"           , natural_of_hex "0x43", [DWA_macptr])                                      ;
  ("DW_AT_namelist_item"        , natural_of_hex "0x44", [DWA_reference])                                   ;
  ("DW_AT_priority"             , natural_of_hex "0x45", [DWA_reference])                                   ;
  ("DW_AT_segment"              , natural_of_hex "0x46", [DWA_exprloc; DWA_loclistptr])                     ;
  ("DW_AT_specification"        , natural_of_hex "0x47", [DWA_reference])                                   ;
  ("DW_AT_static_link"          , natural_of_hex "0x48", [DWA_exprloc; DWA_loclistptr])                     ;
  ("DW_AT_type"                 , natural_of_hex "0x49", [DWA_reference])                                   ;
  ("DW_AT_use_location"         , natural_of_hex "0x4a", [DWA_exprloc; DWA_loclistptr])                     ;
  ("DW_AT_variable_parameter"   , natural_of_hex "0x4b", [DWA_flag])                                        ;
  ("DW_AT_virtuality"           , natural_of_hex "0x4c", [DWA_constant])                                    ;
  ("DW_AT_vtable_elem_location" , natural_of_hex "0x4d", [DWA_exprloc; DWA_loclistptr])                     ;
  ("DW_AT_allocated"            , natural_of_hex "0x4e", [DWA_constant; DWA_exprloc; DWA_reference])        ;
  ("DW_AT_associated"           , natural_of_hex "0x4f", [DWA_constant; DWA_exprloc; DWA_reference])        ;
  ("DW_AT_data_location"        , natural_of_hex "0x50", [DWA_exprloc])                                     ;
  ("DW_AT_byte_stride"          , natural_of_hex "0x51", [DWA_constant; DWA_exprloc; DWA_reference])        ;
  ("DW_AT_entry_pc"             , natural_of_hex "0x52", [DWA_address])                                     ;
  ("DW_AT_use_UTF8"             , natural_of_hex "0x53", [DWA_flag])                                        ;
  ("DW_AT_extension"            , natural_of_hex "0x54", [DWA_reference])                                   ;
  ("DW_AT_ranges"               , natural_of_hex "0x55", [DWA_rangelistptr])                                ;
  ("DW_AT_trampoline"           , natural_of_hex "0x56", [DWA_address; DWA_flag; DWA_reference; DWA_string]);
  ("DW_AT_call_column"          , natural_of_hex "0x57", [DWA_constant])                                    ;
  ("DW_AT_call_file"            , natural_of_hex "0x58", [DWA_constant])                                    ;
  ("DW_AT_call_line"            , natural_of_hex "0x59", [DWA_constant])                                    ;
  ("DW_AT_description"          , natural_of_hex "0x5a", [DWA_string])                                      ;
  ("DW_AT_binary_scale"         , natural_of_hex "0x5b", [DWA_constant])                                    ;
  ("DW_AT_decimal_scale"        , natural_of_hex "0x5c", [DWA_constant])                                    ;
  ("DW_AT_small"                , natural_of_hex "0x5d", [DWA_reference])                                   ;
  ("DW_AT_decimal_sign"         , natural_of_hex "0x5e", [DWA_constant])                                    ;
  ("DW_AT_digit_count"          , natural_of_hex "0x5f", [DWA_constant])                                    ;
  ("DW_AT_picture_string"       , natural_of_hex "0x60", [DWA_string])                                      ;
  ("DW_AT_mutable"              , natural_of_hex "0x61", [DWA_flag])                                        ;
  ("DW_AT_threads_scaled"       , natural_of_hex "0x62", [DWA_flag])                                        ;
  ("DW_AT_explicit"             , natural_of_hex "0x63", [DWA_flag])                                        ;
  ("DW_AT_object_pointer"       , natural_of_hex "0x64", [DWA_reference])                                   ;
  ("DW_AT_endianity"            , natural_of_hex "0x65", [DWA_constant])                                    ;
  ("DW_AT_elemental"            , natural_of_hex "0x66", [DWA_flag])                                        ;
  ("DW_AT_pure"                 , natural_of_hex "0x67", [DWA_flag])                                        ;
  ("DW_AT_recursive"            , natural_of_hex "0x68", [DWA_flag])                                        ;
  ("DW_AT_signature"            , natural_of_hex "0x69", [DWA_reference])                                   ;
  ("DW_AT_main_subprogram"      , natural_of_hex "0x6a", [DWA_flag])                                        ;
  ("DW_AT_data_bit_offset"      , natural_of_hex "0x6b", [DWA_constant])                                    ;
  ("DW_AT_const_expr"           , natural_of_hex "0x6c", [DWA_flag])                                        ;
  ("DW_AT_enum_class"           , natural_of_hex "0x6d", [DWA_flag])                                        ;
  ("DW_AT_linkage_name"         , natural_of_hex "0x6e", [DWA_string])                                      ;
(* DW_AT_noreturn is a gcc extension to support the C11 _Noreturn keyword*)
  ("DW_AT_noreturn"             , natural_of_hex "0x87", [DWA_flag])                                      ;
  ("DW_AT_alignment"            , natural_of_hex "0x88", [DWA_constant])                                      ;
  ("DW_AT_lo_user"              , natural_of_hex "0x2000", [DWA_dash])                                      ;
  ("DW_AT_hi_user"              , natural_of_hex "0x3fff", [DWA_dash])
]


(* attribute form encoding *)

let attribute_form_encodings = [
  ("DW_FORM_addr"        , natural_of_hex "0x01", [DWA_address])  ;
  ("DW_FORM_block2"      , natural_of_hex "0x03", [DWA_block])    ;
  ("DW_FORM_block4"      , natural_of_hex "0x04", [DWA_block])    ;
  ("DW_FORM_data2"       , natural_of_hex "0x05", [DWA_constant]) ;
  ("DW_FORM_data4"       , natural_of_hex "0x06", [DWA_constant]) ;
  ("DW_FORM_data8"       , natural_of_hex "0x07", [DWA_constant]) ;
  ("DW_FORM_string"      , natural_of_hex "0x08", [DWA_string])   ;
  ("DW_FORM_block"       , natural_of_hex "0x09", [DWA_block])    ;
  ("DW_FORM_block1"      , natural_of_hex "0x0a", [DWA_block])    ;
  ("DW_FORM_data1"       , natural_of_hex "0x0b", [DWA_constant]) ;
  ("DW_FORM_flag"        , natural_of_hex "0x0c", [DWA_flag])     ;
  ("DW_FORM_sdata"       , natural_of_hex "0x0d", [DWA_constant]) ;
  ("DW_FORM_strp"        , natural_of_hex "0x0e", [DWA_string])   ;
  ("DW_FORM_udata"       , natural_of_hex "0x0f", [DWA_constant]) ;
  ("DW_FORM_ref_addr"    , natural_of_hex "0x10", [DWA_reference]);
  ("DW_FORM_ref1"        , natural_of_hex "0x11", [DWA_reference]);
  ("DW_FORM_ref2"        , natural_of_hex "0x12", [DWA_reference]);
  ("DW_FORM_ref4"        , natural_of_hex "0x13", [DWA_reference]);
  ("DW_FORM_ref8"        , natural_of_hex "0x14", [DWA_reference]);
  ("DW_FORM_ref_udata"   , natural_of_hex "0x15", [DWA_reference]);
  ("DW_FORM_indirect"    , natural_of_hex "0x16", [DWA_7_5_3])    ;
  ("DW_FORM_sec_offset"  , natural_of_hex "0x17", [DWA_lineptr; DWA_loclistptr; DWA_macptr; DWA_rangelistptr]) ;
  ("DW_FORM_exprloc"     , natural_of_hex "0x18", [DWA_exprloc])  ;
  ("DW_FORM_flag_present", natural_of_hex "0x19", [DWA_flag])     ;
  ("DW_FORM_ref_sig8"    , natural_of_hex "0x20", [DWA_reference])
]


(* operation encoding *)

let operation_encodings = [
("DW_OP_addr",                natural_of_hex "0x03", [OAT_addr]                 , OpSem_lit); (*1*) (*constant address (size target specific)*)
("DW_OP_deref",               natural_of_hex "0x06", []                         , OpSem_deref); (*0*)
("DW_OP_const1u",             natural_of_hex "0x08", [OAT_uint8]                , OpSem_lit); (*1*) (* 1-byte constant  *)
("DW_OP_const1s",             natural_of_hex "0x09", [OAT_sint8]                , OpSem_lit); (*1*) (* 1-byte constant  *)
("DW_OP_const2u",             natural_of_hex "0x0a", [OAT_uint16]               , OpSem_lit); (*1*) (* 2-byte constant  *)
("DW_OP_const2s",             natural_of_hex "0x0b", [OAT_sint16]               , OpSem_lit); (*1*) (* 2-byte constant  *)
("DW_OP_const4u",             natural_of_hex "0x0c", [OAT_uint32]               , OpSem_lit); (*1*) (* 4-byte constant  *)
("DW_OP_const4s",             natural_of_hex "0x0d", [OAT_sint32]               , OpSem_lit); (*1*) (* 4-byte constant  *)
("DW_OP_const8u",             natural_of_hex "0x0e", [OAT_uint64]               , OpSem_lit); (*1*) (* 8-byte constant  *)
("DW_OP_const8s",             natural_of_hex "0x0f", [OAT_sint64]               , OpSem_lit); (*1*) (* 8-byte constant  *)
("DW_OP_constu",              natural_of_hex "0x10", [OAT_ULEB128]              , OpSem_lit); (*1*) (* ULEB128 constant *)
("DW_OP_consts",              natural_of_hex "0x11", [OAT_SLEB128]              , OpSem_lit); (*1*) (* SLEB128 constant *)
("DW_OP_dup",                 natural_of_hex "0x12", []                         , OpSem_stack (fun ac vs args -> match vs with v::vs -> Just (v::v::vs) | _ -> Nothing end)); (*0*)
("DW_OP_drop",                natural_of_hex "0x13", []                         , OpSem_stack (fun ac vs args -> match vs with v::vs -> Just vs | _ -> Nothing end)); (*0*)
("DW_OP_over",                natural_of_hex "0x14", []                         , OpSem_stack (fun ac vs args -> match vs with v::v'::vs -> Just (v'::v::v'::vs) | _ -> Nothing end)); (*0*)
("DW_OP_pick",                natural_of_hex "0x15", [OAT_uint8]                , OpSem_stack (fun ac vs args -> match args with [OAV_natural n] -> match index_natural vs n with Just v -> Just (v::vs) | Nothing -> Nothing end | _ -> Nothing end)); (*1*) (* 1-byte stack index *)
("DW_OP_swap",                natural_of_hex "0x16", []                         , OpSem_stack (fun ac vs args -> match vs with v::v'::vs -> Just (v'::v::vs) | _ -> Nothing end)); (*0*)
("DW_OP_rot",                 natural_of_hex "0x17", []                         , OpSem_stack (fun ac vs args -> match vs with v::v'::v''::vs -> Just (v'::v''::v::vs) | _ -> Nothing end)); (*0*)
("DW_OP_xderef",              natural_of_hex "0x18", []                         , OpSem_not_supported); (*0*)
("DW_OP_abs",                 natural_of_hex "0x19", []                         , OpSem_unary (fun ac v -> if v < ac.ac_half then Just v else if v=ac.ac_max then Nothing else Just (ac.ac_all-v))); (*0*)
("DW_OP_and",                 natural_of_hex "0x1a", []                         , OpSem_binary (fun ac v1 v2 -> Just (natural_land v1 v2))); (*0*)
("DW_OP_div",                 natural_of_hex "0x1b", []                         , OpSem_not_supported) (*TODO*); (*0*)
("DW_OP_minus",               natural_of_hex "0x1c", []                         , OpSem_binary (fun ac v1 v2 -> Just (partialNaturalFromInteger ((integerFromNatural v1 - integerFromNatural v2) mod (integerFromNatural ac.ac_all))))); (*0*)
("DW_OP_mod",                 natural_of_hex "0x1d", []                         , OpSem_binary (fun ac v1 v2 -> Just (v1 mod v2))); (*0*)
("DW_OP_mul",                 natural_of_hex "0x1e", []                         , OpSem_binary (fun ac v1 v2 -> Just (partialNaturalFromInteger ((integerFromNatural v1 * integerFromNatural v2) mod (integerFromNatural ac.ac_all))))); (*0*)
("DW_OP_neg",                 natural_of_hex "0x1f", []                         , OpSem_unary (fun ac v -> if v < ac.ac_half then Just (ac.ac_max - v) else if v=ac.ac_half then Nothing else Just (ac.ac_all - v))); (*0*)
("DW_OP_not",                 natural_of_hex "0x20", []                         , OpSem_unary (fun ac v -> Just (natural_lxor v ac.ac_max))); (*0*)
("DW_OP_or",                  natural_of_hex "0x21", []                         , OpSem_binary (fun ac v1 v2 -> Just (natural_lor v1 v2))); (*0*)
("DW_OP_plus",                natural_of_hex "0x22", []                         , OpSem_binary (fun ac v1 v2 -> Just ((v1 + v2) mod ac.ac_all))); (*0*)
("DW_OP_plus_uconst",         natural_of_hex "0x23", [OAT_ULEB128]              , OpSem_stack (fun ac vs args -> match args with [OAV_natural n] -> match vs with v::vs' -> let v' = (v+n) mod ac.ac_all in Just (v'::vs)  | [] -> Nothing end  | _ -> Nothing end)); (*1*) (* ULEB128 addend *)
("DW_OP_shl",                 natural_of_hex "0x24", []                         , OpSem_binary (fun ac v1 v2 -> if v2 >= ac.ac_bitwidth then Just 0 else Just (natural_nat_shift_left v1 (natFromNatural v2)))); (*0*)
("DW_OP_shr",                 natural_of_hex "0x25", []                         , OpSem_binary (fun ac v1 v2 -> if v2 >= ac.ac_bitwidth then Just 0 else Just (natural_nat_shift_right v1 (natFromNatural v2)))); (*0*)
("DW_OP_shra",                natural_of_hex "0x26", []                         , OpSem_binary (fun ac v1 v2 -> if v1 < ac.ac_half then (if v2 >= ac.ac_bitwidth then Just 0 else Just (natural_nat_shift_right v1 (natFromNatural v2))) else (if v2 >= ac.ac_bitwidth then Just ac.ac_max  else Just (ac.ac_max - (natural_nat_shift_right (ac.ac_max - v1) (natFromNatural v2)))))); (*0*)
("DW_OP_xor",                 natural_of_hex "0x27", []                         , OpSem_binary (fun ac v1 v2 -> Just (natural_lxor v1 v2))); (*0*)
("DW_OP_skip",                natural_of_hex "0x2f", [OAT_sint16]               , OpSem_not_supported); (*1*) (* signed 2-byte constant *)
("DW_OP_bra",                 natural_of_hex "0x28", [OAT_sint16]               , OpSem_not_supported); (*1*) (* signed 2-byte constant *)
("DW_OP_eq",                  natural_of_hex "0x29", []                         , OpSem_not_supported); (*0*)
("DW_OP_ge",                  natural_of_hex "0x2a", []                         , OpSem_not_supported); (*0*)
("DW_OP_gt",                  natural_of_hex "0x2b", []                         , OpSem_not_supported); (*0*)
("DW_OP_le",                  natural_of_hex "0x2c", []                         , OpSem_not_supported); (*0*)
("DW_OP_lt",                  natural_of_hex "0x2d", []                         , OpSem_not_supported); (*0*)
("DW_OP_ne",                  natural_of_hex "0x2e", []                         , OpSem_not_supported); (*0*)
("DW_OP_lit0",                natural_of_hex "0x30", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*) (* literals 0..31 =(DW_OP_lit0 + literal) *)
("DW_OP_lit1",                natural_of_hex "0x31", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*)
("DW_OP_lit2",                natural_of_hex "0x32", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*)
("DW_OP_lit3",                natural_of_hex "0x33", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*)
("DW_OP_lit4",                natural_of_hex "0x34", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*)
("DW_OP_lit5",                natural_of_hex "0x35", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*)
("DW_OP_lit6",                natural_of_hex "0x36", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*)
("DW_OP_lit7",                natural_of_hex "0x37", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*)
("DW_OP_lit8",                natural_of_hex "0x38", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*)
("DW_OP_lit9",                natural_of_hex "0x39", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*)
("DW_OP_lit10",               natural_of_hex "0x3a", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*)
("DW_OP_lit11",               natural_of_hex "0x3b", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*)
("DW_OP_lit12",               natural_of_hex "0x3c", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*)
("DW_OP_lit13",               natural_of_hex "0x3d", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*)
("DW_OP_lit14",               natural_of_hex "0x3e", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*)
("DW_OP_lit15",               natural_of_hex "0x3f", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*)
("DW_OP_lit16",               natural_of_hex "0x40", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*)
("DW_OP_lit17",               natural_of_hex "0x41", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*)
("DW_OP_lit18",               natural_of_hex "0x42", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*)
("DW_OP_lit19",               natural_of_hex "0x43", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*)
("DW_OP_lit20",               natural_of_hex "0x44", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*)
("DW_OP_lit21",               natural_of_hex "0x45", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*)
("DW_OP_lit22",               natural_of_hex "0x46", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*)
("DW_OP_lit23",               natural_of_hex "0x47", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*)
("DW_OP_lit24",               natural_of_hex "0x48", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*)
("DW_OP_lit25",               natural_of_hex "0x49", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*)
("DW_OP_lit26",               natural_of_hex "0x4a", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*)
("DW_OP_lit27",               natural_of_hex "0x4b", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*)
("DW_OP_lit28",               natural_of_hex "0x4c", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*)
("DW_OP_lit29",               natural_of_hex "0x4d", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*)
("DW_OP_lit30",               natural_of_hex "0x4e", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*)
("DW_OP_lit31",               natural_of_hex "0x4f", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*)
("DW_OP_reg0",                natural_of_hex "0x50", []                         , OpSem_reg); (*1*) (* reg 0..31 = (DW_OP_reg0 + regnum) *)
("DW_OP_reg1",                natural_of_hex "0x51", []                         , OpSem_reg); (*1*)
("DW_OP_reg2",                natural_of_hex "0x52", []                         , OpSem_reg); (*1*)
("DW_OP_reg3",                natural_of_hex "0x53", []                         , OpSem_reg); (*1*)
("DW_OP_reg4",                natural_of_hex "0x54", []                         , OpSem_reg); (*1*)
("DW_OP_reg5",                natural_of_hex "0x55", []                         , OpSem_reg); (*1*)
("DW_OP_reg6",                natural_of_hex "0x56", []                         , OpSem_reg); (*1*)
("DW_OP_reg7",                natural_of_hex "0x57", []                         , OpSem_reg); (*1*)
("DW_OP_reg8",                natural_of_hex "0x58", []                         , OpSem_reg); (*1*)
("DW_OP_reg9",                natural_of_hex "0x59", []                         , OpSem_reg); (*1*)
("DW_OP_reg10",               natural_of_hex "0x5a", []                         , OpSem_reg); (*1*)
("DW_OP_reg11",               natural_of_hex "0x5b", []                         , OpSem_reg); (*1*)
("DW_OP_reg12",               natural_of_hex "0x5c", []                         , OpSem_reg); (*1*)
("DW_OP_reg13",               natural_of_hex "0x5d", []                         , OpSem_reg); (*1*)
("DW_OP_reg14",               natural_of_hex "0x5e", []                         , OpSem_reg); (*1*)
("DW_OP_reg15",               natural_of_hex "0x5f", []                         , OpSem_reg); (*1*)
("DW_OP_reg16",               natural_of_hex "0x60", []                         , OpSem_reg); (*1*)
("DW_OP_reg17",               natural_of_hex "0x61", []                         , OpSem_reg); (*1*)
("DW_OP_reg18",               natural_of_hex "0x62", []                         , OpSem_reg); (*1*)
("DW_OP_reg19",               natural_of_hex "0x63", []                         , OpSem_reg); (*1*)
("DW_OP_reg20",               natural_of_hex "0x64", []                         , OpSem_reg); (*1*)
("DW_OP_reg21",               natural_of_hex "0x65", []                         , OpSem_reg); (*1*)
("DW_OP_reg22",               natural_of_hex "0x66", []                         , OpSem_reg); (*1*)
("DW_OP_reg23",               natural_of_hex "0x67", []                         , OpSem_reg); (*1*)
("DW_OP_reg24",               natural_of_hex "0x68", []                         , OpSem_reg); (*1*)
("DW_OP_reg25",               natural_of_hex "0x69", []                         , OpSem_reg); (*1*)
("DW_OP_reg26",               natural_of_hex "0x6a", []                         , OpSem_reg); (*1*)
("DW_OP_reg27",               natural_of_hex "0x6b", []                         , OpSem_reg); (*1*)
("DW_OP_reg28",               natural_of_hex "0x6c", []                         , OpSem_reg); (*1*)
("DW_OP_reg29",               natural_of_hex "0x6d", []                         , OpSem_reg); (*1*)
("DW_OP_reg30",               natural_of_hex "0x6e", []                         , OpSem_reg); (*1*)
("DW_OP_reg31",               natural_of_hex "0x6f", []                         , OpSem_reg); (*1*)
("DW_OP_breg0",               natural_of_hex "0x70", [OAT_SLEB128]              , OpSem_breg); (*1*) (* base register 0..31 = (DW_OP_breg0 + regnum) *)
("DW_OP_breg1",               natural_of_hex "0x71", [OAT_SLEB128]              , OpSem_breg); (*1*)
("DW_OP_breg2",               natural_of_hex "0x72", [OAT_SLEB128]              , OpSem_breg); (*1*)
("DW_OP_breg3",               natural_of_hex "0x73", [OAT_SLEB128]              , OpSem_breg); (*1*)
("DW_OP_breg4",               natural_of_hex "0x74", [OAT_SLEB128]              , OpSem_breg); (*1*)
("DW_OP_breg5",               natural_of_hex "0x75", [OAT_SLEB128]              , OpSem_breg); (*1*)
("DW_OP_breg6",               natural_of_hex "0x76", [OAT_SLEB128]              , OpSem_breg); (*1*)
("DW_OP_breg7",               natural_of_hex "0x77", [OAT_SLEB128]              , OpSem_breg); (*1*)
("DW_OP_breg8",               natural_of_hex "0x78", [OAT_SLEB128]              , OpSem_breg); (*1*)
("DW_OP_breg9",               natural_of_hex "0x79", [OAT_SLEB128]              , OpSem_breg); (*1*)
("DW_OP_breg10",              natural_of_hex "0x7a", [OAT_SLEB128]              , OpSem_breg); (*1*)
("DW_OP_breg11",              natural_of_hex "0x7b", [OAT_SLEB128]              , OpSem_breg); (*1*)
("DW_OP_breg12",              natural_of_hex "0x7c", [OAT_SLEB128]              , OpSem_breg); (*1*)
("DW_OP_breg13",              natural_of_hex "0x7d", [OAT_SLEB128]              , OpSem_breg); (*1*)
("DW_OP_breg14",              natural_of_hex "0x7e", [OAT_SLEB128]              , OpSem_breg); (*1*)
("DW_OP_breg15",              natural_of_hex "0x7f", [OAT_SLEB128]              , OpSem_breg); (*1*)
("DW_OP_breg16",              natural_of_hex "0x80", [OAT_SLEB128]              , OpSem_breg); (*1*)
("DW_OP_breg17",              natural_of_hex "0x81", [OAT_SLEB128]              , OpSem_breg); (*1*)
("DW_OP_breg18",              natural_of_hex "0x82", [OAT_SLEB128]              , OpSem_breg); (*1*)
("DW_OP_breg19",              natural_of_hex "0x83", [OAT_SLEB128]              , OpSem_breg); (*1*)
("DW_OP_breg20",              natural_of_hex "0x84", [OAT_SLEB128]              , OpSem_breg); (*1*)
("DW_OP_breg21",              natural_of_hex "0x85", [OAT_SLEB128]              , OpSem_breg); (*1*)
("DW_OP_breg22",              natural_of_hex "0x86", [OAT_SLEB128]              , OpSem_breg); (*1*)
("DW_OP_breg23",              natural_of_hex "0x87", [OAT_SLEB128]              , OpSem_breg); (*1*)
("DW_OP_breg24",              natural_of_hex "0x88", [OAT_SLEB128]              , OpSem_breg); (*1*)
("DW_OP_breg25",              natural_of_hex "0x89", [OAT_SLEB128]              , OpSem_breg); (*1*)
("DW_OP_breg26",              natural_of_hex "0x8a", [OAT_SLEB128]              , OpSem_breg); (*1*)
("DW_OP_breg27",              natural_of_hex "0x8b", [OAT_SLEB128]              , OpSem_breg); (*1*)
("DW_OP_breg28",              natural_of_hex "0x8c", [OAT_SLEB128]              , OpSem_breg); (*1*)
("DW_OP_breg29",              natural_of_hex "0x8d", [OAT_SLEB128]              , OpSem_breg); (*1*)
("DW_OP_breg30",              natural_of_hex "0x8e", [OAT_SLEB128]              , OpSem_breg); (*1*)
("DW_OP_breg31",              natural_of_hex "0x8f", [OAT_SLEB128]              , OpSem_breg); (*1*)
("DW_OP_regx",                natural_of_hex "0x90", [OAT_ULEB128]              , OpSem_lit); (*1*) (* ULEB128 register *)
("DW_OP_fbreg",               natural_of_hex "0x91", [OAT_SLEB128]              , OpSem_fbreg); (*1*) (* SLEB128 offset *)
("DW_OP_bregx",               natural_of_hex "0x92", [OAT_ULEB128; OAT_SLEB128] , OpSem_bregx); (*2*) (* ULEB128 register followed by SLEB128 offset *)
("DW_OP_piece",               natural_of_hex "0x93", [OAT_ULEB128]              , OpSem_piece); (*1*) (* ULEB128 size of piece addressed *)
("DW_OP_deref_size",          natural_of_hex "0x94", [OAT_uint8]                , OpSem_deref_size); (*1*) (* 1-byte size of data retrieved *)
("DW_OP_xderef_size",         natural_of_hex "0x95", [OAT_uint8]                , OpSem_not_supported); (*1*) (* 1-byte size of data retrieved *)
("DW_OP_nop",                 natural_of_hex "0x96", []                         , OpSem_nop); (*0*)
("DW_OP_push_object_address", natural_of_hex "0x97", []                         , OpSem_not_supported); (*0*)
("DW_OP_call2",               natural_of_hex "0x98", [OAT_uint16]               , OpSem_not_supported); (*1*) (* 2-byte offset of DIE *)
("DW_OP_call4",               natural_of_hex "0x99", [OAT_uint32]               , OpSem_not_supported); (*1*) (* 4-byte offset of DIE *)
("DW_OP_call_ref",            natural_of_hex "0x9a", [OAT_dwarf_format_t]       , OpSem_not_supported); (*1*) (* 4- or 8-byte offset of DIE *)
("DW_OP_form_tls_address",    natural_of_hex "0x9b", []                         , OpSem_not_supported); (*0*)
("DW_OP_call_frame_cfa",      natural_of_hex "0x9c", []                         , OpSem_call_frame_cfa); (*0*)
("DW_OP_bit_piece",           natural_of_hex "0x9d", [OAT_ULEB128; OAT_ULEB128] , OpSem_bit_piece); (*2*) (* ULEB128 size followed by ULEB128 offset *)
("DW_OP_implicit_value",      natural_of_hex "0x9e", [OAT_block]                , OpSem_implicit_value); (*2*) (* ULEB128 size followed by block of that size *)
("DW_OP_stack_value",         natural_of_hex "0x9f", []                         , OpSem_stack_value); (*0*)
(* these aren't real operations
("DW_OP_lo_user",             natural_of_hex "0xe0", []                         , );
("DW_OP_hi_user",             natural_of_hex "0xff", []                         , );
*)

(* GCC also produces these for our example:
https://fedorahosted.org/elfutils/wiki/DwarfExtensions
http://dwarfstd.org/ShowIssue.php?issue=100909.1 *)
("DW_GNU_OP_entry_value",     natural_of_hex "0xf3", [OAT_block], OpSem_not_supported); (*2*) (* ULEB128 size followed by DWARF expression block of that size*)
("DW_OP_GNU_implicit_pointer", natural_of_hex "0xf2", [OAT_dwarf_format_t;OAT_SLEB128], OpSem_not_supported)

]


let vDW_OP_reg0 = natural_of_hex "0x50"
let vDW_OP_breg0 = natural_of_hex "0x70"


(* call frame instruction encoding *)

let call_frame_instruction_encoding : list (string * natural * natural * list call_frame_argument_type * ((list call_frame_argument_value) -> maybe call_frame_instruction)) = [
(*                            high-order 2 bits   low-order 6 bits       uniformly parsed arguments  *)

(* instructions using low-order 6 bits for first argument *)
(*
("DW_CFA_advance_loc",         1,                  0,(*delta *)           []);
("DW_CFA_offset",              2,                  0,(*register*)         [CFAT_offset]);
("DW_CFA_restore",             3,                  0,(*register*)         []);
*)
(* instructions using low-order 6 bits as part of opcode  *)
("DW_CFA_nop",                 0,                  natural_of_hex "0x00", [], (* *)
 fun avs -> match avs with [] -> Just (DW_CFA_nop) | _ -> Nothing end);
("DW_CFA_set_loc",             0,                  natural_of_hex "0x01", [CFAT_address], (* address *)
 fun avs -> match avs with [CFAV_address a] -> Just (DW_CFA_set_loc a) | _ -> Nothing end);
("DW_CFA_advance_loc1",        0,                  natural_of_hex "0x02", [CFAT_delta1], (* 1-byte delta *)
 fun avs -> match avs with [CFAV_delta d] -> Just (DW_CFA_advance_loc1 d) | _ -> Nothing end);
("DW_CFA_advance_loc2",        0,                  natural_of_hex "0x03", [CFAT_delta2], (* 2-byte delta *)
 fun avs -> match avs with [CFAV_delta d] -> Just (DW_CFA_advance_loc2 d) | _ -> Nothing end);
("DW_CFA_advance_loc4",        0,                  natural_of_hex "0x04", [CFAT_delta4], (* 4-byte delta *)
 fun avs -> match avs with [CFAV_delta d] -> Just (DW_CFA_advance_loc4 d) | _ -> Nothing end);
("DW_CFA_offset_extended",     0,                  natural_of_hex "0x05", [CFAT_register; CFAT_offset], (* ULEB128 register ULEB128 offset *)
 fun avs -> match avs with [CFAV_register r; CFAV_offset n] -> Just (DW_CFA_offset_extended r n) | _ -> Nothing end);
("DW_CFA_restore_extended",    0,                  natural_of_hex "0x06", [CFAT_register], (* ULEB128 register *)
 fun avs -> match avs with [CFAV_register r] -> Just (DW_CFA_restore_extended r) | _ -> Nothing end);
("DW_CFA_undefined",           0,                  natural_of_hex "0x07", [CFAT_register], (* ULEB128 register *)
 fun avs -> match avs with [CFAV_register r] -> Just (DW_CFA_undefined r) | _ -> Nothing end);
("DW_CFA_same_value",          0,                  natural_of_hex "0x08", [CFAT_register], (* ULEB128 register *)
 fun avs -> match avs with [CFAV_register r] -> Just (DW_CFA_same_value r) | _ -> Nothing end);
("DW_CFA_register",            0,                  natural_of_hex "0x09", [CFAT_register; CFAT_register], (* ULEB128 register ULEB128 register *)
 fun avs -> match avs with [CFAV_register r1; CFAV_register r2] -> Just (DW_CFA_register r1 r2) | _ -> Nothing end);
("DW_CFA_remember_state",      0,                  natural_of_hex "0x0a", [], (* *)
 fun avs -> match avs with [] -> Just (DW_CFA_remember_state) | _ -> Nothing end);
("DW_CFA_restore_state",       0,                  natural_of_hex "0x0b", [], (* *)
 fun avs -> match avs with [] -> Just (DW_CFA_restore_state) | _ -> Nothing end);
("DW_CFA_def_cfa",             0,                  natural_of_hex "0x0c", [CFAT_register; CFAT_offset], (* ULEB128 register ULEB128 offset *)
 fun avs -> match avs with [CFAV_register r; CFAV_offset n] -> Just (DW_CFA_def_cfa r n) | _ -> Nothing end);
("DW_CFA_def_cfa_register",    0,                  natural_of_hex "0x0d", [CFAT_register], (* ULEB128 register *)
 fun avs -> match avs with [CFAV_register r] -> Just (DW_CFA_def_cfa_register r) | _ -> Nothing end);
("DW_CFA_def_cfa_offset",      0,                  natural_of_hex "0x0e", [CFAT_offset], (* ULEB128 offset *)
 fun avs -> match avs with [CFAV_offset n] -> Just (DW_CFA_def_cfa_offset n) | _ -> Nothing end);
("DW_CFA_def_cfa_expression",  0,                  natural_of_hex "0x0f", [CFAT_block], (* BLOCK *)
 fun avs -> match avs with [CFAV_block b] -> Just (DW_CFA_def_cfa_expression b) | _ -> Nothing end);
("DW_CFA_expression",          0,                  natural_of_hex "0x10", [CFAT_register; CFAT_block], (* ULEB128 register BLOCK *)
 fun avs -> match avs with [CFAV_register r; CFAV_block b] -> Just (DW_CFA_expression r b) | _ -> Nothing end);
("DW_CFA_offset_extended_sf",  0,                  natural_of_hex "0x11", [CFAT_register; CFAT_sfoffset], (* ULEB128 register SLEB128 offset *)
 fun avs -> match avs with [CFAV_register r; CFAV_sfoffset i] -> Just (DW_CFA_offset_extended_sf r i) | _ -> Nothing end);
("DW_CFA_def_cfa_sf",          0,                  natural_of_hex "0x12", [CFAT_register; CFAT_sfoffset], (* ULEB128 register SLEB128 offset *)
 fun avs -> match avs with [CFAV_register r; CFAV_sfoffset i] -> Just (DW_CFA_def_cfa_sf r i) | _ -> Nothing end);
("DW_CFA_def_cfa_offset_sf",   0,                  natural_of_hex "0x13", [CFAT_sfoffset], (* SLEB128 offset *)
 fun avs -> match avs with [CFAV_sfoffset i] -> Just (DW_CFA_def_cfa_offset_sf i) | _ -> Nothing end);
("DW_CFA_val_offset",          0,                  natural_of_hex "0x14", [CFAT_register; CFAT_offset], (* ULEB128 ULEB128 *)
 fun avs -> match avs with [CFAV_register r; CFAV_offset n] -> Just (DW_CFA_val_offset r n) | _ -> Nothing end);
("DW_CFA_val_offset_sf",       0,                  natural_of_hex "0x15", [CFAT_register; CFAT_sfoffset], (* ULEB128 SLEB128 *)
 fun avs -> match avs with [CFAV_register r; CFAV_sfoffset i] -> Just (DW_CFA_val_offset_sf r i) | _ -> Nothing end);
("DW_CFA_val_expression",      0,                  natural_of_hex "0x16", [CFAT_register; CFAT_block], (* ULEB128 BLOCK *)
 fun avs -> match avs with [CFAV_register r; CFAV_block b] -> Just (DW_CFA_val_expression r b) | _ -> Nothing end);
("DW_CFA_AARCH64_negate_ra_state",     0,                  natural_of_hex "0x2d", [], (* *)
 fun avs -> match avs with [] -> Just (DW_CFA_AARCH64_negate_ra_state) | _ -> Nothing end);
]
(*
0x2d DW_CFA_GNU_window_save is listed in https://sourceware.org/elfutils/DwarfExtensions as "magic shorthand used only by SPARC"
https://elixir.bootlin.com/linux/v4.0/source/arch/arc/kernel/unwind.c#L842 no-ops it
https://refspecs.linuxbase.org/LSB_3.0.0/LSB-PDA/LSB-PDA/dwarfext.html doesn't mention it
https://github.com/gcc-mirror/gcc/blob/master/libgcc/unwind-dw2.c#L1189 says
"This CFA is multiplexed with Sparc.  On AArch64 it's used to toggle return address signing status."
fs->regs.reg[DWARF_REGNUM_AARCH64_RA_STATE].loc.offset ^= 1;
https://developer.arm.com/docs/ihi0057/c/dwarf-for-the-arm-64-bit-architecture-aarch64-abi-2018q4 "DWARF for the Arm® 64-bit Architecture (AArch64) - ABI 2018Q4"
calls this "DW_CFA_AARCH64_negate_ra_state" 
"The DW_CFA_AARCH64_negate_ra_state operation negates bit[0] of the RA_SIGN_STATE pseudo-register. It does not take any operands."
p10 says "The RA_SIGN_STATE pseudo-register records whether the return address has been signed with aPAC. This information can be used when unwinding.  It is an unsigned integer with the same sizeas a general register. Only bit[0] is meaningful and is initialized to zero. A value of 0 indicates the return address has not been signed. A value of 1 indicates the return address has been signed"
For our purposes it seems fine to nop-this.
 *)
                          (*
("DW_CFA_lo_user",             0,                  natural_of_hex "0x1c", []); (* *)
("DW_CFA_hi_user",             0,                  natural_of_hex "0x3f", []); (* *)
*)


(* line number encodings *)

let line_number_standard_encodings = [
  ("DW_LNS_copy"               , natural_of_hex "0x01", [             ],
   fun lnvs -> match lnvs with [] -> Just  DW_LNS_copy                              | _ -> Nothing end);
  ("DW_LNS_advance_pc"         , natural_of_hex "0x02", [LNAT_ULEB128 ],
   fun lnvs -> match lnvs with [LNAV_ULEB128 n] -> Just  (DW_LNS_advance_pc n)      | _ -> Nothing end);
  ("DW_LNS_advance_line"       , natural_of_hex "0x03", [LNAT_SLEB128 ],
   fun lnvs -> match lnvs with [LNAV_SLEB128 i] -> Just  (DW_LNS_advance_line i)    | _ -> Nothing end);
  ("DW_LNS_set_file"           , natural_of_hex "0x04", [LNAT_ULEB128 ],
   fun lnvs -> match lnvs with [LNAV_ULEB128 n] -> Just  (DW_LNS_set_file n)        | _ -> Nothing end);
  ("DW_LNS_set_column"         , natural_of_hex "0x05", [LNAT_ULEB128 ],
   fun lnvs -> match lnvs with [LNAV_ULEB128 n] -> Just  (DW_LNS_set_column n)      | _ -> Nothing end);
  ("DW_LNS_negate_stmt"        , natural_of_hex "0x06", [             ],
   fun lnvs -> match lnvs with [] -> Just  (DW_LNS_negate_stmt)                     | _ -> Nothing end);
  ("DW_LNS_set_basic_block"    , natural_of_hex "0x07", [             ],
   fun lnvs -> match lnvs with [] -> Just  (DW_LNS_set_basic_block)                 | _ -> Nothing end);
  ("DW_LNS_const_add_pc"       , natural_of_hex "0x08", [             ],
   fun lnvs -> match lnvs with [] -> Just  (DW_LNS_const_add_pc)                    | _ -> Nothing end);
  ("DW_LNS_fixed_advance_pc"   , natural_of_hex "0x09", [LNAT_uint16  ],
   fun lnvs -> match lnvs with [LNAV_uint16 n] -> Just  (DW_LNS_fixed_advance_pc n) | _ -> Nothing end);
  ("DW_LNS_set_prologue_end"   , natural_of_hex "0x0a", [             ],
   fun lnvs -> match lnvs with [] -> Just  (DW_LNS_set_prologue_end)                | _ -> Nothing end);
  ("DW_LNS_set_epilogue_begin" , natural_of_hex "0x0b", [             ],
   fun lnvs -> match lnvs with [] -> Just  (DW_LNS_set_epilogue_begin)              | _ -> Nothing end);
  ("DW_LNS_set_isa"            , natural_of_hex "0x0c", [LNAT_ULEB128 ],
   fun lnvs -> match lnvs with [LNAV_ULEB128 n] -> Just  (DW_LNS_set_isa n)         | _ -> Nothing end)
]

let line_number_extended_encodings = [
  ("DW_LNE_end_sequence"       , natural_of_hex "0x01", [],
   fun lnvs -> match lnvs with [] -> Just  (DW_LNE_end_sequence)                      | _ -> Nothing end);
  ("DW_LNE_set_address"        , natural_of_hex "0x02", [LNAT_address],
   fun lnvs -> match lnvs with [LNAV_address n] -> Just  (DW_LNE_set_address n)          | _ -> Nothing end);
  ("DW_LNE_define_file"        , natural_of_hex "0x03", [LNAT_string; LNAT_ULEB128; LNAT_ULEB128; LNAT_ULEB128],
   fun lnvs -> match lnvs with [LNAV_string s; LNAV_ULEB128 n1; LNAV_ULEB128 n2; LNAV_ULEB128 n3] -> Just  (DW_LNE_define_file s n1 n2 n3) | _ -> Nothing end);
  ("DW_LNE_set_discriminator"  , natural_of_hex "0x04", [LNAT_ULEB128],
   fun lnvs -> match lnvs with [LNAV_ULEB128 n] -> Just  (DW_LNE_set_discriminator n)  | _ -> Nothing end)             (* new in Dwarf 4*)
]


(*
(DW_LNE_lo_user            , natural_of_hex "0x80", "DW_LNE_lo_user");
(DW_LNE_hi_user            , natural_of_hex "0xff", "DW_LNE_hi_user");
*)



(* booleans encoded as a single byte containing the value 0 for “false,” and a non-zero value for “true.” *)

(* base type attribute encoding *)
let base_type_attribute_encodings = [
  ("DW_ATE_address"         , natural_of_hex "0x01");
  ("DW_ATE_boolean"         , natural_of_hex "0x02");
  ("DW_ATE_complex_float"   , natural_of_hex "0x03");
  ("DW_ATE_float"           , natural_of_hex "0x04");
  ("DW_ATE_signed"          , natural_of_hex "0x05");
  ("DW_ATE_signed_char"     , natural_of_hex "0x06");
  ("DW_ATE_unsigned"        , natural_of_hex "0x07");
  ("DW_ATE_unsigned_char"   , natural_of_hex "0x08");
  ("DW_ATE_imaginary_float" , natural_of_hex "0x09");
  ("DW_ATE_packed_decimal"  , natural_of_hex "0x0a");
  ("DW_ATE_numeric_string"  , natural_of_hex "0x0b");
  ("DW_ATE_edited"          , natural_of_hex "0x0c");
  ("DW_ATE_signed_fixed"    , natural_of_hex "0x0d");
  ("DW_ATE_unsigned_fixed"  , natural_of_hex "0x0e");
  ("DW_ATE_decimal_float"   , natural_of_hex "0x0f");
  ("DW_ATE_UTF"             , natural_of_hex "0x10");
  ("DW_ATE_lo_user"         , natural_of_hex "0x80");
  ("DW_ATE_signed_capability_hack_a0"         , natural_of_hex "0xa0");
  ("DW_ATE_unsigned_capability_hack_a1"         , natural_of_hex "0xa1");
  ("DW_ATE_hi_user"         , natural_of_hex "0xff")
  ]
                                  
(** ************************************************************ *)
(** ** more missing pervasives and bits  *********************** *)
(** ************************************************************ *)


(* quick hacky workaround: this is in String.lem, in src_lem_library, but the linker doesn't find it *)
val myconcat : string -> list string -> string
let rec myconcat sep ss =
  match ss with
    | [] -> ""
    | s :: ss' ->
      match ss' with
      | [] -> s
      | _ -> s ^ sep ^ myconcat sep ss'
      end
  end
  
val myhead : forall 'a. list 'a -> 'a
let myhead l = match l with | x::xs -> x | [] -> Assert_extra.failwith "myhead of empty list" end


val myfindNonPure : forall 'a. ('a -> bool) -> list 'a -> 'a
let myfindNonPure P l = match (List.find P l) with
  | Just e      -> e
  | Nothing     -> Assert_extra.failwith "myfindNonPure"
end

val myfindmaybe : forall 'a 'b.  ('a -> maybe 'b) -> list 'a -> maybe 'b
let rec myfindmaybe f xs =
  match xs with
  | [] -> Nothing
  | x::xs' -> match f x with Just y -> Just y | Nothing -> myfindmaybe f xs' end
  end

val myfind : forall 'a.  ('a -> bool) -> list 'a -> maybe 'a
let rec myfind f xs =
  match xs with
  | [] -> Nothing
  | x::xs' -> match f x with true -> Just x | false -> myfind f xs' end
  end

val myfiltermaybe : forall 'a 'b.  ('a -> maybe 'b) -> list 'a -> list 'b
let rec myfiltermaybe f xs =
  match xs with
  | [] -> []
  | x::xs' -> match f x with Just y -> y::myfiltermaybe f xs'| Nothing -> myfiltermaybe f xs' end
  end



val bytes_of_natural: endianness -> natural (*size*) -> natural (*value*) -> byte_sequence
let bytes_of_natural en size n =
  byte_sequence_of_byte_list (
  if size = 8 then
    bytes_of_elf64_xword en (elf64_xword_of_natural n)
  else if size = 4 then
    bytes_of_elf32_word en (elf32_word_of_natural n)
  else
    Assert_extra.failwith "bytes_of_natural given size that is not 4 or 8")

let rec natural_of_bytes_little bs : natural =
  match read_char bs with
  | Fail _ -> 0
  | Success (b, bs') -> natural_of_byte b + 256 * natural_of_bytes_little bs'
  end

let rec natural_of_bytes_big acc bs =
  match read_char bs with
  | Fail _ -> acc
  | Success (b, bs') -> natural_of_bytes_big (natural_of_byte b + 256 * acc) bs'
end

val natural_of_bytes: endianness -> byte_sequence -> natural
let natural_of_bytes en bs =
  match en with
  | Little -> natural_of_bytes_little bs
  | Big -> natural_of_bytes_big 0 bs
  end


(* TODO: generalise *)
(*
  match bs with
  | b0::b1::b2::b3::b4::b5::b6::b7::[] ->
      let v = if en=Little then
        natural_of_byte b0 + 256*natural_of_byte b1 + 256*256*natural_of_byte b2 + 256*256*256*natural_of_byte b3
          + (256*256*256*256*(natural_of_byte b4 + 256*natural_of_byte b5 + 256*256*natural_of_byte b6 + 256*256*256*natural_of_byte b7))
      else
        natural_of_byte b7 + 256*natural_of_byte b6 + 256*256*natural_of_byte b5 + 256*256*256*natural_of_byte b4
          + (256*256*256*256*(natural_of_byte b3 + 256*natural_of_byte b2 + 256*256*natural_of_byte b1 + 256*256*256*natural_of_byte b0))
      in
      v
  | b0::b1::b2::b3::[] ->
      let v = if en=Little then
        natural_of_byte b0 + 256*natural_of_byte b1 + 256*256*natural_of_byte b2 + 256*256*256*natural_of_byte b3
      else
        natural_of_byte b3 + 256*natural_of_byte b2 + 256*256*natural_of_byte b1 + 256*256*256*natural_of_byte b0

      in
      v
  | b0::b1::[] ->
      let v = if en=Little then
        natural_of_byte b0 + 256*natural_of_byte b1
      else
        natural_of_byte b1 + 256*natural_of_byte b0

      in
      v
  | b0::[] ->
      natural_of_byte b0
  | _ -> Assert_extra.failwith "natural_of_bytes given not-8/4/2/1 bytes"
  end
*)

val bigunionListMap : forall 'a 'b. SetType 'b => ('a -> set 'b) -> list 'a -> set 'b
let rec bigunionListMap f xs =
  match xs with
  | [] -> {}
  | x::xs' -> Set.(union) (f x)  (bigunionListMap f xs')
  end

let rec mytake' (n:natural) acc xs =
  match (n,xs) with
  | (0, _) -> Just (List.reverse acc, xs)
  | (_, []) -> Nothing
  | (_, x::xs') -> mytake' (n-1) (x::acc) xs'
  end

val mytake : forall 'a.  natural -> (list 'a) -> maybe (list 'a * list 'a)
let mytake n xs = mytake' n [] xs

val mynth : forall 'a.  natural -> (list 'a) -> maybe 'a
let rec mynth (n:natural) xs =
  match (n,xs) with
  | (0, x::xs') -> Just x
  | (0, []) -> Nothing (*Assert_extra.failwith "mynth"*)
  | (_, x::xs') -> mynth (n-1) xs'
  end


(** basic pretty printing *)

let pphexplain n = unsafe_hex_string_of_natural 0 n
let pphex n = "0x" ^ pphexplain n

val abs : integer -> natural
(*declare hol      target_rep function abs = `int_of_num` *)
declare ocaml    target_rep function abs = `Nat_big_num.abs`
(*declare isabelle target_rep function abs = `int`
declare coq      target_rep function abs n = (`Zpred` (`Zpos` (`P_of_succ_nat` n))) (* TODO: check*)
*)

let pphex_integer n = if n<0 then "-" ^ pphex (abs n) else pphex (abs n)

let ppbytes bs = show (List.map (fun x -> show x) (byte_list_of_byte_sequence bs))

let rec ppbytes2 n bs =
  match read_char bs with
    | Fail _ -> ""
    | Success (x,xs') -> "<" ^ pphex n ^ ">  " ^ show x ^ "\n" ^ ppbytes2 (n+1) xs'
  end

let rec ppbytesplain (c:p_context) (n:natural) bs = show (natural_of_bytes c.endianness bs)
(*
  unsafe_hex_string_of_uc_list (List.map unsigned_char_of_byte xs) (*match xs with | [] -> "" | x::xs' -> pphexplain x ^ ppbytesplain (n+1) xs' end*)
*)
  
(* workaround: from String *)
val mytoString : list char -> string
declare ocaml    target_rep function mytoString = `Xstring.implode`

let string_of_bytes bs = mytoString (List.map Missing_pervasives.char_of_byte bs)


let just_one s xs =
  match xs with
  | [] -> Assert_extra.failwith ("no " ^ s)
  | x1::x2::_ -> Assert_extra.failwith ("more than one " ^ s)
  | [x] -> x
  end




let max_address (as': natural) : natural =
  match as' with
  | 4 -> natural_of_hex "0xffffffff"
  | 8 -> natural_of_hex "0xffffffffffffffff"
  | _ -> Assert_extra.failwith "max_address size not 4 or 8"
  end

let range_address (as': natural) : natural =
  match as' with
  | 4 -> natural_of_hex "0x100000000"
  | 8 -> natural_of_hex "0x10000000000000000"
  | _ -> Assert_extra.failwith "range_address size not 4 or 8"
  end

   

(** lookup of encodings *)

val lookup_Ab_b : forall 'a 'b. Eq 'a => 'a -> list ('a * 'b) -> maybe 'b
let rec lookup_Ab_b x0 xys =
  match xys with
  | [] -> Nothing
  | (x,y)::xys' -> if x=x0 then Just y else lookup_Ab_b x0 xys'
  end

val lookup_aB_a : forall 'a 'b. Eq 'b => 'b -> list ('a * 'b) -> maybe 'a
let rec lookup_aB_a y0 xys =
  match xys with
  | [] -> Nothing
  | (x,y)::xys' -> if y=y0 then Just x else lookup_aB_a y0 xys'
  end


val lookup_aBc_a : forall 'a 'b 'c. Eq 'b => 'b -> list ('a * 'b * 'c) -> maybe 'a
let rec lookup_aBc_a y0 xyzs =
  match xyzs with
  | [] -> Nothing
  | (x,y,_)::xyzs' -> if y=y0 then Just x else lookup_aBc_a y0 xyzs'
  end

val lookup_aBc_ac : forall 'a 'b 'c. Eq 'b => 'b -> list ('a * 'b * 'c) -> maybe ('a*'c)
let rec lookup_aBc_ac y0 xyzs =
  match xyzs with
  | [] -> Nothing
  | (x,y,z)::xyzs' -> if y=y0 then Just (x,z) else lookup_aBc_ac y0 xyzs'
  end

val lookup_Abc_b : forall 'a 'b 'c. Eq 'a => 'a -> list ('a * 'b * 'c) -> maybe 'b
let rec lookup_Abc_b x0 xyzs =
  match xyzs with
  | [] -> Nothing
  | (x,y,_)::xyzs' -> if x=x0 then Just y else lookup_Abc_b x0 xyzs'
  end



val lookup_aBcd_a : forall 'a 'b 'c 'd. Eq 'b => 'b -> list ('a * 'b * 'c * 'd) -> maybe 'a
let rec lookup_aBcd_a y0 xyzws =
  match xyzws with
  | [] -> Nothing
  | (x,y,_,_)::xyzws' -> if y=y0 then Just x else lookup_aBcd_a y0 xyzws'
  end

val lookup_aBcd_acd : forall 'a 'b 'c 'd. Eq 'b => 'b -> list ('a * 'b * 'c * 'd) -> maybe ('a * 'c * 'd)
let rec lookup_aBcd_acd y0 xyzws =
  match xyzws with
  | [] -> Nothing
  | (x,y,z,w)::xyzws' -> if y=y0 then Just (x,z,w) else lookup_aBcd_acd y0 xyzws'
  end

val lookup_abCde_de : forall 'a 'b 'c 'd 'e. Eq 'c => 'c -> list ('a * 'b * 'c * 'd * 'e) -> maybe ('d * 'e)
let rec lookup_abCde_de z0 xyzwus =
  match xyzwus with
  | [] -> Nothing
  | (x,y,z,w,u)::xyzwus' -> if z=z0 then Just (w,u) else lookup_abCde_de z0 xyzwus'
  end


let pp_maybe ppf n = match ppf n with Just s -> s | Nothing -> "Unknown AT value: " ^ pphexplain n (*encoding not found: "" ^ pphex n*) end

let pp_tag_encoding n = pp_maybe (fun n -> lookup_aB_a n tag_encodings) n
let pp_attribute_encoding n = pp_maybe (fun n -> lookup_aBc_a n attribute_encodings) n
let pp_attribute_form_encoding n = pp_maybe (fun n -> lookup_aBc_a n attribute_form_encodings) n
let pp_operation_encoding n = pp_maybe (fun n -> lookup_aBcd_a n operation_encodings) n

let tag_encode (s: string) : natural =
  match lookup_Ab_b s tag_encodings with
  | Just n -> n
  | Nothing -> Assert_extra.failwith ("tag_encode: \""^s^"\"")
  end

let attribute_encode (s: string) : natural =
  match lookup_Abc_b s attribute_encodings with
  | Just n -> n
  | Nothing -> Assert_extra.failwith ("attribute_encode: \""^s^"\"")
  end

let attribute_form_encode (s: string) : natural =
  match lookup_Abc_b s attribute_form_encodings with
  | Just n -> n
  | Nothing -> Assert_extra.failwith "attribute_form_encode"
  end

let base_type_attribute_encode (s: string) : natural =
  match lookup_Ab_b s base_type_attribute_encodings with
  | Just n -> n
  | Nothing -> Assert_extra.failwith "base_type_attribute_encode"
  end
   


(** ************************************************************ *)
(** **  parser combinators and primitives  ********************* *)
(** ************************************************************ *)

(* parsing combinators *)

type parse_context = <| pc_bytes: byte_sequence; pc_offset: natural |>

type parse_result 'a =
  | PR_success of 'a * parse_context
  | PR_fail of string * parse_context

type parser 'a = parse_context -> parse_result 'a

let pp_parse_context pc = "pc_offset = " ^ pphex pc.pc_offset

let pp_parse_fail s pc =
  "Parse fail\n" ^ s ^ " at " ^ pp_parse_context pc ^ "\n"

let pp_parse_result ppa pr =
  match pr with
  | PR_success x pc -> "Parse success\n" ^ ppa x ^ "\n" ^ pp_parse_context pc ^ "\n"
  | PR_fail s pc -> pp_parse_fail s pc
  end

(* [(>>=)] should be the monadic binding function for [parse_result].  *)
(* but there's a type clash if we use >>=, and lem seems to output bad ocaml for >>>=. So we just use a non-infix version for now *)

val pr_bind : forall 'a 'b. parse_result 'a -> ('a -> parser 'b) -> parse_result 'b
let pr_bind x f =
  match x with
  | PR_success v pc -> f v pc
  | PR_fail err pc  -> PR_fail err pc
  end

val pr_return : forall 'a. 'a -> (parser 'a)
let pr_return x pc = PR_success x pc

val pr_map : forall 'a 'b. ('a -> 'b) -> parse_result 'a -> parse_result 'b
let pr_map f x =
  match x with
  | PR_success v pc -> PR_success (f v) pc
  | PR_fail err pc  -> PR_fail err pc
  end

val pr_map2 : forall 'a 'b. ('a -> 'b) -> (parser 'a) -> (parser 'b)
let pr_map2 f p = fun pc -> pr_map f (p pc)

val pr_post_map1 : forall 'a 'b. (parse_result 'a) -> ('a -> 'b) -> (parse_result 'b)
let pr_post_map1 x f = pr_map f x

(*
val pr_post_map : forall 'a 'b 'c. ('c -> parse_result 'a) -> ('a -> 'b) -> ('c -> parse_result 'b)
let pr_post_map g f = fun x ->  pr_map f (g x)
*)
val pr_post_map : forall 'a 'b. (parser 'a) -> ('a -> 'b) -> (parser 'b)
let pr_post_map p f = fun (pc: parse_context) -> pr_map f (p pc)


val pr_with_pos : forall 'a. (parser 'a) -> (parser (natural * 'a))
let pr_with_pos p = fun pc -> pr_map (fun x -> (pc.pc_offset,x)) (p pc)


val parse_pair : forall 'a 'b. (parser 'a) -> (parser 'b) -> (parser ('a * 'b))
let parse_pair p1 p2 =
  fun pc ->
    let _ = my_debug "pair " in
    pr_bind (p1 pc) (fun x pc' -> match p2 pc' with
    | PR_success y pc'' -> PR_success (x,y) pc''
    | PR_fail s pc'' -> PR_fail s pc''
    end)

val parse_triple : forall 'a 'b 'c. (parser 'a) -> (parser 'b) -> (parser 'c) -> parser ('a * ('b * 'c))
let parse_triple p1 p2 p3 =
  parse_pair p1 (parse_pair p2 p3)

val parse_quadruple : forall 'a 'b 'c 'd. (parser 'a) -> (parser 'b) -> (parser 'c) -> (parser 'd) -> parser ('a * ('b * ('c * 'd)))
let parse_quadruple p1 p2 p3 p4 =
  parse_pair p1 (parse_pair p2 (parse_pair p3 p4))

val parse_pentuple : forall 'a 'b 'c 'd 'e. (parser 'a) -> (parser 'b) -> (parser 'c) -> (parser 'd) -> (parser 'e) -> parser ('a * ('b * ('c * ('d * 'e))))
let parse_pentuple p1 p2 p3 p4 p5 =
  parse_pair p1 (parse_pair p2 (parse_pair p3 (parse_pair p4 p5)))

val parse_sextuple : forall 'a 'b 'c 'd 'e 'f. (parser 'a) -> (parser 'b) -> (parser 'c) -> (parser 'd) -> (parser 'e) -> (parser 'f) -> parser ('a * ('b * ('c * ('d * ('e * 'f)))))
let parse_sextuple p1 p2 p3 p4 p5 p6 =
  parse_pair p1 (parse_pair p2 (parse_pair p3 (parse_pair p4 (parse_pair p5 p6))))

val parse_dependent_pair : forall 'a 'b. (parser 'a) -> ('a -> parser 'b) -> (parser ('a * 'b))
let parse_dependent_pair p1 p2 =
  fun pc ->
    pr_bind (p1 pc) (fun x pc' -> match p2 x pc' with
    | PR_success y pc'' -> PR_success (x,y) pc''
    | PR_fail s pc'' -> PR_fail s pc''
    end)

val parse_dependent : forall 'a 'b. (parser 'a) -> ('a -> parser 'b) -> (parser 'b)
let parse_dependent p1 p2 =
  fun pc ->
    pr_bind (p1 pc) (fun x pc' -> p2 x pc')



val parse_list' : forall 'a. (parser (maybe 'a)) -> (list 'a -> parser (list 'a))
let rec parse_list' p1 =
  fun acc pc ->   let _ = my_debug "list' " in pr_bind (p1 pc) (fun mx pc' ->
    match mx with
    | Nothing -> PR_success acc pc'
    | Just x -> parse_list' p1 (x :: acc) pc'
    end)

val parse_list : forall 'a. (parser (maybe 'a)) -> (parser (list 'a))
let parse_list p1 =
  pr_post_map
    (parse_list' p1 [])
    (List.reverse)

val parse_parser_list : forall 'a. (list (parser 'a)) -> (parser (list 'a))
let rec parse_parser_list ps =
  match ps with
  | [] -> pr_return []
  | p::ps' ->
      (fun pc -> pr_bind (p pc) (fun x pc' ->
        match parse_parser_list ps' pc' with
        | PR_success xs pc'' -> PR_success (x::xs) pc''
        | PR_fail s pc'' -> PR_fail s pc''
        end))
  end

val parse_maybe : forall 'a. parser 'a -> parser (maybe 'a)
let parse_maybe p =
  fun pc ->
    match Byte_sequence.length pc.pc_bytes with
    | 0 -> pr_return Nothing pc
    | _ ->
        match p pc with
        | PR_success v pc'' -> PR_success (Just v) pc''
        | PR_fail s pc'' -> PR_fail s pc''
        end
    end

val parse_demaybe : forall 'a. string ->parser (maybe 'a) -> parser 'a
let parse_demaybe s p =
  fun pc ->
    match p pc with
        | PR_success (Just v) pc'' -> PR_success v pc''
        | PR_success (Nothing) pc'' -> PR_fail s pc''
        | PR_fail s pc'' -> PR_fail s pc''

    end


val parse_restrict_length : forall 'a. natural -> parser 'a -> parser 'a
let parse_restrict_length n p =
  fun pc ->
    match partition n pc.pc_bytes with
    | Fail _ -> Assert_extra.failwith "parse_restrict_length not given enough bytes"
    | Success (xs,ys) ->
        let pc' = <| pc_bytes = xs; pc_offset = pc.pc_offset |> in
        p pc'
    end


(* parsing of basic types *)

let parse_byte : parser(byte) =
  fun (pc:parse_context) ->
    match read_char pc.pc_bytes with
    | Fail _ -> PR_fail "parse_byte" pc
    | Success (b,bs) -> PR_success b (<|pc_bytes=bs; pc_offset= pc.pc_offset + 1 |> )
    end

let parse_n_bytes (n:natural) : parser (byte_sequence) =
  fun (pc:parse_context) ->
    match partition n pc.pc_bytes with
      | Fail _ -> PR_fail ("parse_n_bytes n=" ^ pphex n) pc
      | Success (xs,bs) ->
          PR_success xs (<|pc_bytes=bs; pc_offset= pc.pc_offset + (Byte_sequence.length xs) |> )
    end

let bzero = byte_of_natural 0

let parse_string : parser (byte_sequence) =
  fun (pc:parse_context) ->
    match find_byte pc.pc_bytes bzero with
      | Nothing -> PR_fail "parse_string" pc
      | Just n ->
          pr_bind (parse_n_bytes n pc) (fun res pc ->
          pr_bind (parse_byte pc) (fun _ pc ->
          pr_return res pc))
    end

(* parse a null-terminated string; return Nothing if it is empty, Just s otherwise *)
let parse_non_empty_string : parser (maybe byte_sequence) =
  fun (pc:parse_context) ->
  pr_bind (parse_string pc) (fun str pc ->
    if Byte_sequence.length str = 0 then
      pr_return Nothing pc
    else
      pr_return (Just str) pc)


let parse_uint8 : parser natural =
  fun (pc:parse_context) ->
    let _ = my_debug "uint8 " in
    match read_char pc.pc_bytes with
      | Success (b, bytes) ->
          let v = natural_of_byte b in
          PR_success v (<| pc_bytes = bytes; pc_offset = pc.pc_offset + 1 |>)
      | _ -> PR_fail "parse_uint32 not given enough bytes" pc
    end

let parse_uint8_constant (v:natural) : parser natural =
    fun (pc:parse_context) ->
      let _ = my_debug "uint8_constant " in
      PR_success v pc


let parse_uint16 c : parser natural =
    fun (pc:parse_context) ->
      let _ = my_debug "uint16 " in
      match read_2_bytes_be pc.pc_bytes with
      | Success ((b0,b1),bytes') ->
          let v = if c.endianness=Little then
            natural_of_byte b0 + 256*natural_of_byte b1
          else
            natural_of_byte b1 + 256*natural_of_byte b0 in
          PR_success v (<| pc_bytes = bytes'; pc_offset = pc.pc_offset + 2 |>)
      | _ -> PR_fail "parse_uint32 not given enough bytes" pc
      end

let parse_uint32 c : parser natural =
    fun (pc:parse_context) ->
      let _ = my_debug "uint32 " in
      match read_4_bytes_be pc.pc_bytes with
      | Success ((b0,b1,b2,b3),bytes') ->
          let v = if c.endianness=Little then
            natural_of_byte b0 + 256*natural_of_byte b1 + 256*256*natural_of_byte b2 + 256*256*256*natural_of_byte b3
          else
            natural_of_byte b3 + 256*natural_of_byte b2 + 256*256*natural_of_byte b1 + 256*256*256*natural_of_byte b0 in
          PR_success v (<| pc_bytes = bytes'; pc_offset = pc.pc_offset + 4 |>)
      | _ -> PR_fail "parse_uint32 not given enough bytes" pc
      end

let parse_uint64 c : parser natural =
    fun (pc:parse_context) ->
      let _ = my_debug "uint64 " in
      match read_8_bytes_be pc.pc_bytes with
      | Success ((b0,b1,b2,b3,b4,b5,b6,b7),bytes') ->
          let v = if c.endianness=Little then
            natural_of_byte b0 + 256*natural_of_byte b1 + 256*256*natural_of_byte b2 + 256*256*256*natural_of_byte b3
              + (256*256*256*256*(natural_of_byte b4 + 256*natural_of_byte b5 + 256*256*natural_of_byte b6 + 256*256*256*natural_of_byte b7))
          else
            natural_of_byte b7 + 256*natural_of_byte b6 + 256*256*natural_of_byte b5 + 256*256*256*natural_of_byte b4
              + (256*256*256*256*(natural_of_byte b3 + 256*natural_of_byte b2 + 256*256*natural_of_byte b1 + 256*256*256*natural_of_byte b0))
          in
          PR_success v (<| pc_bytes = bytes'; pc_offset = pc.pc_offset + 8 |>)
      | _ -> PR_fail "parse_uint64 not given enough bytes" pc
      end

let integerFromTwosComplementNatural (n:natural) (half: natural) (all:integer) : integer =
  if n < half then integerFromNatural n else integerFromNatural n - all

let partialTwosComplementNaturalFromInteger (i:integer) (half: natural) (all:integer) : natural =
  if i >=0 && i < integerFromNatural half then partialNaturalFromInteger i
  else if i >= (0-integerFromNatural half) && i < 0 then partialNaturalFromInteger (all + i)
  else Assert_extra.failwith "partialTwosComplementNaturalFromInteger"


let parse_sint8 : parser integer =
  pr_post_map (parse_uint8) (fun n -> integerFromTwosComplementNatural n 128 256)

let parse_sint16 c : parser integer =
  pr_post_map (parse_uint16 c) (fun n -> integerFromTwosComplementNatural n (128*256) (256*256))

let parse_sint32 c : parser integer =
  pr_post_map (parse_uint32 c) (fun n -> integerFromTwosComplementNatural n (128*256*256*256) (256*256*256*256))

let parse_sint64 c : parser integer =
  pr_post_map (parse_uint64 c) (fun n -> integerFromTwosComplementNatural n (128*256*256*256*256*256*256*256) (256*256*256*256*256*256*256*256))

let rec parse_ULEB128' (acc: natural) (shift_factor: natural) : parser natural =
    fun (pc:parse_context) ->
      let _ = my_debug "ULEB128' " in
      match read_char pc.pc_bytes with
      | Success (b,bytes') ->
          let n = natural_of_byte b in
          let acc' = (natural_land n 127) * shift_factor + acc in
          let finished = ((natural_land n 128) = 0) in
          let pc' = <| pc_bytes = bytes'; pc_offset = pc.pc_offset + 1 |> in
          if finished then
            PR_success acc' pc'
          else
            parse_ULEB128' acc' (shift_factor * 128) pc'
      | _ ->
          PR_fail "parse_ULEB128' not given enough bytes" pc
      end

let parse_ULEB128 : parser natural =
  fun (pc:parse_context) ->
    parse_ULEB128' 0 1 pc

let rec parse_SLEB128' (acc: natural) (shift_factor: natural) : parser (bool * natural * natural) =
    fun (pc:parse_context) ->
      let _ = my_debug "SLEB128' " in
      match read_char pc.pc_bytes with
      | Success (b,bytes') ->
          let n = natural_of_byte b in
          let acc' = acc + (natural_land n 127) * shift_factor in
          let shift_factor' = shift_factor * 128 in
          let finished = ((natural_land n 128) = 0) in
          let positive = ((natural_land n 64) = 0) in
          let pc' = <| pc_bytes = bytes'; pc_offset = pc.pc_offset + 1 |> in
          if finished then
            PR_success (positive, shift_factor', acc') pc'
          else
            parse_SLEB128' acc' shift_factor' pc'
      | _ ->
          PR_fail "parse_SLEB128' not given enough bytes" pc
      end

let parse_SLEB128 : parser integer =
    pr_post_map (parse_SLEB128' 0 1) (fun (positive, shift_factor, acc) ->
       if positive then integerFromNatural acc else integerFromNatural acc - integerFromNatural shift_factor)

let parse_nonzero_ULEB128_pair : parser (maybe (natural*natural)) =
  let _ = my_debug "nonzero_ULEB128_pair " in
  pr_post_map
    (parse_pair parse_ULEB128 parse_ULEB128)
    (fun (n1,n2) -> if n1=0 && n2=0 then Nothing else Just (n1,n2))

let parse_zero_terminated_ULEB128_pair_list : parser (list (natural*natural)) =
  let _ = my_debug "zero_terminated_ULEB128_pair_list " in
  parse_list parse_nonzero_ULEB128_pair

let parse_uintDwarfN c (df: dwarf_format) : parser natural =
    match df with
    | Dwarf32 -> (parse_uint32 c)
    | Dwarf64 -> (parse_uint64 c)
    end

let parse_uint_address_size c (as': natural) : parser natural =
    match as' with
    | 4 -> (parse_uint32 c)
    | 8 -> (parse_uint64 c)
    | _ -> Assert_extra.failwith ("cuh_address_size not 4 or 8: " ^ show as')
    end

let parse_uint_segment_selector_size c (ss: natural) : parser (maybe natural) =
    match ss with
    | 0 -> pr_return Nothing
    | 1 -> pr_post_map (parse_uint8)    (fun n -> Just n)
    | 2 -> pr_post_map (parse_uint16 c) (fun n -> Just n)
    | 4 -> pr_post_map (parse_uint32 c) (fun n -> Just n)
    | 8 -> pr_post_map (parse_uint64 c) (fun n -> Just n)
    | _ -> Assert_extra.failwith "cuh_address_size not 4 or 8"
    end



(** ************************************************************ *)
(** **  parsing and pretty printing of .debug_* sections  ****** *)
(** ************************************************************ *)


(** abbreviations table: pp and parsing *)

let pp_abbreviation_declaration (x:abbreviation_declaration) =
  "   "
  ^ show x.ad_abbreviation_code ^ "      "
  ^ pp_tag_encoding x.ad_tag ^ "    "
  ^ (if x.ad_has_children then "[has children]" else "[no children]")
  ^ "\n"
(*  ^ " "^show (List.length x.ad_attribute_specifications) ^ " attributes\n"*)
  ^ String.concat ""
      (List.map
         (fun (n1,n2) ->
           "    " ^ right_space_padded_to 18 (pp_attribute_encoding n1) ^ " " ^ pp_attribute_form_encoding n2 ^ "\n")
         x.ad_attribute_specifications)
  ^ "    DW_AT value: 0     DW_FORM value: 0\n"

      
let pp_abbreviations_table (x:abbreviations_table) =
  "offset: "^pphex x.at_offset^"\n"
  ^ String.concat "" (List.map (pp_abbreviation_declaration) x.at_table)

(* print the distinct abbreviation tables used by all compilation units *)
let rec remove_duplicates xys xys_acc =
  match xys with
  | [] -> List.reverse xys_acc
  | (x,y)::xys' ->
      if List.any (fun (x',y') -> x'=x) xys_acc then
        remove_duplicates xys' xys_acc
      else
        remove_duplicates xys' ((x,y)::xys_acc)
  end
  
let pp_abbreviations_tables (d:dwarf) = 
  let xs : list (natural * abbreviations_table) =
    List.map
      (fun cu -> (cu.cu_header.cuh_debug_abbrev_offset, cu.cu_abbreviations_table)) 
      d.d_compilation_units in
  let ys = remove_duplicates xs [] in
  String.concat "*********************\n" (List.map (fun (x,y)->pp_abbreviations_table y) ys)
  


    
let parse_abbreviation_declaration c : parser (maybe abbreviation_declaration) =
    fun (pc: parse_context) ->
      pr_bind (parse_ULEB128 pc) (fun n1 pc' ->
        if n1 = 0 then
          PR_success Nothing pc'
        else
          pr_bind (parse_ULEB128 pc') (fun n2 pc'' ->
            pr_bind (parse_uint8 pc'') (fun c pc''' ->
              pr_post_map1
                (parse_zero_terminated_ULEB128_pair_list pc''')
                (fun l ->
                  Just ( let ad =
                    <|
                    ad_abbreviation_code = n1;
                    ad_tag = n2;
                    ad_has_children = (c<>0);
                    ad_attribute_specifications = l;
                  |> in (* let _ = my_debug2 (pp_abbreviation_declaration ad) in *) ad)
                ))))

let parse_abbreviations_table c =
  parse_list (parse_abbreviation_declaration c)


(** debug_str entry *)

let rec null_terminated_bs (bs: byte_sequence) : byte_sequence =
  match find_byte bs bzero with
  | Just i ->
      match takebytes i bs with
        | Success bs' -> bs'
        | Fail _ -> Assert_extra.failwith "find_byte or take_byte is broken"
      end
  | Nothing -> bs
  end

let pp_debug_str_entry (str: byte_sequence) (n: natural) : string =
  match dropbytes n str with
  | Fail _ -> "strp beyond .debug_str extent"
  | Success bs -> string_of_byte_sequence (null_terminated_bs bs)
  end

(** operations: pp and parsing *)

let pp_operation_argument_value (oav:operation_argument_value) : string =
  match oav with
  | OAV_natural n -> pphex n
  | OAV_integer n -> pphex_integer n (* show n*)
  | OAV_block n bs -> pphex n ^ " " ^ ppbytes bs
  end

let pp_operation_semantics (os: operation_semantics) : string =
  match os with
  | OpSem_lit                         -> "OpSem_lit"
  | OpSem_deref                       -> "OpSem_deref"
  | OpSem_stack _                     -> "OpSem_stack ..."
  | OpSem_not_supported               -> "OpSem_not_supported"
  | OpSem_binary _                    -> "OpSem_binary ..."
  | OpSem_unary _                     -> "OpSem_unary ..."
  | OpSem_opcode_lit _                -> "OpSem_opcode_lit ..."
  | OpSem_reg                         -> "OpSem_reg"
  | OpSem_breg                        -> "OpSem_breg"
  | OpSem_bregx                       -> "OpSem_bregx"
  | OpSem_fbreg                       -> "OpSem_fbreg"
  | OpSem_deref_size                  -> "OpSem_deref_size"
  | OpSem_nop                         -> "OpSem_nop"
  | OpSem_piece                       -> "OpSem_piece"
  | OpSem_bit_piece                   -> "OpSem_bitpiece"
  | OpSem_implicit_value              -> "OpSem_implicit_value"
  | OpSem_stack_value                 -> "OpSem_stack_value"
  | OpSem_call_frame_cfa              -> "OpSem_call_frame_cfa"
  end

let pp_operation_semantics_brief (os: operation_semantics) : string =
  match os with
  | OpSem_not_supported               -> " (OpSem_not_supported)"
  | _ -> ""
  end
   
let pp_operation (op: operation) : string =
  op.op_string ^ (match op.op_argument_values with [] -> "" | _ -> " " ^ String.concat " " (List.map pp_operation_argument_value op.op_argument_values) end) ^ pp_operation_semantics_brief op.op_semantics 

let pp_operations (ops: list operation) : string =
  String.concat "; " (List.map pp_operation ops)

val parser_of_operation_argument_type : p_context -> compilation_unit_header -> operation_argument_type -> (parser operation_argument_value)
let parser_of_operation_argument_type c cuh oat =
  match oat with
    | OAT_addr ->
        pr_map2 (fun n -> OAV_natural n) (parse_uint_address_size c cuh.cuh_address_size)
    | OAT_dwarf_format_t ->
        pr_map2 (fun n -> OAV_natural n) (parse_uintDwarfN c cuh.cuh_dwarf_format)
    | OAT_uint8   -> pr_map2 (fun n -> OAV_natural n) (parse_uint8)
    | OAT_uint16  -> pr_map2 (fun n -> OAV_natural n) (parse_uint16 c)
    | OAT_uint32  -> pr_map2 (fun n -> OAV_natural n) (parse_uint32 c)
    | OAT_uint64  -> pr_map2 (fun n -> OAV_natural n) (parse_uint64 c)
    | OAT_sint8   -> pr_map2 (fun n -> OAV_integer n) (parse_sint8)
    | OAT_sint16  -> pr_map2 (fun n -> OAV_integer n) (parse_sint16 c)
    | OAT_sint32  -> pr_map2 (fun n -> OAV_integer n) (parse_sint32 c)
    | OAT_sint64  -> pr_map2 (fun n -> OAV_integer n) (parse_sint64 c)
    | OAT_ULEB128 -> pr_map2 (fun n -> OAV_natural n) parse_ULEB128
    | OAT_SLEB128 -> pr_map2 (fun n -> OAV_integer n) parse_SLEB128
    | OAT_block   ->
      (fun pc -> pr_bind (parse_ULEB128 pc) (fun n pc' ->
        pr_map (fun bs -> OAV_block n bs) (parse_n_bytes n pc')))
  end

val parse_operation : p_context -> compilation_unit_header -> parser (maybe operation)
let parse_operation c cuh pc =
  match parse_uint8 pc with
  | PR_fail s pc' -> PR_success Nothing pc
  | PR_success code pc' ->
      match lookup_aBcd_acd code operation_encodings with
      | Nothing -> PR_fail ("encoding not found: " ^ pphex code) pc
      | Just (s,oats,opsem) ->
          let ps = List.map (parser_of_operation_argument_type c cuh) oats in
          (pr_post_map
            (parse_parser_list ps)
            (fun oavs -> Just <| op_code = code; op_string = s; op_argument_values = oavs; op_semantics = opsem |>)
          )
            pc'
      end
  end

val parse_operations : p_context -> compilation_unit_header -> parser (list operation)
let parse_operations c cuh =
  parse_list (parse_operation c cuh)

let parse_operations_bs c cuh bs : list operation =
  let pc = <|pc_bytes = bs; pc_offset = 0  |> in
  match parse_operations c cuh pc with
  | PR_fail s pc' -> Assert_extra.failwith ("parse_operations_bs fail: " ^ pp_parse_fail s pc')
  | PR_success ops pc' ->
     let _ = if Byte_sequence.length pc'.pc_bytes <> 0 then Assert_extra.failwith ("parse_operations_bs extra non-parsed bytes") else () in
     ops
  end



val parse_and_pp_operations : p_context -> compilation_unit_header -> byte_sequence -> string
let parse_and_pp_operations c cuh bs =
  let pc = <|pc_bytes = bs; pc_offset = 0  |> in
  match parse_operations c cuh pc with
  | PR_fail s pc' -> "parse_operations fail: " ^ pp_parse_fail s pc'
  | PR_success ops pc' ->
      pp_operations ops
      ^ if Byte_sequence.length pc'.pc_bytes <> 0 then " Warning: extra non-parsed bytes" else ""
  end


(** attribute values: pp and parsing *)

val pp_attribute_value_plain :  attribute_value -> string
let pp_attribute_value_plain av =
  match av with
  | AV_addr x -> "AV_addr " ^ pphex x
  | AV_block n bs -> "AV_block " ^ show n ^ " " ^ ppbytes bs
  | AV_constantN n bs -> "AV_constantN " ^ show n ^ " " ^ ppbytes bs
  | AV_constant_SLEB128 i -> "AV_constant_SLEB128 " ^ show i
  | AV_constant_ULEB128 n -> "AV_constant_ULEB128 " ^ show n
  | AV_exprloc n bs ->
    String.concat " " ["AV_exprloc"; show n; ppbytes bs]
  | AV_flag b -> "AV_flag " ^ show b
  | AV_ref n -> "AV_ref " ^ pphex n
  | AV_ref_addr n -> "AV_ref_addr " ^ pphex n
  | AV_ref_sig8 n -> "AV_ref_sig8 " ^ pphex n
  | AV_sec_offset n -> "AV_sec_offset " ^ pphex  n
  | AV_string bs -> string_of_byte_sequence bs
  | AV_strp n -> "AV_sec_offset " ^ pphex n ^ " "
  end

   
val pp_attribute_value : p_context -> compilation_unit_header -> byte_sequence -> natural (*attribute tag*) -> attribute_value -> string
let pp_attribute_value c cuh str at av =
  match av with
  | AV_addr x -> "AV_addr " ^ pphex x
  | AV_block n bs -> "AV_block " ^ show n ^ " " ^ ppbytes bs
      ^ if at = attribute_encode "DW_AT_location" then " " ^ parse_and_pp_operations c cuh bs else ""
  | AV_constantN n bs -> "AV_constantN " ^ show n ^ " " ^ ppbytes bs
  | AV_constant_SLEB128 i -> "AV_constant_SLEB128 " ^ show i
  | AV_constant_ULEB128 n -> "AV_constant_ULEB128 " ^ show n
  | AV_exprloc n bs ->
    String.concat " " ["AV_exprloc"; show n; ppbytes bs; parse_and_pp_operations c cuh bs]
  | AV_flag b -> "AV_flag " ^ show b
  | AV_ref n -> "AV_ref " ^ pphex n
  | AV_ref_addr n -> "AV_ref_addr " ^ pphex n
  | AV_ref_sig8 n -> "AV_ref_sig8 " ^ pphex n
  | AV_sec_offset n -> "AV_sec_offset " ^ pphex  n
  | AV_string bs -> string_of_byte_sequence bs
  | AV_strp n -> "AV_sec_offset " ^ pphex n ^ " "
      ^ pp_debug_str_entry str n
  end

val pp_attribute_value_like_objdump : p_context -> compilation_unit_header -> byte_sequence -> natural (*attribute tag*) -> attribute_value -> string
let pp_attribute_value_like_objdump c cuh str at av =
  match av with
  | AV_addr x -> (*"AV_addr " ^*) pphex x
  | AV_block n bs -> (*"AV_block " ^ show n ^ " " ^ ppbytes bs
      ^ if at = attribute_encode "DW_AT_location" then " " ^ parse_and_pp_operations c cuh bs else ""*) 
   (* show n ^ " byte block: " *) ppbytesplain c n bs
      ^ if at = attribute_encode "DW_AT_location" then " " ^ parse_and_pp_operations c cuh bs else ""
  | AV_constantN n bs -> ppbytes bs (*"AV_constantN " ^ show n ^ " " ^ ppbytes bs*)
  | AV_constant_SLEB128 i -> (*"AV_constant_SLEB128 " ^*) show i
  | AV_constant_ULEB128 n -> (*"AV_constant_ULEB128 " ^*) show n
  | AV_exprloc n bs -> (*"AV_exprloc " ^ show n ^ " " ^*) ppbytes bs
      ^ " " ^ parse_and_pp_operations c cuh bs
  | AV_flag b -> (*"AV_flag " ^*)if b then "1" else "0"
  | AV_ref n -> (*"AV_ref " ^*) "<"^pphex (n + cuh.cuh_offset)^">"
  | AV_ref_addr n -> (*"AV_ref_addr " ^*) "<"^pphex n^">"
  | AV_ref_sig8 n -> "AV_ref_sig8 " ^ pphex n
  | AV_sec_offset n -> (*"AV_sec_offset " ^*) pphex  n
     ^ if at = attribute_encode "DW_AT_location" then " (location list)"  else ""
  | AV_string bs -> string_of_byte_sequence bs
  | AV_strp n -> (*"AV_sec_offset " ^ pphex n ^ " "
                   ^ pp_debug_str_entry str n*)
      "(indirect string, offset: "^pphex n ^ "): " ^ pp_debug_str_entry str n
  end


  

val parser_of_attribute_form_non_indirect : p_context -> compilation_unit_header -> natural -> parser attribute_value
let parser_of_attribute_form_non_indirect c cuh n =
(* address*)
  if n = attribute_form_encode "DW_FORM_addr"         then
    pr_map2 (fun n -> AV_addr n) (parse_uint_address_size c cuh.cuh_address_size)
(* block *)
  else if n = attribute_form_encode "DW_FORM_block1"       then
    (fun pc -> pr_bind (parse_uint8 pc) (fun n pc' ->
      pr_map (fun bs -> AV_block n bs) (parse_n_bytes n pc')))
  else if n = attribute_form_encode "DW_FORM_block2"       then
    (fun pc -> pr_bind (parse_uint16 c pc) (fun n pc' ->
      pr_map (fun bs -> AV_block n bs) (parse_n_bytes n pc')))
  else if n = attribute_form_encode "DW_FORM_block4"       then
    (fun pc -> pr_bind (parse_uint32 c pc) (fun n pc' ->
      pr_map (fun bs -> AV_block n bs) (parse_n_bytes n pc')))
  else if n = attribute_form_encode "DW_FORM_block"        then
    (fun pc -> pr_bind (parse_ULEB128 pc) (fun n pc' ->
      pr_map (fun bs -> AV_block n bs) (parse_n_bytes n pc')))
(* constant *)
  else if n = attribute_form_encode "DW_FORM_data1"        then
    pr_map2 (fun bs -> AV_block 1 bs) (parse_n_bytes 1)
  else if n = attribute_form_encode "DW_FORM_data2"        then
    pr_map2 (fun bs -> AV_block 2 bs) (parse_n_bytes 2)
  else if n = attribute_form_encode "DW_FORM_data4"        then
    pr_map2 (fun bs -> AV_block 4 bs) (parse_n_bytes 4)
  else if n = attribute_form_encode "DW_FORM_data8"        then
    pr_map2 (fun bs -> AV_block 8 bs) (parse_n_bytes 8)
  else if n = attribute_form_encode "DW_FORM_sdata"        then
    pr_map2 (fun i -> AV_constant_SLEB128 i) parse_SLEB128
  else if n = attribute_form_encode "DW_FORM_udata"        then
    pr_map2 (fun n -> AV_constant_ULEB128 n) parse_ULEB128
(* exprloc *)
  else if n = attribute_form_encode "DW_FORM_exprloc"      then
    (fun pc -> pr_bind (parse_ULEB128 pc) (fun n pc' ->
      pr_map (fun bs -> AV_exprloc n bs) (parse_n_bytes n pc')))
(* flag *)
  else if n = attribute_form_encode "DW_FORM_flag"         then
    pr_map2 (fun n -> AV_flag (n<>0)) (parse_uint8)
  else if n = attribute_form_encode "DW_FORM_flag_present" then
    pr_map2 (fun () -> AV_flag true) (pr_return ())
(* lineptr, loclistptr, macptr, rangelistptr *)
  else if n = attribute_form_encode "DW_FORM_sec_offset"   then
    pr_map2 (fun n -> AV_sec_offset n) (parse_uintDwarfN c cuh.cuh_dwarf_format)
(* reference - first type *)
  else if n = attribute_form_encode "DW_FORM_ref1"         then
    pr_map2 (fun n -> AV_ref n) (parse_uint8)
  else if n = attribute_form_encode "DW_FORM_ref2"         then
    pr_map2 (fun n -> AV_ref n) (parse_uint16 c)
  else if n = attribute_form_encode "DW_FORM_ref4"         then
    pr_map2 (fun n -> AV_ref n) (parse_uint32 c)
  else if n = attribute_form_encode "DW_FORM_ref8"         then
    pr_map2 (fun n -> AV_ref n) (parse_uint64 c)
  else if n = attribute_form_encode "DW_FORM_ref_udata"    then
    pr_map2 (fun n -> AV_ref n) parse_ULEB128
(* reference - second type *)
  else if n = attribute_form_encode "DW_FORM_ref_addr"     then
    pr_map2 (fun n -> AV_ref_addr n) (parse_uintDwarfN c cuh.cuh_dwarf_format)
(* reference - third type *)
  else if n = attribute_form_encode "DW_FORM_ref_sig8"     then
    pr_map2 (fun n -> AV_ref_sig8 n) (parse_uint64 c)
(* string *)
  else if n = attribute_form_encode "DW_FORM_string"       then
    pr_map2 (fun bs -> AV_string bs) parse_string
  else if n = attribute_form_encode "DW_FORM_strp"         then
    pr_map2 (fun n -> AV_strp n) (parse_uintDwarfN c cuh.cuh_dwarf_format)
(* indirect (cycle detection) *)
  else if n = attribute_form_encode "DW_FORM_indirect"     then
    Assert_extra.failwith "DW_FORM_INDIRECT cycle"
(* unknown *)
  else
    Assert_extra.failwith "parser_of_attribute_form_non_indirect: unknown attribute form"


let parser_of_attribute_form c cuh n =
  if n = attribute_form_encode "DW_FORM_indirect" then
    (fun pc -> pr_bind (parse_ULEB128 pc) (fun n ->
      parser_of_attribute_form_non_indirect c cuh n) )
  else
    parser_of_attribute_form_non_indirect c cuh n


(* *** where to put this? *)

let pp_pos pos = "<" ^ pphexplain pos ^">"

let pp_cupdie (cu,parents,die) = pp_pos cu.cu_header.cuh_offset ^ "/" ^ pp_pos die.die_offset

let pp_cupdie3 (cu,parents,die) = pp_pos die.die_offset ^ "/" ^ String.concat "/" (List.map (fun p -> pp_pos p.die_offset) parents) ^ "/" ^ pp_pos cu.cu_header.cuh_offset
                                                              

(** ************************************************************ *)
(** **  finding things in the die tree                           *)
(** ************************************************************ *)

val find_maybe : forall 'a 'b. ('a -> maybe 'b) -> list 'a -> maybe 'b
let rec find_maybe f l =
  match l with
  | []      -> Nothing
  | x :: xs ->
     match f x with
     | Just y -> Just y
     | Nothing -> find_maybe f xs
     end
  end

let rec find_die_by_offset_in_cu offset cu : maybe cupdie =
  match Map.lookup offset cu.cu_index with
    | Just (parents,die) -> Just (cu, parents,die)
    | Nothing -> Nothing
  end

let find_die_by_offset_in_all offset d : maybe cupdie =
  find_maybe
    (fun cu -> find_die_by_offset_in_cu offset cu)
    d.d_compilation_units

val find_dies_in_die : (die->bool) -> compilation_unit -> list die -> die -> list cupdie
let rec find_dies_in_die (p:die->bool) (cu:compilation_unit) (parents: list die) (d: die) =
  let ds = List.concatMap (find_dies_in_die p cu (d::parents)) d.die_children in
  if p d then (cu,parents,d)::ds else ds

let find_dies (p:die->bool) (d: dwarf) : list cupdie =
  List.concatMap
    (fun cu -> find_dies_in_die p cu [] cu.cu_die)
    d.d_compilation_units


(** convert attribute values to usable Lem types *)


let string_of_string_attribute_value str av : string =
  match av with
  | AV_string bs -> string_of_byte_sequence bs
  | AV_strp n -> pp_debug_str_entry str n
  | _ -> "find_string_attribute_value_of_die AV not understood"
  end

let maybe_natural_of_constant_attribute_value die1 c av : maybe natural = 
  match av with
  | AV_constantN n bs -> Just n
  | AV_constant_ULEB128 n -> Just n
  | AV_block n bs -> Just (natural_of_bytes c.endianness bs)
  | _ -> Nothing
  end

let natural_of_constant_attribute_value die1 c av : natural =
  match maybe_natural_of_constant_attribute_value die1 c av with
  | Just n -> n 
  | Nothing -> Assert_extra.failwith ("natural_of_constant_attribute_value fail at " ^ (pp_pos die1.die_offset ^ (" with av= " ^ pp_attribute_value_plain av)))
  end

let integer_of_constant_attribute_value c av : integer =
  match av with
  | AV_constantN n bs -> integerFromNatural n
  | AV_constant_ULEB128 n -> integerFromNatural n
  | AV_constant_SLEB128 n -> n
  | AV_block n bs -> integerFromNatural (natural_of_bytes c.endianness bs)
  | _ -> Assert_extra.failwith ("integer_of_constant_attribute_value fail")
  end

let bool_of_flag_attribute_value av : bool =
  match av with
  | AV_flag b -> b
  | _ -> Assert_extra.failwith ("bool_of_maybe_flag_attribute_value fail")
  end

let reference_of_reference_attribute_value c d cu str av : maybe (compilation_unit * (list die) * die) =
  match av with
  (* "offset from the first byte of the compilation header for the compilation unit containing the reference" *)
  | AV_ref n ->
     let n' = n+cu.cu_header.cuh_offset in
     match find_die_by_offset_in_all n' d (*cu.cu_die*) with
     | Just (cu',parents',die') -> Just (cu',parents',die')
     | Nothing -> Nothing (* Fail ("find_reference_attribute_of_die AV_ref failed (cuh="^pphex cu.cu_header.cuh_offset ^" n'="^pphex n'^")"^"\n"^ppd())*)
     end
   (* offset in .debug_info *)
  | AV_ref_addr n ->
     match find_die_by_offset_in_all n d with
     | Just (cu',parents',die') -> Just (cu',parents',die')
     | Nothing -> Nothing (*Fail ("find_reference_attribute_of_die AV_ref_addr failed\n"^ppd())*)
     end
  | _ ->
     Nothing (*Fail ("reference_of_reference_attribute AV ("^pp_attribute_value c cu.cu_header str (attribute_encode an) av^") not supported\n"^ppd() )*)
      (* TODO: handle the AV_ref_sig8 case for type signature references *)
  end

(** attribute find *)   
  
let find_attribute_value (an: string) (die:die) : maybe attribute_value =
  let at = attribute_encode an in
  let ats = List.zip
      die.die_abbreviation_declaration.ad_attribute_specifications
      die.die_attribute_values in
  myfindmaybe
    (fun  (((at': natural), (af: natural)), ((pos: natural),(av:attribute_value))) ->
      if at' = at then Just av else Nothing)
    ats

  
let find_string_attribute_value_of_die (an: string) str (die:die) : maybe string =  
  match find_attribute_value an die with
  | Just av ->
     let s = string_of_string_attribute_value str av in
     Just s
  | Nothing -> 
      Nothing
  end 

let find_natural_attribute_value_of_die c (an: string) (die:die) : maybe natural =  
  match find_attribute_value an die with
  | Just av ->
     let n = natural_of_constant_attribute_value die c av in
     Just n
  | Nothing -> 
      Nothing
  end 

let find_integer_attribute_value_of_die c (an: string) (die:die) : maybe integer =  
  match find_attribute_value an die with
  | Just av ->
     let n = integer_of_constant_attribute_value c av in
     Just n
  | Nothing -> 
      Nothing
  end 

let find_flag_attribute_value_of_die (an: string) (die:die) : maybe bool =  
  Maybe.map bool_of_flag_attribute_value (find_attribute_value an die)


let find_flag_attribute_value_of_die_default_false (an: string) (die:die) : bool =  
  match find_flag_attribute_value_of_die an die with
  | Just b -> b
  | Nothing -> false
  end
   
  
  
let find_name_of_die str die : maybe string =
  find_string_attribute_value_of_die "DW_AT_name" str die



  
let find_reference_attribute_of_die c d cu str an die : maybe (compilation_unit * (list die) * die) =
  let ppd () = pp_pos die.die_offset (*pp_die c cuh str true 0 false die ^ "\n"*) in
  match find_attribute_value an die with
  | Nothing ->
     Nothing (*Fail ("find_reference_attribute_of_die found no " ^ an ^ "\n" ^ ppd())*)
  | Just av ->
     reference_of_reference_attribute_value c d cu str av
  end  

let find_DW_AT_type_of_die c d cu str die : maybe (compilation_unit * (list die) * die) =
  find_reference_attribute_of_die c d cu str "DW_AT_type" die

(* look up "an" in die. If not found, see if die has an abstract origin, and if so, look up "an" in that. Return the relevant cu, too *)
let find_attribute_value_using_abstract_origin c d cu str an die : maybe (compilation_unit * attribute_value) = 
  match find_attribute_value an die with
  | Just av -> Just (cu,av)
  | Nothing ->
     match find_reference_attribute_of_die c d cu str "DW_AT_abstract_origin" die with
     | Nothing ->
        Nothing (*s ^ " and no DW_AT_abstract_origin"*)
     | Just (cu',parents',die') -> 
        match find_attribute_value an die' with
        | Just av -> Just (cu',av)
        | Nothing -> Nothing
        end
     end
  end

let find_name_of_die_using_abstract_origin c d cu str die : maybe string = 
  match find_attribute_value_using_abstract_origin c d cu str "DW_AT_name" die with
  | Nothing -> Nothing
  | Just (cu',av) -> Just (string_of_string_attribute_value str av)
  end

(* TODO: not sure how DW_AT_specification should interact with abstract origins *)   
let find_name_of_die_using_abstract_origin_and_spec c d cu str die mcupdie_spec : maybe string = 
  match find_name_of_die_using_abstract_origin c d cu str die with
  | Just name -> Just name
  | Nothing ->
     match mcupdie_spec with
     | Just ((cu_spec,parents_spec,die_spec) as cupdie_spec) -> 
        find_name_of_die_using_abstract_origin c d cu_spec str die_spec
     | Nothing ->
        Nothing
    end
end
   
let find_reference_attribute_using_abstract_origin c d cu str an die : maybe (compilation_unit * (list die) * die) = 
  match find_attribute_value_using_abstract_origin c d cu str an die with
  | Nothing -> Nothing
  | Just (cu',av) ->
     reference_of_reference_attribute_value c d cu' str av     
  end

let find_DW_AT_type_of_die_using_abstract_origin c d cu str die : maybe (compilation_unit * (list die) * die) =
  find_reference_attribute_using_abstract_origin c d cu str "DW_AT_type" die

let find_flag_attribute_value_of_die_using_abstract_origin d (an: string) ((cu,parents,die):cupdie) : maybe bool =  
  let c = p_context_of_d d in
  match find_attribute_value_using_abstract_origin c d cu d.d_str an die with
  | Nothing -> Nothing
  | Just (cu',av) ->
     Just (bool_of_flag_attribute_value av)
  end
  

(** compilation unit header: pp and parsing *)

let pp_dwarf_format df = match df with Dwarf32 -> "(32-bit)" | Dwarf64 -> "(64-bit)" end

let pp_unit_header (s:string) (x:compilation_unit_header) : string =
    "**" ^ s ^ " Unit @ offset " ^ pphex x.cuh_offset ^ "\n"
  ^ "  " ^ s ^ " Unit @ offset " ^ pphex x.cuh_offset ^ ":\n"
  ^ "   Length:        " ^ pphex x.cuh_unit_length ^ " " ^ pp_dwarf_format x.cuh_dwarf_format ^ "\n"
  ^ "   Version:       " ^ show x.cuh_version ^ "\n"
  ^ "   Abbrev Offset: " ^ pphex x.cuh_debug_abbrev_offset ^ "\n"
  ^ "   Pointer Size:  " ^ show x.cuh_address_size ^ "\n"

let pp_compilation_unit_header (x:compilation_unit_header) : string =
  pp_unit_header "Compilation" x

let parse_unit_length c : parser (dwarf_format * natural) =
    fun (pc: parse_context) ->
      pr_bind (parse_uint32 c pc) (fun x pc' ->
        if x < natural_of_hex "0xfffffff0" then PR_success (Dwarf32,x) pc'
        else if x <> natural_of_hex "0xffffffff" then PR_fail "bad unit_length" pc
        else
          pr_bind (parse_uint64 c pc') (fun x' pc'' ->
            PR_success (Dwarf64, x') pc'))


let parse_compilation_unit_header c : parser compilation_unit_header =
    pr_post_map
      (pr_with_pos
         (parse_dependent_pair
            (parse_unit_length c)
            (fun (df,ul) ->
              parse_triple
                (parse_uint16 c) (* version *)
                (parse_uintDwarfN c df) (* debug abbrev offset *)
                (parse_uint8) (* address_size *))))
      (fun (offset,((df,ul), (v, (dao, as')))) ->
        (*let _ = my_debug4 ("dao " ^ pphex dao) in *)
        <|
        cuh_offset = offset;
        cuh_dwarf_format = df;
        cuh_unit_length = ul;
        cuh_version = v;
        cuh_debug_abbrev_offset = dao;
        cuh_address_size = as';
      |>)


(** type unit header: pp and parsing *)

(* the test binaries don't have a .debug_types section, so this isn't tested *)

let pp_type_unit_header (x:type_unit_header) : string =
  pp_unit_header "Type" x.tuh_cuh
  ^ "   Type Signature:  " ^ pphex x.tuh_type_signature ^ "\n"
  ^ "   Type Offset:  " ^ pphex x.tuh_type_offset ^ "\n"


let parse_type_unit_header c : parser type_unit_header =
    pr_post_map
      (parse_dependent_pair
         (parse_compilation_unit_header c)
         (fun cuh ->
           parse_pair
             (parse_uint64 c) (* type signature *)
             (parse_uintDwarfN c cuh.cuh_dwarf_format) (* type offset *) ))
      (fun (cuh, (ts, to')) ->
        <|
        tuh_cuh = cuh;
        tuh_type_signature = ts;
        tuh_type_offset = to';
      |>)


(** debugging information entries: pp and parsing *)

(* example pp from readelf
 <2><51>: Abbrev Number: 3 (DW_TAG_variable)
    <52>   DW_AT_name        : x
    <54>   DW_AT_decl_file   : 1
    <55>   DW_AT_decl_line   : 2
    <56>   DW_AT_type        : <0x6a>
    <5a>   DW_AT_location    : 2 byte block: 91 6c 	(DW_OP_fbreg: -20)
*)



  

  
               
(** debugging information entries: pp and parsing *)
               
let indent_level (indent: bool) (level: natural) =
  if indent then
    (toString (replicate (3 * level) #' '))
  else
    " "
let indent_level_plus_one indent level =
  if indent then
    indent_level indent (level+1)
  else
    " "^"   "
      
let pp_die_attribute c (cuh:compilation_unit_header) (str : byte_sequence) (indent:bool) (level: natural) (((at: natural), (af: natural)), ((pos: natural),(av:attribute_value))) : string =
  indent_level_plus_one indent level ^ pp_pos pos  ^ "   "
  ^ right_space_padded_to 18 (pp_attribute_encoding at) ^ ": "
  ^
    if indent then
      "(" ^ pp_attribute_form_encoding af ^ ") "
      ^ pp_attribute_value c cuh str at av
      ^ "\n"
    else
      pp_attribute_value_like_objdump c cuh str at av
      ^ "\n"
          
val pp_die : p_context -> compilation_unit_header -> byte_sequence -> bool -> natural -> bool -> die -> string
let rec pp_die c cuh str indent level (pp_children:bool) die =
  indent_level indent level ^ "<" ^ show level ^ ">"
  ^ pp_pos die.die_offset
  ^ ": Abbrev Number: " ^ show die.die_abbreviation_code
  ^ " (" ^ pp_tag_encoding die.die_abbreviation_declaration.ad_tag ^")\n"
  ^
    let ats = List.zip
        die.die_abbreviation_declaration.ad_attribute_specifications
        die.die_attribute_values in
    (String.concat "" (List.map (pp_die_attribute c cuh str indent level) ats))
    ^
      if pp_children then String.concat "" (List.map (pp_die c cuh str indent (level +1) pp_children) die.die_children) else ""

val pp_die_abbrev : p_context -> compilation_unit_header -> byte_sequence -> natural -> bool -> (list die) -> die -> string
let rec pp_die_abbrev c cuh str level (pp_children:bool) parents die =
  indent_level true level
  ^ pp_tag_encoding die.die_abbreviation_declaration.ad_tag
  ^ " (" ^ pp_pos die.die_offset ^ ") "
(*  ^ ": Abbrev Number: " ^ show die.die_abbreviation_code *)
  ^
    (match find_name_of_die str die with Just s -> s | Nothing -> "-" end)
    ^ "   :  " ^ String.concat " : " (List.map (fun die' ->  pp_tag_encoding die'.die_abbreviation_declaration.ad_tag) parents)
    ^ "\n"
    ^ (*(String.concat "" (List.map (pp_die_abbrev_attribute c cuh str) ats))*)

      if pp_children then String.concat "" (List.map (pp_die_abbrev c cuh str (level +1) pp_children (die::parents)) die.die_children) else ""


(* condensed pp for variables *)
val pp_die_abbrev_var : p_context -> dwarf -> compilation_unit -> byte_sequence -> bool -> (list die) -> die -> (string (*name*) * string (*offset*) * string (*kind*))
let rec pp_die_abbrev_var c d cu str (pp_children:bool) parents die =
  (*   (indent_level true level*)
  (*  ^ pp_tag_encoding die.die_abbreviation_declaration.ad_tag*)
(*  ^ ": Abbrev Number: " ^ show die.die_abbreviation_code *)
  ((match find_name_of_die_using_abstract_origin c d cu str die with
    | Just s -> s
    | Nothing -> "?"
    end)
   ,
   pp_pos die.die_offset,
   (if die.die_abbreviation_declaration.ad_tag = tag_encode "DW_TAG_variable" then  "var"
    else if die.die_abbreviation_declaration.ad_tag = tag_encode "DW_TAG_formal_parameter" then "param"
    else "other")
  )

(* condensed pp for variable parents *)
val pp_die_abbrev_var_parent : p_context -> dwarf -> compilation_unit -> byte_sequence -> die -> string
let pp_die_abbrev_var_parent c d cu str die =
  (*   (indent_level true level*)
  (*  ^ pp_tag_encoding die.die_abbreviation_declaration.ad_tag*)
(*  ^ ": Abbrev Number: " ^ show die.die_abbreviation_code *)
  let name = (match find_name_of_die_using_abstract_origin c d cu str die with Just s -> s | Nothing -> "" end) in
  let offset = pp_pos die.die_offset in 
   (if die.die_abbreviation_declaration.ad_tag = tag_encode "DW_TAG_compile_unit" then  name
    else if die.die_abbreviation_declaration.ad_tag = tag_encode "DW_TAG_subprogram" then name (*"subprogram"*)
    else if die.die_abbreviation_declaration.ad_tag = tag_encode "DW_TAG_inlined_subroutine" then name ^ "(inlined)"
    else if die.die_abbreviation_declaration.ad_tag = tag_encode "DW_TAG_lexical_block" then "block"
    else name ^ "(" ^ pp_tag_encoding die.die_abbreviation_declaration.ad_tag ^ ")")
  
  

val pp_die_abbrev_var_parents : p_context -> dwarf -> compilation_unit -> byte_sequence -> list die -> string
let pp_die_abbrev_var_parents c d cu str parents =
    String.concat ":" (List.map (fun die -> pp_die_abbrev_var_parent c d cu str die) parents)


  
  (*    ^ "   :  " ^ String.concat " : " (List.map (fun die' ->  pp_tag_encoding die'.die_abbreviation_declaration.ad_tag) parents)*)
    (* ^ "\n"*)
(*    ^ (*(String.concat "" (List.map (pp_die_abbrev_attribute c cuh str) ats))*)*)

(*      if pp_children then String.concat "" (List.map (pp_die_abbrev c cuh str (level +1) pp_children (die::parents)) die.die_children) else ""*)
    


val parse_die : p_context -> byte_sequence -> compilation_unit_header -> (natural->abbreviation_declaration) -> parser (maybe die)
let rec parse_die c str cuh find_abbreviation_declaration =
  fun (pc: parse_context) ->
    (* let _ = my_debug3 ("parse_die called at " ^ pp_parse_context pc ^ "\n") in *)
    pr_bind (parse_ULEB128 pc) (fun abbreviation_code pc' ->
      if abbreviation_code = 0 then PR_success Nothing pc'
      else
        (* let _ = my_debug3 ("parse_die abbreviation code "^pphex abbreviation_code ^"\n") in *)
        let ad = find_abbreviation_declaration abbreviation_code in
        let attribute_value_parsers = List.map (fun (at,af) -> pr_with_pos (parser_of_attribute_form c cuh af)) ad.ad_attribute_specifications in
        pr_bind (parse_parser_list attribute_value_parsers pc') (fun avs pc'' ->

(*
          let die_header =
            <|
            die_offset = pc.pc_offset;
            die_abbreviation_code = abbreviation_code;
            die_abbreviation_declaration = ad;
            die_attribute_values = avs;
            die_children = [];
          |> in let _ = my_debug3 ("die_header " ^ pp_die cuh str true 999 die_header) in
  *)
            pr_bind
              (if ad.ad_has_children then parse_list (parse_die c str cuh find_abbreviation_declaration) pc'' else pr_return [] pc'')
              (fun dies pc''' ->
                PR_success (Just ( let die =
                  <|
                  die_offset = pc.pc_offset;
                  die_abbreviation_code = abbreviation_code;
                  die_abbreviation_declaration = ad;
                  die_attribute_values = avs;
                  die_children = dies;
                  |> in
                  let _ = my_debug3 ("die entire " ^ pp_die c cuh str true 0 false die) in
                  die)) pc''')))

let has_attribute (an: string) (die: die) : bool =
  List.elem
    (attribute_encode an)
    (List.map Tuple.fst die.die_abbreviation_declaration.ad_attribute_specifications)


(** compilation units: pp and parsing *)

let pp_compilation_unit c (indent:bool) (debug_str_section_body: byte_sequence) cu =
  ""
(*  "*** compilation unit header               ***\n"*)
  ^ pp_compilation_unit_header cu.cu_header
  ^ "\n*** compilation unit abbreviation table\n"
  ^ pp_abbreviations_table cu.cu_abbreviations_table
  ^ "\n"
  ^ "*** compilation unit die tree\n"
  ^ pp_die c cu.cu_header debug_str_section_body indent 0 true cu.cu_die
  ^ "\n"

let pp_compilation_units c (indent:bool) debug_string_section_body (compilation_units: list compilation_unit) : string =
  String.concat "" (List.map (pp_compilation_unit c indent debug_string_section_body) compilation_units)


let pp_compilation_unit_abbrev c (debug_str_section_body: byte_sequence) cu =
  pp_compilation_unit_header cu.cu_header
(*  ^ pp_abbreviations_table cu.cu_abbreviations_table*)
  ^ pp_die_abbrev c cu.cu_header debug_str_section_body 0 true [] cu.cu_die

let pp_compilation_units_abbrev c debug_string_section_body (compilation_units: list compilation_unit) : string =
  String.concat "" (List.map (pp_compilation_unit_abbrev c debug_string_section_body) compilation_units)

val add_die_to_index : die_index -> list die -> die -> die_index
let rec add_die_to_index acc parents die =
  let nacc : die_index = Map.insert die.die_offset (parents,die) acc in
  List.foldl (fun acc ndie -> add_die_to_index acc (die::parents) ndie) nacc die.die_children

let parse_compilation_unit c (debug_str_section_body: byte_sequence) (debug_abbrev_section_body: byte_sequence) : parser (maybe compilation_unit) =
    fun (pc:parse_context) ->

      if Byte_sequence.length pc.pc_bytes = 0 then PR_success Nothing pc else

      let (cuh, pc') =

        match parse_compilation_unit_header c pc with
        | PR_fail s pc' -> Assert_extra.failwith ("parse_cuh_header fail: " ^ pp_parse_fail s pc')
        | PR_success cuh pc' -> (cuh,pc')
        end in

let _ = my_debug4 (pp_compilation_unit_header cuh) in

      if cuh.cuh_unit_length = 0 then PR_success Nothing pc' else
      
      let pc_abbrev = <|pc_bytes = match dropbytes cuh.cuh_debug_abbrev_offset debug_abbrev_section_body with Success bs -> bs | Fail _ -> Assert_extra.failwith "mydrop of debug_abbrev" end; pc_offset = cuh.cuh_debug_abbrev_offset  |> in

      (* todo: this is reparsing the abbreviations table for each cu *)
      let abbreviations_table =
        match parse_abbreviations_table c pc_abbrev with
        | PR_fail s pc_abbrev' -> Assert_extra.failwith ("parse_abbrevations_table fail: " ^ pp_parse_fail s pc_abbrev')
        | PR_success at pc_abbrev' -> <| at_offset=pc_abbrev.pc_offset; at_table= at|>
        end in

      (* let _ = my_debug4 (pp_abbreviations_table abbreviations_table) in *)

      let find_abbreviation_declaration (ac:natural) : abbreviation_declaration =
        (* let _ = my_debug4 ("find_abbreviation_declaration "^pphex ac) in *)
        myfindNonPure (fun ad -> ad.ad_abbreviation_code = ac) abbreviations_table.at_table  in

      (* let _ = my_debug3 (pp_abbreviations_table abbreviations_table) in *)

      match parse_die c debug_str_section_body cuh find_abbreviation_declaration pc' with
      | PR_fail s pc'' -> Assert_extra.failwith ("parse_die fail: " ^ pp_parse_fail s pc'')
      | PR_success (Nothing) pc'' -> Assert_extra.failwith ("parse_die returned Nothing: " ^ pp_parse_context pc'')
      | PR_success (Just die) pc'' ->
          let cu =
            <|
            cu_header = cuh;
            cu_abbreviations_table = abbreviations_table;
            cu_die = die;
            cu_index = add_die_to_index Map.empty [] die
          |> in
          PR_success (Just cu) pc''
      end

let parse_compilation_units c (debug_str_section_body: byte_sequence) (debug_abbrev_section_body: byte_sequence): parser (list compilation_unit)
    =
  parse_list (parse_compilation_unit c debug_str_section_body debug_abbrev_section_body)


(** type units: pp and parsing *)

let pp_type_unit c (debug_str_section_body: byte_sequence) tu =
  pp_type_unit_header tu.tu_header
  ^ pp_abbreviations_table tu.tu_abbreviations_table
  ^ pp_die c tu.tu_header.tuh_cuh debug_str_section_body true 0 true tu.tu_die

let pp_type_units c debug_string_section_body (type_units: list type_unit) : string =
  String.concat "" (List.map (pp_type_unit c debug_string_section_body) type_units)


let parse_type_unit c (debug_str_section_body: byte_sequence) (debug_abbrev_section_body: byte_sequence) : parser (maybe type_unit) =
    fun (pc:parse_context) ->

      if Byte_sequence.length pc.pc_bytes = 0 then PR_success Nothing pc else

      let (tuh, pc') =
        match parse_type_unit_header c pc with
        | PR_fail s pc' -> Assert_extra.failwith ("parse_tuh_header fail: " ^ pp_parse_fail s pc')
        | PR_success tuh pc' -> (tuh,pc')
        end in

      (* let _ = my_debug4 (pp_type_unit_header tuh) in *)

      let pc_abbrev = let n = tuh.tuh_cuh.cuh_debug_abbrev_offset in <|pc_bytes = match dropbytes n debug_abbrev_section_body with Success bs -> bs | Fail _ -> Assert_extra.failwith "mydrop of debug_abbrev" end; pc_offset = n  |> in

      let abbreviations_table =
        match parse_abbreviations_table c pc_abbrev with
        | PR_fail s pc_abbrev' -> Assert_extra.failwith ("parse_abbrevations_table fail: " ^ pp_parse_fail s pc_abbrev')
        | PR_success at pc_abbrev' -> <| at_offset=pc_abbrev.pc_offset; at_table= at|>
        end in

      (* let _ = my_debug4 (pp_abbreviations_table abbreviations_table) in *)

      let find_abbreviation_declaration (ac:natural) : abbreviation_declaration =
        (* let _ = my_debug4 ("find_abbreviation_declaration "^pphex ac) in *)
        myfindNonPure (fun ad -> ad.ad_abbreviation_code = ac) abbreviations_table.at_table  in

      (* let _ = my_debug3 (pp_abbreviations_table abbreviations_table) in *)

      match parse_die c debug_str_section_body tuh.tuh_cuh find_abbreviation_declaration pc' with
      | PR_fail s pc'' -> Assert_extra.failwith ("parse_die fail: " ^ pp_parse_fail s pc'')
      | PR_success (Nothing) pc'' -> Assert_extra.failwith ("parse_die returned Nothing: " ^ pp_parse_context pc'')
      | PR_success (Just die) pc'' ->
          let tu =
            <|
            tu_header = tuh;
            tu_abbreviations_table = abbreviations_table;
            tu_die = die;
          |> in
          PR_success (Just tu) pc''
      end

let parse_type_units c (debug_str_section_body: byte_sequence) (debug_abbrev_section_body: byte_sequence): parser (list type_unit)
      =
    parse_list (parse_type_unit c debug_str_section_body debug_abbrev_section_body)

(** location lists, pp and parsing *)

(* readelf example
Contents of the .debug_loc section:

    Offset   Begin    End      Expression
    00000000 0000000000400168 0000000000400174 (DW_OP_reg0 (r0))
    00000000 0000000000400174 0000000000400184 (DW_OP_GNU_entry_value: (DW_OP_reg0 (r0)); DW_OP_stack_value)
    00000000 <End of list>
    00000039 000000000040017c 0000000000400180 (DW_OP_lit1; DW_OP_stack_value)
*)

  

      
let pp_location_list_entry c (cuh:compilation_unit_header) (offset:natural) (x:location_list_entry) : string =
  "    " ^ pphex offset
  ^ " " ^ pphex x.lle_beginning_address_offset
  ^ " " ^ pphex x.lle_ending_address_offset
  ^ " (" ^ parse_and_pp_operations c cuh x.lle_single_location_description ^")"
  ^ "\n"

let pp_base_address_selection_entry c (cuh:compilation_unit_header) (offset:natural) (x:base_address_selection_entry) : string =
  "    " ^ pphex offset
  ^ " " ^ pphex x.base_address
  ^ "\n"

let pp_location_list_item c (cuh: compilation_unit_header) (offset: natural) (x:location_list_item) =
  match x with
  | LLI_lle lle -> pp_location_list_entry c cuh offset lle
  | LLI_base base -> pp_base_address_selection_entry c cuh offset base
  end

let pp_location_list c (cuh: compilation_unit_header) ((offset:natural), (llis: list location_list_item)) =
  String.concat "" (List.map (pp_location_list_item c cuh offset) llis)
(*  ^ "    " ^ pphex offset  ^ " <End of list>\n"*)

let pp_loc c (cuh: compilation_unit_header) (lls: list location_list) =
  "    Offset   Begin    End      Expression\n"
  ^  String.concat "" (List.map (pp_location_list c cuh) lls)

(* Note that this is just pp'ing the raw location list data - Section
3.1.1 says: The applicable base address of a location list entry is
determined by the closest preceding base address selection entry in
the same location list. If there is no such selection entry, then the
applicable base address defaults to the base address of the
compilation unit.  That is handled by the interpret_location_list below *)



let parse_location_list_item c (cuh: compilation_unit_header) : parser (maybe location_list_item) =
    fun (pc:parse_context) ->
      pr_bind
        (parse_pair
           (parse_uint_address_size c cuh.cuh_address_size)
           (parse_uint_address_size c cuh.cuh_address_size)
           pc)
        (fun ((a1: natural),(a2:natural)) pc' ->
          (* let _ = my_debug4 ("offset="^pphex pc.pc_offset ^ " begin=" ^ pphex a1 ^ " end=" ^ pphex a2) in *)
          if a1=0 && a2=0 then
            PR_success Nothing pc'
          else if a1 = max_address cuh.cuh_address_size then
            let x = LLI_base <| (*base_offset=pc.pc_offset;*) base_address=a1 |> in
            PR_success (Just x (*(pc.pc_offset, x)*)) pc'
          else
            pr_bind (parse_uint16 c pc') (fun n pc'' ->
              pr_post_map1
                (parse_n_bytes n pc'')
                (fun bs ->
                  let x =
                    LLI_lle <|
                    (*lle_offset = pc.pc_offset;*)
                    lle_beginning_address_offset = a1;
                    lle_ending_address_offset = a2;
                    lle_single_location_description = bs;
                  |> in
                  Just x (*(pc.pc_offset, x)*))
                                        )
        )

let parse_location_list c cuh : parser (maybe location_list) =
    fun (pc: parse_context) ->
      if Byte_sequence.length pc.pc_bytes = 0 then
        PR_success Nothing pc
      else
        pr_post_map1
          (parse_list (parse_location_list_item c cuh) pc)
          (fun llis -> (Just (pc.pc_offset, llis)))

let parse_location_list_list c cuh : parser location_list_list =
    parse_list (parse_location_list c cuh)

let find_location_list dloc n : location_list =
  myfindNonPure (fun (n',_)-> n'=n) dloc
  (* fails if location list not found *)

(* interpretation of a location list applies the base_address and LLI_base offsets to give a list indexed by concrete address ranges *)

let rec interpret_location_list (base_address: natural) (llis: list location_list_item) : list (natural * natural * single_location_description) =
  match llis with
  | [] -> []
  | LLI_base base::llis' -> interpret_location_list base.base_address llis'
  | LLI_lle lle :: llis' -> (base_address+lle.lle_beginning_address_offset, base_address+lle.lle_ending_address_offset, lle.lle_single_location_description) :: interpret_location_list base_address llis'
  end


(** range lists, pp and parsing *)

(* example output from:  aarch64-linux-gnu-objdump --dwarf=Ranges 

Contents of the .debug_ranges section:

    Offset   Begin    End
    00000000 00000000004000fc 0000000000400114 
    00000000 000000000040011c 0000000000400128 
    00000000 <End of list>
...
    00000380 0000000000400598 000000000040059c 
    00000380 00000000004005a0 00000000004005a4 
    00000380 00000000004005b4 00000000004005b8 
    00000380 00000000004005bc 00000000004005bc (start == end)
    00000380 00000000004005c0 00000000004005c4 
    00000380 <End of list>

*)

let pp_range_list_entry c (cuh:compilation_unit_header) (offset:natural) (x:range_list_entry) : string =
  "    " ^ pphex offset
  ^ " " ^ pphex x.rle_beginning_address_offset
  ^ " " ^ pphex x.rle_ending_address_offset
  ^ (if x.rle_beginning_address_offset = x.rle_ending_address_offset then " (start == end)" else "")
  ^ "\n"

let pp_range_list_item c (cuh: compilation_unit_header) (offset: natural) (x:range_list_item) =
  match x with
  | RLI_rle rle -> pp_range_list_entry c cuh offset rle
  | RLI_base base -> pp_base_address_selection_entry c cuh offset base
  end

let pp_range_list c (cuh: compilation_unit_header) ((offset:natural), (rlis: list range_list_item)) =
  String.concat "" (List.map (pp_range_list_item c cuh offset) rlis)
  ^ "    " ^ pphex offset  ^ " <End of list>\n"

let pp_ranges c (cuh: compilation_unit_header) (rls: list range_list) =
  "    Offset   Begin    End\n"
  ^  String.concat "" (List.map (pp_range_list c cuh) rls)

(* Note that this is just pp'ing the raw range list data - see also
the interpret_range_list below *)


let parse_range_list_item c (cuh: compilation_unit_header) : parser (maybe range_list_item) =
    fun (pc:parse_context) ->
      pr_bind
        (parse_pair
           (parse_uint_address_size c cuh.cuh_address_size)
           (parse_uint_address_size c cuh.cuh_address_size)
           pc)
        (fun ((a1: natural),(a2:natural)) pc' ->
          (* let _ = my_debug4 ("offset="^pphex pc.pc_offset ^ " begin=" ^ pphex a1 ^ " end=" ^ pphex a2) in *)
          if a1=0 && a2=0 then
            PR_success Nothing pc'
          else if a1 = max_address cuh.cuh_address_size then
            let x = RLI_base <| base_address=a2 |> in
            PR_success (Just x) pc'
          else
            let x =
              RLI_rle <|
                    rle_beginning_address_offset = a1;
                    rle_ending_address_offset = a2;
                  |> in
                  PR_success (Just x (*(pc.pc_offset, x)*)) pc'
        )

(* compiler output includes DW_AT_ranges attributes that point to proper suffixes of range lists. We support that by explicitly including each suffix - though one could be more efficient *)
    
let rec expand_range_list_suffixes cuh (offset,(rlis: list range_list_item)) : list range_list =
  match rlis with
  | [] -> []
  | [rli] -> [(offset,rlis)]
  | rli::rlis' -> (offset,rlis) :: expand_range_list_suffixes cuh ((offset + 2*cuh.cuh_address_size),rlis')
  end  

let parse_range_list c cuh : parser (maybe (list range_list)) =
    fun (pc: parse_context) ->
      if Byte_sequence.length pc.pc_bytes = 0 then
        PR_success Nothing pc
      else
        pr_post_map1
          (parse_list (parse_range_list_item c cuh) pc)
          (fun rlis -> (Just (expand_range_list_suffixes cuh (pc.pc_offset, rlis))))

let parse_range_list_list c cuh : parser range_list_list =
    pr_map2 List.concat (parse_list (parse_range_list c cuh))

let find_range_list dranges n : maybe range_list =
  List.find (fun (n',_)-> n'=n) dranges
  (* fails if range list not found *)

(* interpretation of a range list applies the base_address and RLI_base offsets to give a list of concrete address ranges *)

let rec interpret_range_list (base_address: natural) (rlis: list range_list_item) : list (natural * natural) =
  match rlis with
  | [] -> []
  | RLI_base base::rlis' -> interpret_range_list base.base_address rlis'
  | RLI_rle rle :: rlis' -> (base_address+rle.rle_beginning_address_offset, base_address+rle.rle_ending_address_offset) :: interpret_range_list base_address rlis'
  end

(** frame information, pp and parsing *)

(* readelf example

Contents of the .debug_frame section:

00000000 0000000c ffffffff CIE
  Version:               1
  Augmentation:          ""
  Code alignment factor: 4
  Data alignment factor: -8
  Return address column: 65

  DW_CFA_def_cfa: r1 ofs 0

00000010 00000024 00000000 FDE cie=00000000 pc=100000b0..10000120
  DW_CFA_advance_loc: 8 to 100000b8
  DW_CFA_def_cfa_offset: 80
  DW_CFA_offset: r31 at cfa-8
  DW_CFA_advance_loc: 4 to 100000bc
  DW_CFA_def_cfa_register: r31
  DW_CFA_advance_loc: 80 to 1000010c
  DW_CFA_def_cfa: r1 ofs 0
  DW_CFA_nop
  DW_CFA_nop
  DW_CFA_nop
  DW_CFA_nop

00000038 00000024 00000000 FDE cie=00000000 pc=10000120..100001a4
  DW_CFA_advance_loc: 16 to 10000130
  DW_CFA_def_cfa_offset: 144
  DW_CFA_offset_extended_sf: r65 at cfa+16
  DW_CFA_offset: r31 at cfa-8
  DW_CFA_advance_loc: 4 to 10000134
  DW_CFA_def_cfa_register: r31
  DW_CFA_advance_loc: 84 to 10000188
  DW_CFA_def_cfa: r1 ofs 0
*)



let pp_cfa_address a = pphex a
let pp_cfa_block b = ppbytes b
let pp_cfa_delta d = pphex d
(*let pp_cfa_offset n = pphex n
let pp_cfa_register r = show r*)
let pp_cfa_sfoffset i = show i

let pp_cfa_register r = "r"^show r (*TODO: arch-specific register names *)

let pp_cfa_offset (i:integer) = if i=0 then "" else if i<0 then show i else "+" ^ show i

let pp_cfa_rule (cr:cfa_rule) : string =
  match cr with
  | CR_undefined -> "u"
  | CR_register r i -> pp_cfa_register r ^ pp_cfa_offset i
  | CR_expression bs -> "exp"
  end

let pp_register_rule (rr:register_rule) : string =  (*TODO make this more readelf-like *)
  match rr with
  | RR_undefined -> "u"
  | RR_same_value -> "s"
  | RR_offset i -> "c" ^ pp_cfa_offset i
  | RR_val_offset i -> "val(c" ^ pp_cfa_offset i ^ ")"
  | RR_register r -> pp_cfa_register r
  | RR_expression bs -> "exp"
  | RR_val_expression bs -> "val(exp)"
  | RR_architectural -> ""
  end



let pp_call_frame_instruction i =
  match i with
  | DW_CFA_advance_loc d          -> "DW_CFA_advance_loc" ^ " " ^ pp_cfa_delta d
  | DW_CFA_offset r n             -> "DW_CFA_offset" ^ " " ^ pp_cfa_register r ^ " " ^ pp_cfa_offset (integerFromNatural n)
  | DW_CFA_restore r              -> "DW_CFA_restore" ^ " " ^ pp_cfa_register r
  | DW_CFA_nop                    -> "DW_CFA_nop"
  | DW_CFA_set_loc a              -> "DW_CFA_set_loc" ^ " " ^ pp_cfa_address a
  | DW_CFA_advance_loc1 d         -> "DW_CFA_advance_loc1" ^ " " ^ pp_cfa_delta d
  | DW_CFA_advance_loc2 d         -> "DW_CFA_advance_loc2" ^ " " ^ pp_cfa_delta d
  | DW_CFA_advance_loc4 d         -> "DW_CFA_advance_loc4" ^ " " ^ pp_cfa_delta d
  | DW_CFA_offset_extended r n    -> "DW_CFA_offset_extended" ^ " " ^ pp_cfa_register r ^ " " ^ pp_cfa_offset (integerFromNatural n)
  | DW_CFA_restore_extended r     -> "DW_CFA_restore_extended" ^ " " ^ pp_cfa_register r
  | DW_CFA_undefined r            -> "DW_CFA_undefined" ^ " " ^ pp_cfa_register r
  | DW_CFA_same_value r           -> "DW_CFA_same_value" ^ " " ^ pp_cfa_register r
  | DW_CFA_register r1 r2         -> "DW_CFA_register" ^ " " ^ pp_cfa_register r1 ^ " " ^ pp_cfa_register r2
  | DW_CFA_remember_state         -> "DW_CFA_remember_state"
  | DW_CFA_restore_state          -> "DW_CFA_restore_state"
  | DW_CFA_def_cfa r n            -> "DW_CFA_def_cfa" ^ " " ^ pp_cfa_register r ^ " " ^ pp_cfa_offset (integerFromNatural n)
  | DW_CFA_def_cfa_register r     -> "DW_CFA_def_cfa_register" ^ " " ^ pp_cfa_register r
  | DW_CFA_def_cfa_offset n       -> "DW_CFA_def_cfa_offset" ^ " " ^ pp_cfa_offset (integerFromNatural n)
  | DW_CFA_def_cfa_expression b   -> "DW_CFA_def_cfa_expression" ^ " " ^ pp_cfa_block b
  | DW_CFA_expression r b         -> "DW_CFA_expression" ^ " " ^ pp_cfa_register r ^ " " ^ pp_cfa_block b
  | DW_CFA_offset_extended_sf r i -> "DW_CFA_offset_extended_sf" ^ " " ^ pp_cfa_register r ^ " " ^ pp_cfa_sfoffset i
  | DW_CFA_def_cfa_sf r i         -> "DW_CFA_def_cfa_sf" ^ " " ^ pp_cfa_register r ^ " " ^ pp_cfa_sfoffset i
  | DW_CFA_def_cfa_offset_sf i    -> "DW_CFA_def_cfa_offset_sf" ^ " " ^ pp_cfa_sfoffset i
  | DW_CFA_val_offset r n         -> "DW_CFA_val_offset" ^ " " ^ pp_cfa_register r ^ " " ^ pp_cfa_offset (integerFromNatural n)
  | DW_CFA_val_offset_sf r i      -> "DW_CFA_val_offset_sf" ^ pp_cfa_register r ^ " " ^ pp_cfa_sfoffset i
  | DW_CFA_val_expression r b     -> "DW_CFA_val_expression" ^ " " ^ pp_cfa_register r ^ " " ^ pp_cfa_block b
  | DW_CFA_AARCH64_negate_ra_state        -> "DW_CFA_AARCH64_negate_ra_state"
  | DW_CFA_unknown bt             -> "DW_CFA_unknown" ^ " " ^ show bt
  end

let pp_call_frame_instructions is = String.concat "" (List.map (fun i -> "  " ^ pp_call_frame_instruction i ^ "\n") is)


let parser_of_call_frame_argument_type c cuh (cfat: call_frame_argument_type) : parser call_frame_argument_value =
    match cfat with
    | CFAT_address       -> pr_map2 (fun n -> CFAV_address n) (parse_uint_address_size c cuh.cuh_address_size)
    | CFAT_delta1        -> pr_map2 (fun n -> CFAV_delta n) (parse_uint8)
    | CFAT_delta2        -> pr_map2 (fun n -> CFAV_delta n) (parse_uint16 c)
    | CFAT_delta4        -> pr_map2 (fun n -> CFAV_delta n) (parse_uint32 c)
    | CFAT_delta_ULEB128 -> pr_map2 (fun n -> CFAV_delta n) (parse_ULEB128)
    | CFAT_offset        -> pr_map2 (fun n -> CFAV_offset n) (parse_ULEB128)
    | CFAT_sfoffset      -> pr_map2 (fun n -> CFAV_sfoffset n) (parse_SLEB128)
    | CFAT_register      -> pr_map2 (fun n -> CFAV_register n) (parse_ULEB128)
    | CFAT_block ->
      (fun pc -> pr_bind (parse_ULEB128 pc) (fun n pc' ->
        pr_map (fun bs -> CFAV_block bs) (parse_n_bytes n pc')))
    end

let parse_call_frame_instruction c cuh : parser (maybe call_frame_instruction) =
    fun pc ->
      match read_char pc.pc_bytes with
      | Fail _ -> PR_success Nothing pc
      | Success (b,bs') ->
          let pc' = <| pc_bytes = bs'; pc_offset = pc.pc_offset + 1 |> in
          let ch = unsigned_char_of_byte b in
          let high_bits = unsigned_char_land ch (unsigned_char_of_natural 192) in
          let low_bits = natural_of_unsigned_char (unsigned_char_land ch (unsigned_char_of_natural 63)) in
          if high_bits = unsigned_char_of_natural 0 then
            match lookup_abCde_de low_bits call_frame_instruction_encoding with
            | Just ((args: list call_frame_argument_type), result) ->
                let ps = List.map (parser_of_call_frame_argument_type c cuh) args in
                let p =
                  pr_post_map
                    (parse_parser_list ps)
                    result in
                match p pc' with
                | PR_success (Just cfi) pc'' -> PR_success (Just cfi) pc''
                | PR_success (Nothing) pc'' -> Assert_extra.failwith "bad call frame instruction argument 1"
                | PR_fail s pc'' -> Assert_extra.failwith "bad call frame instruction argument 2"
                end
            | Nothing ->
                (*Assert_extra.failwith ("can't parse " ^ show b ^ " as call frame instruction")*)
                PR_success (Just (DW_CFA_unknown b)) pc'
            end
          else
            if high_bits = unsigned_char_of_natural 64 then
              PR_success (Just (DW_CFA_advance_loc low_bits)) pc'
            else if high_bits = unsigned_char_of_natural 192 then
              PR_success (Just (DW_CFA_restore low_bits)) pc'
            else
                let p = parser_of_call_frame_argument_type c cuh CFAT_offset in
                match p pc' with
                | PR_success (CFAV_offset n) pc'' -> PR_success (Just (DW_CFA_offset low_bits n)) pc''
                | PR_success _ pc'' -> Assert_extra.failwith "bad call frame instruction argument 3"
                | PR_fail s pc'' -> Assert_extra.failwith "bad call frame instruction argument 4"
                end
      end

let parse_call_frame_instructions c cuh : parser (list call_frame_instruction) =
    parse_list (parse_call_frame_instruction c cuh)

val parse_and_pp_call_frame_instructions : p_context -> compilation_unit_header -> byte_sequence -> string
let parse_and_pp_call_frame_instructions c cuh bs =
  let pc = <|pc_bytes = bs; pc_offset = 0  |> in
  match parse_call_frame_instructions c cuh pc with
  | PR_fail s pc' -> "parse_call_frame_instructions fail: " ^ pp_parse_fail s pc'
  | PR_success is pc' ->
      pp_call_frame_instructions is
      ^ if Byte_sequence.length pc'.pc_bytes <> 0 then " Warning: extra non-parsed bytes" else ""
  end



let pp_call_frame_instructions' c cuh bs =
  (* ppbytes bs ^ "\n" *)
  parse_and_pp_call_frame_instructions c cuh bs



let pp_cie c cuh cie =
  pphex cie.cie_offset
  ^ " " ^ pphex cie.cie_length
  ^ " " ^ pphex cie.cie_id
  ^ " CIE\n"
  ^ "  Version:                " ^ show cie.cie_version ^ "\n"
  ^ "  Augmentation:           \""^ show (string_of_byte_sequence cie.cie_augmentation) ^ "\"\n"
  ^ "  Code alignment factor: " ^ show cie.cie_code_alignment_factor ^ "\n"
  ^ "  Data alignment factor: " ^ show cie.cie_data_alignment_factor ^ "\n"
  ^ "  Return address column: " ^ show cie.cie_return_address_register ^ "\n"
  ^ "\n"
  ^ ppbytes cie.cie_initial_instructions_bytes ^ "\n"
  ^ pp_call_frame_instructions cie.cie_initial_instructions

(*    cie_address_size: natural;  (* not shown by readelf - must match compilation unit *)*)
(*    cie_segment_size: natural;  (* not shown by readelf *)*)
(* readelf says "Return address column", but the DWARF spec says "Return address register" *)


let pp_fde c cuh fde =
  pphex fde.fde_offset
  ^ " " ^ pphex fde.fde_length
  ^ " " ^ pphex fde.fde_cie_pointer  (* not what this field of readelf output is *)
  ^ " FDE"
  ^ " cie=" ^ pphex fde.fde_cie_pointer (* duplicated?? *)
  ^ " pc=" ^ match fde.fde_initial_location_segment_selector with Nothing -> "" | Just segment_selector -> "("^pphex segment_selector^")" end ^ pphex fde.fde_initial_location_address ^ ".." ^ pphex (fde.fde_initial_location_address + fde.fde_address_range) ^ "\n"
  ^ ppbytes fde.fde_instructions_bytes ^ "\n"
  ^ pp_call_frame_instructions fde.fde_instructions

let pp_frame_info_element c cuh fie =
  match fie with
  | FIE_cie cie -> pp_cie c cuh cie
  | FIE_fde fde -> pp_fde c cuh fde
  end

let pp_frame_info c cuh fi =
  "Contents of the .debug_frame section:\n\n"
  ^ String.concat "\n" (List.map (pp_frame_info_element c cuh) fi)
  ^ "\n"



let rec find_cie fi cie_id =
  match fi with
  | [] -> Assert_extra.failwith "find_cie: cie_id not found"
  | FIE_fde _ :: fi' -> find_cie fi' cie_id
  | FIE_cie cie :: fi' -> if cie_id = cie.cie_offset then cie else find_cie fi' cie_id
  end

let parse_initial_location c cuh mss mas' : parser ((maybe natural) * natural) = (*(segment selector and target address)*)
    (* assume segment selector size is zero unless given explicitly.  Probably we need to do something architecture-specific for earlier dwarf versions?*)
  parse_pair
    (parse_uint_segment_selector_size c (match mss with Just n -> n | Nothing -> 0 end))
    (parse_uint_address_size c (match mas' with Just n -> n | Nothing -> cuh.cuh_address_size end))


let parse_call_frame_instruction_bytes offset' ul =
  fun (pc: parse_context) ->
    parse_n_bytes (ul - (pc.pc_offset - offset')) pc

let parse_frame_info_element c cuh (fi: list frame_info_element) : parser frame_info_element =
  parse_dependent
    (pr_with_pos
       (parse_dependent_pair
          (parse_unit_length c)
          (fun (df,ul) ->
            pr_with_pos
              (parse_uintDwarfN c df) (* CIE_id (cie) or CIE_pointer (fde) *)
          )))
    (fun (offset,((df,ul),(offset',cie_id))) ->
      if (cie_id =
        match df with
        | Dwarf32 -> natural_of_hex "0xffffffff"
        | Dwarf64 -> natural_of_hex "0xffffffffffffffff"
        end)
      then
        (* parse cie *)
        pr_post_map
          (parse_pair
             (parse_dependent_pair
                parse_uint8  (* version *)
                (fun v ->
                  parse_triple
                    parse_string (* augmentation *)
                    (if v=4 || v=46 then pr_post_map parse_uint8 (fun i->Just i) else pr_return Nothing) (* address_size *)
                    (if v=4 || v=46 then pr_post_map parse_uint8 (fun i->Just i) else pr_return Nothing)))  (* segment_size *)
             (parse_quadruple
                parse_ULEB128 (* code_alignment_factor *)
                parse_SLEB128 (* data_alignment_factor *)
                parse_ULEB128 (* return address register *)
                (parse_call_frame_instruction_bytes offset' ul)))
          (fun ( (v,(aug,(mas',mss))), (caf,(daf,(rar,bs))) ) ->
            let pc = <|pc_bytes = bs; pc_offset = 0  |> in
            match parse_call_frame_instructions c cuh pc with
            | PR_success is _ ->
                FIE_cie
                  (
                    <|
                    cie_offset = offset;
                    cie_length = ul;
                    cie_id = cie_id;
                    cie_version = v;
                    cie_augmentation = aug;
                    cie_address_size = mas';
                    cie_segment_size = mss;
                    cie_code_alignment_factor = caf;
                    cie_data_alignment_factor = daf;
                    cie_return_address_register = rar;
                    cie_initial_instructions_bytes = bs;
                    cie_initial_instructions = is;
                  |>)
            | PR_fail s _ -> Assert_extra.failwith s
            end
          )

      else
        (* parse fde *)
        let cie = find_cie fi cie_id in
        (* let _ = my_debug4 (pp_cie c cuh cie) in *)
        pr_post_map
          (parse_triple
             (parse_initial_location c cuh cie.cie_segment_size cie.cie_address_size) (*(segment selector and target address)*)
             (parse_uint_address_size c (match cie.cie_address_size with Just n -> n | Nothing -> cuh.cuh_address_size end)) (* address_range (target address) *)
             (parse_call_frame_instruction_bytes offset' ul)
          )
          (fun ( (ss,adr), (ar, bs)) ->
            let pc = <|pc_bytes = bs; pc_offset = 0  |> in
            match parse_call_frame_instructions c cuh pc with
            | PR_success is _ ->
                FIE_fde
                  (
                    <|
                    fde_offset = offset;
                    fde_length = ul;
                    fde_cie_pointer = cie_id;
                    fde_initial_location_segment_selector = ss;
                    fde_initial_location_address = adr;
                    fde_address_range = ar;
                    fde_instructions_bytes = bs;
                    fde_instructions = is;
                  |> )
            | PR_fail s _ -> Assert_extra.failwith s
            end
         )
    )

(* you can't even parse an fde without accessing the cie it refers to
(to determine the segment selector size).  Gratuitous complexity or what?
Hence the following, which should be made more tail-recursive.  *)

val parse_dependent_list' : forall 'a. (list 'a -> parser 'a) -> list 'a -> parser (list 'a)
let rec parse_dependent_list' p1 acc =
  fun pc ->
    if Byte_sequence.length pc.pc_bytes = 0 then
      PR_success (List.reverse acc) pc
    else
      pr_bind
        (p1 acc pc)
        (fun x pc' ->
          parse_dependent_list' p1 (x::acc) pc')

val parse_dependent_list : forall 'a. (list 'a -> parser 'a) -> parser (list 'a)
let parse_dependent_list p1 = parse_dependent_list' p1 []


let parse_frame_info c cuh : parser frame_info
      =
    parse_dependent_list (parse_frame_info_element c cuh)


(** line numbers .debug_line, pp and parsing *)

let pp_line_number_file_entry lnfe =
 "lnfe_path = " ^ string_of_byte_sequence lnfe.lnfe_path ^ "\n"
^ "lnfe_directory_index " ^ show lnfe.lnfe_directory_index ^ "\n"
^ "lnfe_last_modification = " ^ show lnfe.lnfe_last_modification ^ "\n"
^ "lnfe_length = " ^ show lnfe.lnfe_length ^ "\n"


let pp_line_number_header lnh =
  "offset =                             " ^ pphex lnh.lnh_offset ^ "\n"
^ "dwarf_format =                       " ^ pp_dwarf_format lnh.lnh_dwarf_format ^ "\n"
^ "unit_length =                        " ^ show lnh.lnh_unit_length ^ "\n"
^ "version =                            " ^ show lnh.lnh_version ^ "\n"
^ "header_length =                      " ^ show lnh.lnh_header_length ^ "\n"
^ "minimum_instruction_length =         " ^ show lnh.lnh_minimum_instruction_length ^ "\n"
^ "maximum_operations_per_instruction = " ^ show lnh.lnh_maximum_operations_per_instruction ^ "\n"
^ "default_is_stmt =                    " ^ show lnh.lnh_default_is_stmt ^ "\n"
^ "line_base =                          " ^ show lnh.lnh_line_base ^ "\n"
^ "line_range =                         " ^ show lnh.lnh_line_range ^ "\n"
^ "opcode_base =                        " ^ show lnh.lnh_opcode_base ^ "\n"
^ "standard_opcode_lengths =            " ^ show lnh.lnh_standard_opcode_lengths ^ "\n"
^ "comp_dir =                           " ^ show lnh.lnh_comp_dir ^ "\n"
^ "include_directories =                " ^ String.concat ", " (List.map string_of_byte_sequence  lnh.lnh_include_directories) ^ "\n"
^ "file_entries =                   \n\n" ^ String.concat "\n" (List.map pp_line_number_file_entry  lnh.lnh_file_entries) ^ "\n"

  
let pp_line_number_operation lno =
  match lno with
  | DW_LNS_copy               -> "DW_LNS_copy"
  | DW_LNS_advance_pc n       -> "DW_LNS_advance_pc" ^ " " ^ show n
  | DW_LNS_advance_line i     -> "DW_LNS_advance_line" ^ " " ^ show i
  | DW_LNS_set_file n         -> "DW_LNS_set_file" ^ " " ^ show n
  | DW_LNS_set_column n       -> "DW_LNS_set_column" ^ " " ^ show n
  | DW_LNS_negate_stmt        -> "DW_LNS_negate_stmt"
  | DW_LNS_set_basic_block    -> "DW_LNS_set_basic_block"
  | DW_LNS_const_add_pc       -> "DW_LNS_const_add_pc"
  | DW_LNS_fixed_advance_pc n -> "DW_LNS_fixed_advance_pc" ^ " " ^ show n
  | DW_LNS_set_prologue_end   -> "DW_LNS_set_prologue_end"
  | DW_LNS_set_epilogue_begin -> "DW_LNS_set_epilogue_begin"
  | DW_LNS_set_isa n          -> "DW_LNS_set_isa" ^ " " ^ show n
  | DW_LNE_end_sequence           -> "DW_LNE_end_sequence"
  | DW_LNE_set_address n          -> "DW_LNE_set_address" ^ " " ^ pphex n
  | DW_LNE_define_file s n1 n2 n3 -> "DW_LNE_define_file" ^ " " ^ show s ^ " " ^ show n1 ^ " " ^ show n2 ^ " " ^ show n3
  | DW_LNE_set_discriminator n    -> "DW_LNE_set_discriminator" ^ " " ^ show n
  | DW_LN_special n           -> "DW_LN_special" ^ " " ^ show n
  end

let pp_line_number_program lnp =
  pp_line_number_header lnp.lnp_header
  ^ "[" ^ String.concat ", " (List.map pp_line_number_operation lnp.lnp_operations) ^ "]\n"



let parse_line_number_file_entry : parser (maybe line_number_file_entry)
      =
    parse_dependent
      (parse_non_empty_string)
      (fun ms ->
        match ms with
        | Nothing ->
            pr_return Nothing
        | Just s ->
            pr_post_map
              (parse_triple
                 parse_ULEB128
                 parse_ULEB128
                 parse_ULEB128
              )
              (fun (n1,(n2,n3)) ->
                (Just
                <|
                lnfe_path = s;
                lnfe_directory_index = n1;
                lnfe_last_modification = n2;
                lnfe_length = n3;
              |> )
              )
         end
      )

let parse_line_number_header c (comp_dir:maybe string) : parser line_number_header =
  (parse_dependent
     ((pr_with_pos
         (parse_unit_length c) ))
     (fun (pos,(df,ul)) ->
       (*
         parse_dependent_pair
           (parse_pair
              (parse_triple
                 (parse_uint16 c)        (* version *)
                 (parse_uintDwarfN c df) (* header_length *)
                 (parse_uint8)           (* minimum_instruction_length *)
              (*    (parse_uint8)           (* maximum_operations_per_instruction  NOT IN DWARF 2*)*)
              )
              (parse_quadruple
                 (parse_uint8)           (* default_is_stmt *)
                 (parse_sint8)           (* line_base *)
                 (parse_uint8)           (* line_range *)
                 (parse_uint8)           (* opcode_base *)
           ))
           (fun ((v,(hl,(minil(*,maxopi*)))),(dis,(lb,(lr,ob)))) ->

        *)
       (parse_dependent
          (parse_dependent_pair
	     (parse_uint16 c)        (* version *)
             (fun v -> 
               (parse_pair
                  (parse_triple
                     (parse_uintDwarfN c df) (* header_length *)
                     (parse_uint8)           (* minimum_instruction_length *)
                     (if v<4 then     (* maximum_operations_per_instruction*)(*  NOT IN DWARF 2 or 3; in DWARF 4*)
                        (parse_uint8_constant 1)
                      else
                        (parse_uint8)           
                     ))
                  (parse_quadruple
                     (parse_uint8)           (* default_is_stmt *)
                     (parse_sint8)           (* line_base *)
                     (parse_uint8)           (* line_range *)
                     (parse_uint8)           (* opcode_base *)
          ))))
          (fun ((v,(((hl,(minil,maxopi))),(dis,(lb,(lr,ob)))))) ->
            pr_post_map
              (parse_triple
                 (pr_post_map (parse_n_bytes (ob-1)) (fun bs -> List.map natural_of_byte (byte_list_of_byte_sequence bs)))  (* standard_opcode_lengths *)
                 ((*pr_return [[]]*) parse_list parse_non_empty_string) (* include_directories *)
                 (parse_list parse_line_number_file_entry) (* file names *)
              )
              (fun (sols, (ids, fns)) ->
                <|
                lnh_offset = pos;
                lnh_dwarf_format = df;
                lnh_unit_length = ul;
                lnh_version = v;
                lnh_header_length = hl;
                lnh_minimum_instruction_length = minil;
                lnh_maximum_operations_per_instruction = maxopi;
                lnh_default_is_stmt = (dis<>0);
                lnh_line_base = lb;
                lnh_line_range = lr;
                lnh_opcode_base = ob;
                lnh_standard_opcode_lengths = sols;
                lnh_include_directories = ids;
                lnh_file_entries = fns;
                lnh_comp_dir = comp_dir;
                |>
              )
          )
       )
     )
  )  
let parser_of_line_number_argument_type c (cuh: compilation_unit_header) (lnat: line_number_argument_type) : parser line_number_argument_value =
    match lnat with
    | LNAT_address -> pr_map2 (fun n -> LNAV_address n) (parse_uint_address_size c cuh.cuh_address_size)
    | LNAT_ULEB128 -> pr_map2 (fun n -> LNAV_ULEB128 n) (parse_ULEB128)
    | LNAT_SLEB128 -> pr_map2 (fun i -> LNAV_SLEB128 i) (parse_SLEB128)
    | LNAT_uint16  -> pr_map2 (fun n -> LNAV_uint16 n) (parse_uint16 c)
    | LNAT_string  -> pr_map2 (fun s -> LNAV_string s) (parse_string)
    end

let parse_line_number_operation c (cuh: compilation_unit_header) (lnh: line_number_header) : parser line_number_operation =
  parse_dependent
    parse_uint8
    (fun opcode ->
      if opcode=0 then
        (* parse extended opcode *)
        parse_dependent
          (parse_pair
             parse_ULEB128
             parse_uint8)
          (fun (size,opcode') ->
            match lookup_aBcd_acd opcode' line_number_extended_encodings with
            | Just (_, arg_types, result) ->
                let ps = List.map (parser_of_line_number_argument_type c cuh) arg_types in
                parse_demaybe ("parse_line_number_operation fail")
                  (pr_post_map
                     (parse_parser_list ps)
                     result )
            | Nothing ->
                Assert_extra.failwith ("parse_line_number_operation extended opcode not found: " ^ show opcode')
            end)
            (* it's not clear what the ULEB128 size field is for, as the extended opcides all seem to have well-defined sizes.  perhaps there can be extra padding that needs to be absorbed? *)
      else if opcode >= lnh.lnh_opcode_base then
        (* parse special opcode *)
        let adjusted_opcode = opcode - lnh.lnh_opcode_base in
        pr_return (DW_LN_special adjusted_opcode)
      else
        (* parse standard opcode *)
        match lookup_aBcd_acd opcode line_number_standard_encodings with
        | Just (_, arg_types, result) ->
            let ps = List.map (parser_of_line_number_argument_type c cuh) arg_types in
            parse_demaybe ("parse_line_number_operation fail")
              (pr_post_map
                 (parse_parser_list ps)
                 result)
        | Nothing ->
            Assert_extra.failwith ("parse_line_number_operation standard opcode not found: " ^ show opcode)
              (* the standard_opcode_lengths machinery is intended to allow vendor specific extension instructions to be parsed and ignored, but here we couldn't usefully process such instructions in any case, so we just fail *)
        end)


let parse_line_number_operations c (cuh:compilation_unit_header) (lnh:line_number_header) : parser (list line_number_operation) =
    parse_list (parse_maybe (parse_line_number_operation c cuh lnh))


        (* assume operations start immediately after the header - not completely clear in DWARF whether the header_length is just an optimisation or whether it's intended to allow the operations to start later *)
        (* line number operations have no no-op and no termination operation, so we have to cut down the available bytes to the right length *)

let parse_line_number_program c (cuh:compilation_unit_header) (comp_dir:maybe string) : parser line_number_program =
    parse_dependent
      (parse_line_number_header c comp_dir)
      (fun lnh ->
        let byte_count_of_operations =
          lnh.lnh_unit_length - (lnh.lnh_header_length + 2 + (match lnh.lnh_dwarf_format with Dwarf32 -> 4 | Dwarf64 -> 8 end)) in
       pr_post_map
         (parse_restrict_length
           byte_count_of_operations
           (parse_line_number_operations c cuh lnh)
         )
         (fun ops ->
           <|
           lnp_header = lnh;
           lnp_operations = ops;
         |>)
     )

(*TODO: this should use find_natural_attribute_value_of_die *)  
let line_number_offset_of_compilation_unit c cu =
  match find_attribute_value "DW_AT_stmt_list" cu.cu_die with
  | Just (AV_sec_offset n) -> n
  | Just (AV_block n bs) -> natural_of_bytes c.endianness bs
        (* a 32-bit MIPS example used a 4-byte AV_block not AV_sec_offset *)
  | Just _ -> (Assert_extra.failwith ("compilation unit DW_AT_stmt_list attribute was not an AV_sec_offset"  ^ pp_compilation_unit_header cu.cu_header))
  | _ -> Assert_extra.failwith ("compilation unit did not have a DW_AT_stmt_list attribute\n" ^ pp_compilation_unit_header cu.cu_header ^ "\n")
  end

let line_number_program_of_compilation_unit d cu =
  let c = p_context_of_d d in
  let offset = line_number_offset_of_compilation_unit c cu in
  match List.find (fun lnp -> lnp.lnp_header.lnh_offset = offset) d.d_line_info with
  | Nothing -> Assert_extra.failwith "compilation unit line number offset not found"
  | Just lnp ->lnp
  end

let filename d cu n =
  let lnp = line_number_program_of_compilation_unit d cu in
  if n=0 then Nothing else
    match mynth (n - 1) lnp.lnp_header.lnh_file_entries with
    | Just lnfe ->
       Just (string_of_byte_sequence lnfe.lnfe_path)
    | Nothing ->
       Assert_extra.failwith ("line number file entry not found")
    end

let unpack_file_entry lnh file : unpacked_file_entry = 
  match mynth (file - 1) lnh.lnh_file_entries with
  | Just lnfe ->
     let directory =
       if lnfe.lnfe_directory_index = 0 then
         Nothing 
       else
         match mynth (lnfe.lnfe_directory_index - 1) lnh.lnh_include_directories with
         | Just d -> Just (string_of_byte_sequence d)
         | Nothing -> Just "<unpack_file_entry: directory entry not found>"
         end
     in
     (lnh.lnh_comp_dir, directory, string_of_byte_sequence lnfe.lnfe_path)
   | Nothing ->
     (Nothing,Nothing,"<unpack_file_entry: file entry not found>")
   end


let pp_ufe (((mcomp_dir,mdir,file) as ufe) : unpacked_file_entry) : string = 
  file
  ^ " dir=" ^ match mdir with | Just s->s|Nothing->"<none>" end
  ^ " comp_dir=" ^ match mcomp_dir with | Just s->s|Nothing->"<none>" end

let pp_ud (((((mcomp_dir,mdir,file) as ufe) : unpacked_file_entry), (line:nat), (subprogram_name:string)) : unpacked_decl) : string = 
  file
  ^ ":" ^ show line
  ^ " " ^ subprogram_name
  ^ " dir=" ^ match mdir with | Just s->s|Nothing->"<none>" end
  ^ " comp_dir=" ^ match mcomp_dir with | Just s->s|Nothing->"<none>" end

   
let pp_ufe_brief (((mcomp_dir,mdir,file) as ufe) : unpacked_file_entry) : string = 
  file
  (*
  ^ " dir=" ^ match mdir with | Just s->s|Nothing->"<none>" end
  ^ " comp_dir=" ^ match mcomp_dir with | Just s->s|Nothing->"<none>" end
   *)
   
let parse_line_number_info c str (d_line: byte_sequence) (cu: compilation_unit) : line_number_program =
  let comp_dir = find_string_attribute_value_of_die "DW_AT_comp_dir" str cu.cu_die in
  let f n =
    let d_line' = match dropbytes n d_line with Success xs -> xs | Fail _ -> Assert_extra.failwith "parse_line_number_info drop" end in
    let pc = <| pc_bytes = d_line'; pc_offset = n|> in
    match parse_line_number_program c cu.cu_header comp_dir pc with
    | PR_success lnp pc' ->
        (*let _ = print_endline (pp_line_number_program lnp) in*)
        lnp
    | PR_fail s pc' -> Assert_extra.failwith ("parse_line_number_header failed: " ^ s)
    end in
  f (line_number_offset_of_compilation_unit c cu)

let parse_line_number_infos c str debug_line_section_body compilation_units
    =
  List.map (parse_line_number_info c str debug_line_section_body) compilation_units

let pp_line_info li
    =
  String.concat "\n" (List.map (pp_line_number_program) li)


(** all dwarf info: pp and parsing *)

(* roughly matching objdump --dwarf=abbrev,info *)
let pp_dwarf_like_objdump d =
  let c = p_context_of_d d in
  ""

(*  ^ "\n*** compilation unit abbreviation table ***\n" *)
  ^ "Contents of the .debug_abbrev section:\n\n"
  ^ "  Number TAG (0x0)\n"
  ^ pp_abbreviations_tables d
(*  ^ "\n*** compilation unit die tree           ***\n"*)

(*  "\n************** .debug_info section - abbreviated *****************\n"
  ^ pp_compilation_units_abbrev c d.d_str d.d_compilation_units
    ^*)
(*  ^"\n************** .debug_info section - full ************************\n"*)
  ^ "\nContents of the .debug_info section:\n\n"
  ^ pp_compilation_units c false (*false for no indent, like objdump; true for nice indent *) d.d_str d.d_compilation_units


    
let pp_dwarf d =
  let c = p_context_of_d d in

(*  "\n************** .debug_info section - abbreviated *****************\n"
  ^ pp_compilation_units_abbrev c d.d_str d.d_compilation_units
  ^*) "\n************** .debug_info section - full ************************\n"
  ^ pp_compilation_units c true d.d_str d.d_compilation_units
  ^ "\n************** .debug_loc section: location lists ****************\n"
  ^ let (cuh_default : compilation_unit_header) = let cu = myhead d.d_compilation_units in cu.cu_header in
    pp_loc c cuh_default d.d_loc
  ^ "\n************** .debug_ranges section: range lists ****************\n"
  ^ pp_ranges c cuh_default d.d_ranges
  ^ "\n************** .debug_frame section: frame info   ****************\n"
  ^ pp_frame_info c cuh_default d.d_frame_info
  ^ "\n************** .debug_line section: line number info   ****************\n"
  ^ pp_line_info d.d_line_info


(* TODO: don't use lists of bytes here! *)
let parse_dwarf c
    (debug_info_section_body: byte_sequence)
    (debug_abbrev_section_body: byte_sequence)
    (debug_str_section_body: byte_sequence)
    (debug_loc_section_body: byte_sequence)
    (debug_ranges_section_body: byte_sequence)
    (debug_frame_section_body: byte_sequence)
    (debug_line_section_body: byte_sequence)
    : dwarf =

  let pc_info = <|pc_bytes = debug_info_section_body; pc_offset = 0  |> in

  let compilation_units =
    match parse_compilation_units c debug_str_section_body debug_abbrev_section_body pc_info with
    | PR_fail s pc_info' ->  Assert_extra.failwith ("parse_compilation_units: " ^ pp_parse_fail s pc_info')
    | PR_success cus pc_info' -> cus
    end in

  (*let _ = my_debug5 (pp_compilation_units c debug_str_section_body compilation_units) in*)


(* the DWARF4 spec doesn't seem to specify the address size used in the .debug_loc section, so we (hackishly) take it from the first compilation unit *)
  let (cuh_default : compilation_unit_header) = let cu = myhead compilation_units in cu.cu_header in

  let pc_loc = <|pc_bytes = debug_loc_section_body; pc_offset = 0  |> in

  let loc =
    match parse_location_list_list c cuh_default pc_loc with
    | PR_fail s pc_info' ->  Assert_extra.failwith ("parse_location_list: " ^ pp_parse_fail s pc_info')
    | PR_success loc pc_loc' -> loc
    end in

  let pc_ranges = <|pc_bytes = debug_ranges_section_body; pc_offset = 0  |> in

  let ranges =
    match parse_range_list_list c cuh_default pc_ranges with
    | PR_fail s pc_info' ->  Assert_extra.failwith ("parse_range_list: " ^ pp_parse_fail s pc_info')
    | PR_success r pc_loc' -> r
    end in

  let pc_frame = <|pc_bytes = debug_frame_section_body; pc_offset = 0  |> in

  let fi =
    (* let _ = my_debug5 ("debug_frame_section_body:\n" ^ ppbytes2 0 debug_frame_section_body) in *)

    match parse_frame_info c cuh_default pc_frame with
    | PR_fail s pc_info' ->  Assert_extra.failwith ("parse_frame_info: " ^ pp_parse_fail s pc_info')
    | PR_success fi pc_loc' -> fi
    end in

  let li = parse_line_number_infos c debug_str_section_body debug_line_section_body compilation_units in

   <|
   d_endianness = c.endianness;
   d_str = debug_str_section_body;
   d_compilation_units = compilation_units;
   d_type_units = [];
   d_loc = loc;
   d_ranges = ranges;
   d_frame_info = fi;
   d_line_info = li;
  |>

val extract_section_body : elf_file -> string -> bool -> p_context * natural * byte_sequence
let extract_section_body (f:elf_file) (section_name:string) (strict: bool) =
  let (en: Endianness.endianness) =
    match f with
    | ELF_File_32 f32 -> Elf_header.get_elf32_header_endianness f32.Elf_file.elf32_file_header
    | ELF_File_64 f64 -> Elf_header.get_elf64_header_endianness f64.Elf_file.elf64_file_header
    end in
  let (c: p_context) = <| endianness = en |> in
  match f with
  | ELF_File_32 f32 ->
      let sections =
        List.filter
          (fun x ->
            x.Elf_interpreted_section.elf32_section_name_as_string = section_name
          ) f32.elf32_file_interpreted_sections in
      match sections with
      | [section] ->
          let section_addr = section.Elf_interpreted_section.elf32_section_addr in
          let section_body = section.Elf_interpreted_section.elf32_section_body in
          (* let _ = my_debug4 (section_name ^ (": \n" ^ (Elf_interpreted_section.string_of_elf32_interpreted_section section ^ "\n"
           *                ^ "  body = " ^ ppbytes2 0 section_body ^ "\n"))) in *)
          (c,section_addr,section_body)
      | [] ->
          if strict then
            Assert_extra.failwith ("" ^ section_name ^ " section not present")
          else
            (c,0,Byte_sequence.empty)
      | _ -> Assert_extra.failwith ("multiple " ^ section_name ^ " sections present")
      end


  | ELF_File_64 f64 ->
      let sections =
        List.filter
          (fun x ->
            x.Elf_interpreted_section.elf64_section_name_as_string = section_name
          ) f64.elf64_file_interpreted_sections in
      match sections with
      | [section] ->
          let section_addr = section.Elf_interpreted_section.elf64_section_addr in 
          let section_body = section.Elf_interpreted_section.elf64_section_body in
          (c,section_addr,section_body)
      | [] ->
          if strict then
            Assert_extra.failwith ("" ^ section_name ^ " section not present")
          else
            (c,0,Byte_sequence.empty)
      | _ -> Assert_extra.failwith ("multiple " ^ section_name ^ " sections present")
      end
  end

val extract_dwarf : elf_file -> maybe dwarf
let extract_dwarf f =
  let (c, _, debug_info_section_body)   = extract_section_body f ".debug_info"   true  in
  let (c, _, debug_abbrev_section_body) = extract_section_body f ".debug_abbrev" false in
  let (c, _, debug_str_section_body)    = extract_section_body f ".debug_str"    false in
  let (c, _, debug_loc_section_body)    = extract_section_body f ".debug_loc"    false in
  let (c, _, debug_ranges_section_body) = extract_section_body f ".debug_ranges" false in
  let (c, _, debug_frame_section_body)  = extract_section_body f ".debug_frame" false in
  let (c, _, debug_line_section_body)   = extract_section_body f ".debug_line" false in

  let d = parse_dwarf c debug_info_section_body debug_abbrev_section_body debug_str_section_body debug_loc_section_body debug_ranges_section_body debug_frame_section_body debug_line_section_body in

  Just d

val extract_text : elf_file -> p_context * natural * byte_sequence  (* (p_context, elf32/64_section_addr, elf32/64_section_body) *)
let extract_text f = extract_section_body f ".text" true 


(** ************************************************************ *)
(** ****** location evaluation  ******************************** *)
(** ************************************************************ *)


(** pp of locations *)

val pp_simple_location : simple_location -> string
let pp_simple_location sl =
  match sl with
  | SL_memory_address n -> pphex n
  | SL_register n -> "reg" ^ show n
  | SL_implicit bs -> "value: " ^ ppbytes bs
  | SL_empty -> "<empty>"
  end

val pp_composite_location_piece : composite_location_piece -> string
let pp_composite_location_piece clp =
  match clp with
  | CLP_piece n sl -> "piece (" ^ show n ^ ") " ^ pp_simple_location sl
  | CLP_bit_piece n1 n2 sl -> "bit_piece (" ^ show n1 ^ "," ^ show n2 ^ ") " ^ pp_simple_location sl
  end

val pp_single_location: single_location -> string
let pp_single_location sl =
  match sl with
  | SL_simple sl -> pp_simple_location sl
  | SL_composite clps -> "composite: " ^ String.concat ", " (List.map pp_composite_location_piece clps)
  end


(** evaluation of location expressions *)

(* cf dwarflist, btw: https://fedorahosted.org/elfutils/wiki/DwarfLint?format=txt *)

(*

location description ::=
| single location description
| location list

single location description ::=
| simple location description
| composite location description

simple location description ::=
| memory location description : non-empty dwarf expr, value is address of all or part of object in memory
| register location description : single DW_OP_regN or DW_OP_regx, naming a register in which all the object is
| implicit location description : single DW_OP_implicit_value or a non-empty dwarf expr ending in DW_OP_stack_value, giving the value of all/part of object
| empty location description : an empty dwarf expr, indicating a part or all of an object that is not represented

composite location description : a list of simple location descriptions, each followed by a DW_OP_piece or DW_OP_bitpiece

(the simple location description can be a register location description: https://www.mail-archive.com/dwarf-discuss@lists.dwarfstd.org/msg00271.html)
(contradicting "A register location description must stand alone as the entire description of an object or a piece of an object.")

location list entry : a list of address ranges (possibly overlapping), each with a single location description

Dwarf expressions can include data-dependent control flow choices
(though we don't see that in the examples?), so we can't statically
determine which kind of single location description or simple location
description we have.  We can distinguish:

- empty -> simple.empty
- DW_OP_regN/DW_OP_regx -> simple.register
- DW_OP_implicit_value -> simple.implicit
- any of those followed by DW_OP_piece or DW_OP_bitpiece, perhaps followed by more composite parts -> composite part :: composite

otherwise run to the end, or a DW_OP_stack_value at the end, or to
anything (except a DO_OP_regN/DW_OP_regx) followed by a
DW_OP_piece/DW_OP_bitpiece. Pfeh.


actually used in our examples (ignoring GNU extentions):

DW_OP_addr         literal
DW_OP_lit1         literal
DW_OP_const4u      literal

DW_OP_breg3 (r3)   read register value and add offset

DW_OP_and          bitwise and
DW_OP_plus         addition (mod whatever)

DW_OP_deref_size
DW_OP_fbreg        evaluate location description from DW_AT_frame_base attribute of the current function (which is DW_OP_call_frame_cfa in our examples) and add offset

DW_OP_implicit_value   the argument block is the actual value (not location) of the entity in question
DW_OP_stack_value      use the value at top of stack as the actual value (not location) of the entity in question

DW_OP_reg0 (r0))       read register value

DW_OP_call_frame_cfa   go off to 6.4 and pull info out of .debug_frame (possibly involving other location expressions)

*)



let initial_state =
  <|
  s_stack = [];
  s_value = SL_empty;
  s_location_pieces = [];
|>

(* the main location expression evaluation function *)

(* location expression evaluation is basically a recursive function
down a list of operations, maintaining an operation_stack (a list of
naturals representing machine-address-size words), the current
simple_location, and a list of any composite_location_piece's
accumulated so far *)



let arithmetic_context_of_cuh cuh =
  match cuh.cuh_address_size with
  | 8 ->
      <|
      ac_bitwidth = 64;
      ac_half = naturalPow 2 32;
      ac_all = naturalPow 2 64;
      ac_max = (naturalPow 2 64) - 1;
    |>
  | 4 ->
      <|
      ac_bitwidth = 32;
      ac_half = naturalPow 2 16;
      ac_all = naturalPow 2 32;
      ac_max = (naturalPow 2 32) - 1;
    |>
  | _ -> Assert_extra.failwith "arithmetic_context_of_cuh given non-4/8 size"
  end

let find_cfa_table_row_for_pc (evaluated_frame_info: evaluated_frame_info) (pc: natural) : cfa_table_row =
  match
    myfind
      (fun (fde,rows) -> pc >= fde.fde_initial_location_address && pc < fde.fde_initial_location_address + fde.fde_address_range)
      evaluated_frame_info
  with
  | Just (fde,rows) ->
      match myfind (fun row -> pc >= row.ctr_loc) rows with
      | Just row -> row
      | Nothing -> Assert_extra.failwith "evaluate_cfa: no matchine row"
      end
  | Nothing -> Assert_extra.failwith "evaluate_cfa: no fde encloding pc"
  end


let rec evaluate_operation_list (c:p_context) (dloc: location_list_list) (evaluated_frame_info: evaluated_frame_info) (cuh: compilation_unit_header) (ac: arithmetic_context) (ev: evaluation_context) (mfbloc: maybe attribute_value) (pc: natural) (s: state) (ops: list operation) : error single_location =

  let push_memory_address v vs' = Success <| s with s_stack = v :: vs'; s_value = SL_memory_address v |>  in

  let push_memory_address_maybe (mv: maybe natural) vs' (err:string) op =
    match mv with
    | Just v -> push_memory_address v vs'
    | Nothing -> Fail (err ^ pp_operation op)
    end in

  let bregxi r i =
    match ev.read_register r with
    | RRR_result v -> push_memory_address (partialNaturalFromInteger ((integerFromNatural v+i) mod (integerFromNatural ac.ac_all))) s.s_stack
    | RRR_not_currently_available -> Fail "RRR_not_currently_available"
    | RRR_bad_register_number -> Fail ("RRR_bad_register_number " ^ show r)
    end in

  let deref_size n =
    match s.s_stack with
    | v::vs' ->
        match ev.read_memory v n with
        | MRR_result v' -> push_memory_address v' vs'
        | MRR_not_currently_available -> Fail "MRR_not_currently_available"
        | MRR_bad_address -> Fail "MRR_bad_address"
        end
    | _ -> Fail "OpSem unary not given an element on stack"
    end in

  match ops with
  | [] ->
      if s.s_location_pieces = [] then
        Success (SL_simple s.s_value)
      else if s.s_value = SL_empty then
        Success (SL_composite s.s_location_pieces)
      else
        (*  unclear what's supposed to happen in this case *)
        Fail "unfinished part of composite expression"

  | op::ops' ->
      let es' =
        match (op.op_semantics, op.op_argument_values)  with
        | (OpSem_nop, []) ->
            Success s
        | (OpSem_lit, [OAV_natural n]) ->
            push_memory_address n s.s_stack
        | (OpSem_lit, [OAV_integer i]) ->
            push_memory_address (partialTwosComplementNaturalFromInteger i ac.ac_half (integerFromNatural ac.ac_all)) s.s_stack
        | (OpSem_stack f, []) ->
            match f ac s.s_stack op.op_argument_values with
            | Just stack' ->
                let value' : simple_location = match stack' with [] -> SL_empty | v'::_ -> SL_memory_address v' end in
                Success <| s with s_stack = stack'; s_value = value' |>
            | Nothing -> Fail "OpSem_stack failed"
            end
        | (OpSem_not_supported, []) ->
            Fail ("OpSem_not_supported: " ^ pp_operation op)
        | (OpSem_binary f, []) ->
            match s.s_stack with
            | v1::v2::vs' -> push_memory_address_maybe (f ac v1 v2) vs' "OpSem_binary error: " op
            | _ -> Fail "OpSem binary not given two elements on stack"
            end
        | (OpSem_unary f, []) ->
            match s.s_stack with
            | v1::vs' -> push_memory_address_maybe (f ac v1) vs' "OpSem_unary error: " op
            | _ -> Fail "OpSem unary not given an element on stack"
            end
        | (OpSem_opcode_lit base, []) ->
            if op.op_code >= base && op.op_code < base + 32 then
              push_memory_address (op.op_code - base) s.s_stack
            else
              Fail "OpSem_opcode_lit opcode not within [base,base+32)"
        | (OpSem_reg, []) ->
            (* TODO: unclear whether this should push the register id or not *)
            let r = op.op_code - vDW_OP_reg0 in
            Success <| s with s_stack = r :: s.s_stack; s_value = SL_register r |>
        | (OpSem_breg, [OAV_integer i]) ->
            let r = op.op_code - vDW_OP_breg0 in
            bregxi r i
        | (OpSem_bregx, [OAV_natural r; OAV_integer i]) ->
            bregxi r i
        | (OpSem_deref, []) ->
            deref_size cuh.cuh_address_size
        | (OpSem_deref_size, [OAV_natural n]) ->
            deref_size n
        | (OpSem_fbreg, [OAV_integer i]) ->
            match mfbloc with
            | Just fbloc ->
                (*let _ = my_debug5 ("OpSem_fbreg (" ^ show i ^ ")\n") in*)
                match evaluate_location_description c dloc evaluated_frame_info  cuh ac ev (*mfbloc*)Nothing pc fbloc with
                (* what to do if the recursive call also uses fbreg?  for now assume that's not allowed *)
                | Success l ->
                    match l with
                    | SL_simple (SL_memory_address a) ->
                        (*let _ = my_debug5 ("OpSem_fbreg: a = "^ pphex a ^ "\n") in*)
                        let vi = ((integerFromNatural a) + i) mod (integerFromNatural ac.ac_all) in
                        (*let _ = my_debug5 ("OpSem_fbreg: v = "^ show vi ^ "\n") in*)
                        let v = partialNaturalFromInteger vi (*ac.ac_half (integerFromNatural ac.ac_all)*) in
                        push_memory_address v s.s_stack
                    | _ ->
                        Fail "OpSem_fbreg got a non-SL_simple (SL_memory_address _) result"
                       (* "The DW_OP_fbreg operation provides a signed LEB128
                           offset from the address specified by the location
                           description in the DW_AT_frame_base attribute of the
                           current function. "
                          - so what to do if the location description returns a non-memory-address location?  *)
                    end
                | Fail e ->
                    Fail ("OpSem_fbreg failure: " ^ e)
                end
            | Nothing ->
                Fail "OpSem_fbreg: no frame base location description given"
            end

        | (OpSem_piece, [OAV_natural size_bytes]) ->
            let piece = CLP_piece size_bytes s.s_value in
            (* we allow a piece (or bit_piece) to be any simple_location, including implicit and stack values. Unclear if this is intended, esp. the latter *)
            let stack' = [] in
            let value' = SL_empty in
            Success <| s_stack = stack'; s_value = value'; s_location_pieces = s.s_location_pieces ++ [piece] |>
        | (OpSem_bit_piece, [OAV_natural size_bits; OAV_natural offset_bits]) ->
            let piece = CLP_bit_piece size_bits offset_bits s.s_value in
            let stack' = [] in
            let value' = SL_empty in
            Success <| s_stack = stack'; s_value = value'; s_location_pieces = s.s_location_pieces ++ [piece] |>
        | (OpSem_implicit_value, [OAV_block size bs]) ->
            let stack' = [] in
            let value' = SL_implicit bs in
            Success <| s with s_stack = stack'; s_value = value' |>
        | (OpSem_stack_value, []) ->
            (* "The DW_OP_stack_value operation terminates the expression." - does
               this refer to just the subexpression, ie allowing a stack value to be
               a piece of a composite location, or necessarily the whole expression?
               Why does DW_OP_stack_value have this clause while DW_OP_implicit_value
               does not? *)
            (* why doesn't DW_OP_stack_value have a size argument? *)
            match s.s_stack with
            | v::vs' ->
                let stack' = [] in
                let value' = SL_implicit (bytes_of_natural c.endianness cuh.cuh_address_size v) in
                Success <| s with s_stack = stack'; s_value = value' |>

            | _ -> Fail "OpSem_stack_value not given an element on stack"
            end
        | (OpSem_call_frame_cfa, []) ->
            let row = find_cfa_table_row_for_pc evaluated_frame_info pc in
            match row.ctr_cfa with
            | CR_undefined ->
                Assert_extra.failwith "evaluate_cfa of CR_undefined"
            | CR_register r i ->
                bregxi r i  (* same behaviour as an OpSem_bregx *)
            | CR_expression bs ->
                Assert_extra.failwith "CR_expression"
                (*TODO: fix result type - not this evaluate_location_description_bytes c dloc evaluated_frame_info cuh ac ev mfbloc pc bs*)
                  (* TODO: restrict allowed OpSem_* in that recursive call *)
            end
        | (_, _) ->
            Fail ("bad OpSem invocation: op=" ^ pp_operation op ^ " arguments=" ^ String.concat "" (List.map pp_operation_argument_value op.op_argument_values))
        end
      in
      match es' with
      | Success s' ->
          evaluate_operation_list c dloc evaluated_frame_info  cuh ac ev mfbloc pc s' ops'
      | Fail e ->
          Fail e
      end
  end

and evaluate_location_description_bytes (c:p_context) (dloc: location_list_list) (evaluated_frame_info: evaluated_frame_info) (cuh: compilation_unit_header) (ac: arithmetic_context) (ev: evaluation_context) (mfbloc: maybe attribute_value) (pc: natural) (bs: byte_sequence) : error single_location =
  let parse_context = <|pc_bytes = bs; pc_offset = 0  |> in
  match parse_operations c cuh parse_context with
  | PR_fail s pc' -> Fail ("evaluate_location_description_bytes: parse_operations fail: " ^ pp_parse_fail s pc')
  | PR_success ops pc' ->
      if Byte_sequence.length pc'.pc_bytes <> 0 then
        Fail "evaluate_location_description_bytes: extra non-parsed bytes"
      else
        evaluate_operation_list c dloc evaluated_frame_info  cuh ac ev mfbloc pc initial_state ops
  end

and evaluate_location_description (c:p_context) (dloc: location_list_list) (evaluated_frame_info: evaluated_frame_info) (cuh: compilation_unit_header) (ac: arithmetic_context) (ev: evaluation_context) (mfbloc: maybe attribute_value) (pc: natural) (loc:attribute_value) : error single_location =
  match loc with
  | AV_exprloc n bs ->
      evaluate_location_description_bytes c dloc evaluated_frame_info  cuh ac ev mfbloc pc bs
  | AV_block n bs ->
      evaluate_location_description_bytes c dloc evaluated_frame_info  cuh ac ev mfbloc pc bs
  | AV_sec_offset n ->
      let location_list = find_location_list dloc n in
      let (offset,(llis:list location_list_item)) = location_list in
      let f (lli:location_list_item) : maybe single_location_description =
        match lli with
        | LLI_lle lle ->
           if pc >= lle.lle_beginning_address_offset && pc < lle.lle_ending_address_offset then Just lle.lle_single_location_description else Nothing
        | LLI_base _ ->
           Nothing  (* TODO: either refactor to do offset during parsing or update base offsets here. Should refactor to use "interpreted". *)
        end in
        match myfindmaybe f llis with
        | Just bs ->
            evaluate_location_description_bytes c dloc evaluated_frame_info  cuh ac ev mfbloc pc bs
        | Nothing ->
            Fail "evaluate_location_description didn't find pc in location list ranges"
        end
  | _ -> Fail "evaluate_location_description av_location not understood"
  end





(** ************************************************************ *)
(** ****  evaluation of frame information ********************** *)
(** ************************************************************ *)

(** register maps *)

val rrp_update : register_rule_map -> cfa_register -> register_rule -> register_rule_map
let rrp_update rrp r rr = (r,rr)::rrp

val rrp_lookup : cfa_register -> register_rule_map -> register_rule
let rrp_lookup r rrp =
  match List.lookup r rrp with
  | Just rr -> rr
  | Nothing -> RR_undefined
  end

val rrp_empty : register_rule_map
let rrp_empty = []



(** pp of evaluated cfa information from .debug_frame *)
(* readelf --debug-dump=frames-interp test/a.out

Contents of the .eh_frame section:

00000000 00000014 00000000 CIE "zR" cf=1 df=-8 ra=16
   LOC           CFA      ra
0000000000000000 rsp+8    c-8

00000018 00000024 0000001c FDE cie=00000000 pc=004003b0..004003d0
   LOC           CFA      ra
00000000004003b0 rsp+16   c-8
00000000004003b6 rsp+24   c-8
00000000004003c0 exp      c-8

00000040 0000001c 00000044 FDE cie=00000000 pc=004004b4..004004ba
   LOC           CFA      rbp   ra
00000000004004b4 rsp+8    u     c-8
00000000004004b5 rsp+16   c-16  c-8
00000000004004b8 rbp+16   c-16  c-8
00000000004004b9 rsp+8    c-16  c-8

00000060 00000024 00000064 FDE cie=00000000 pc=004004c0..00400549
   LOC           CFA      rbx   rbp   r12   r13   r14   r15   ra
00000000004004c0 rsp+8    u     u     u     u     u     u     c-8
00000000004004d1 rsp+8    u     c-48  c-40  u     u     u     c-8
00000000004004f0 rsp+64   c-56  c-48  c-40  c-32  c-24  c-16  c-8
0000000000400548 rsp+8    c-56  c-48  c-40  c-32  c-24  c-16  c-8

00000088 00000014 0000008c FDE cie=00000000 pc=00400550..00400552
   LOC           CFA      ra
0000000000400550 rsp+8    c-8

000000a0 ZERO terminator
*)



val mytoList        : forall 'a. SetType 'a => set 'a -> list 'a
declare ocaml    target_rep function mytoList = `Pset.elements`

let register_footprint_rrp (rrp: register_rule_map) : set cfa_register =
  Set.fromList (List.map Tuple.fst rrp)

let register_footprint (rows: list cfa_table_row) : list cfa_register =
  mytoList (bigunionListMap (fun row -> register_footprint_rrp row.ctr_regs) rows)


val max_lengths : list (list string) -> list natural
let rec max_lengths xss =
  match xss with
  | [] -> Assert_extra.failwith "max_lengths"
  | xs::xss' ->
      let lens = List.map (fun x -> naturalFromNat (String.stringLength x)) xs in
      if xss' = [] then lens
      else
        let lens' = max_lengths xss' in
        let z = List.zip lens lens' in
        let lens'' = List.map (fun (l1,l2)-> max l1 l2) z in
        lens''
  end

let rec pad_row xs lens =
  match (xs,lens) with
  | ([],[]) -> []
  | ([x],[len]) -> [x]
  | (x::((_::_) as xs'), len::((_::_) as lens')) -> right_space_padded_to len x ::  pad_row xs' lens'
  end

let pad_rows (xss : list (list string)) : string =
  match xss with
  | [] -> ""
  | _ ->
     let lens = max_lengths xss in
     String.concat "" (List.map (fun xs -> String.concat " " (pad_row xs lens) ^ "\n") xss)
  end

let pp_evaluated_fde (fde, (rows: list cfa_table_row)) : string =
  let regs = register_footprint rows in
  let header : list string = "LOC" :: "CFA" :: List.map pp_cfa_register regs in
  let ppd_rows : list (list string) =
    List.map (fun row -> pphex row.ctr_loc :: pp_cfa_rule row.ctr_cfa :: List.map (fun r -> pp_register_rule (rrp_lookup r row.ctr_regs)) regs) rows  in
  pad_rows (header :: ppd_rows)

let semi_pp_evaluated_fde (fde, (rows: list cfa_table_row)) : list (natural (*address*) * string (*cfa*) * list (string*string) (*register rules*) ) =
  let regs = register_footprint rows in
  let ppd_rows =
    List.map
      (fun row ->
        (row.ctr_loc,
         pp_cfa_rule row.ctr_cfa,
         List.map (fun r -> (pp_cfa_register r, pp_register_rule (rrp_lookup r row.ctr_regs))) regs))
      rows  in
  ppd_rows

val semi_pp_evaluated_frame_info : evaluated_frame_info -> list (natural (*address*) * string (*cfa*) * list (string*string) (*register rules*) )
let semi_pp_evaluated_frame_info efi = 
  List.concat (List.map semi_pp_evaluated_fde efi)
  


(** evaluation of cfa information from .debug_frame *)

let evaluate_call_frame_instruction (fi: frame_info) (cie: cie) (state: cfa_state) (cfi: call_frame_instruction) : cfa_state =

  let create_row (loc: natural) =
    let row = <| state.cs_current_row with ctr_loc = loc |> in
    <| state with cs_current_row = row; cs_previous_rows = state.cs_current_row::state.cs_previous_rows |> in

  let update_cfa (cr:cfa_rule) =
    let row = <| state.cs_current_row with ctr_cfa = cr |> in
    <| state with cs_current_row = row |> in

  let update_reg r rr =
    let row = <| state.cs_current_row with ctr_regs = rrp_update state.cs_current_row.ctr_regs r rr |> in
    <| state with cs_current_row = row |> in

  match cfi with
  (* Row Creation Instructions *)
  | DW_CFA_set_loc a              ->
      create_row a
  | DW_CFA_advance_loc d          ->
      create_row (state.cs_current_row.ctr_loc + d * cie.cie_code_alignment_factor)
  | DW_CFA_advance_loc1 d         ->
      create_row (state.cs_current_row.ctr_loc + d * cie.cie_code_alignment_factor)
  | DW_CFA_advance_loc2 d         ->
      create_row (state.cs_current_row.ctr_loc + d * cie.cie_code_alignment_factor)
  | DW_CFA_advance_loc4 d         ->
      create_row (state.cs_current_row.ctr_loc + d * cie.cie_code_alignment_factor)

  (* CFA Definition Instructions *)
  | DW_CFA_def_cfa r n            ->
      update_cfa (CR_register r (integerFromNatural n))
  | DW_CFA_def_cfa_sf r i         ->
      update_cfa (CR_register r (i * cie.cie_data_alignment_factor))
  | DW_CFA_def_cfa_register r     ->
      match state.cs_current_row.ctr_cfa with
      | CR_register r' i ->
          update_cfa (CR_register r i)
      | CR_undefined ->
          (* FIXME: this is to handle a bug in riscv64-gcc.
          gcc generates "DW_CFA_def_cfa_register: r2 (sp)" as the first instruction.
          Dwarf5 documentation  seems to suggest this is not valid.
          We think what gcc meant to generate is "DW_CFA_def_cfa: r2 (sp) ofs 0" *)
          update_cfa (CR_register r 0)
      | CR_expression _ ->
          Assert_extra.failwith "DW_CFA_def_cfa_register: current rule is CR_expression"
      end
  | DW_CFA_def_cfa_offset n       ->
      match state.cs_current_row.ctr_cfa with
      | CR_register r i ->
          update_cfa (CR_register r (integerFromNatural n))
      | _ -> Assert_extra.failwith "DW_CFA_def_cfa_offset: current rule is not CR_register"
      end
  | DW_CFA_def_cfa_offset_sf i    ->
      match state.cs_current_row.ctr_cfa with
      | CR_register r i' ->
          update_cfa (CR_register r (i' * cie.cie_data_alignment_factor))
      | _ -> Assert_extra.failwith "DW_CFA_def_cfa_offset_sf: current rule is not CR_register"
      end
  | DW_CFA_def_cfa_expression b   ->
      update_cfa (CR_expression b)

  (* Register Rule Instrutions *)
  | DW_CFA_undefined r            ->
      update_reg r (RR_undefined)
  | DW_CFA_same_value r           ->
      update_reg r (RR_same_value)
  | DW_CFA_offset r n             ->
      update_reg r (RR_offset ((integerFromNatural n) * cie.cie_data_alignment_factor))
  | DW_CFA_offset_extended r n    ->
      update_reg r (RR_offset ((integerFromNatural n) * cie.cie_data_alignment_factor))
  | DW_CFA_offset_extended_sf r i ->
      update_reg r (RR_offset (i * cie.cie_data_alignment_factor))
  | DW_CFA_val_offset r n         ->
      update_reg r (RR_val_offset ((integerFromNatural n) * cie.cie_data_alignment_factor))
  | DW_CFA_val_offset_sf r i      ->
      update_reg r (RR_val_offset (i * cie.cie_data_alignment_factor))
  | DW_CFA_register r1 r2         ->
      update_reg r1 (RR_register r2)
  | DW_CFA_expression r b         ->
      update_reg r (RR_expression b)
  | DW_CFA_val_expression r b     ->
      update_reg r (RR_val_expression b)
  | DW_CFA_restore r              ->
      update_reg r (rrp_lookup r state.cs_initial_instructions_row.ctr_regs)
(* RR_undefined if the lookup fails? *)
  | DW_CFA_restore_extended r     ->
      update_reg r (rrp_lookup r state.cs_initial_instructions_row.ctr_regs)

(* Row State Instructions *)
(* do these also push and restore the CFA rule? *)
  | DW_CFA_remember_state         ->
      <| state with cs_row_stack = state.cs_current_row :: state.cs_row_stack |>
  | DW_CFA_restore_state          ->
      match state.cs_row_stack with
      | r::rs -> <| state with cs_current_row = r; cs_row_stack = rs |>
      | [] -> Assert_extra.failwith "DW_CFA_restore_state: empty row stack"
      end
(* Padding Instruction *)
  | DW_CFA_nop                    ->
      state

(* DW_CFA_AARCH64_negate_ra_state Instruction *)
  | DW_CFA_AARCH64_negate_ra_state        ->
      state
    
(* Unknown *)
  | DW_CFA_unknown b              ->
      Assert_extra.failwith ("evaluate_call_frame_instruction: DW_CFA_unknown " ^ show b)

  end



let rec evaluate_call_frame_instructions (fi: frame_info) (cie: cie) (state: cfa_state) (cfis: list call_frame_instruction) : cfa_state =
  match cfis with
  | [] -> state
  | cfi::cfis' ->
      let state' = evaluate_call_frame_instruction fi cie state cfi in
      evaluate_call_frame_instructions fi cie state' cfis'
  end


let evaluate_fde (fi: frame_info) (fde:fde) : list cfa_table_row =
  let cie = find_cie fi fde.fde_cie_pointer in
  let final_location = fde.fde_initial_location_address + fde.fde_address_range in
  let initial_cfa_state  =
    let initial_row =
      <|
      ctr_loc = fde.fde_initial_location_address;
      ctr_cfa = CR_undefined;
      ctr_regs = rrp_empty;
    |> in
    <|
    cs_current_row = initial_row;
    cs_previous_rows = [];
    cs_initial_instructions_row = initial_row;
    cs_row_stack = [];
  |>
  in
  let state' =
    evaluate_call_frame_instructions fi cie initial_cfa_state cie.cie_initial_instructions in
  let initial_row' = state'.cs_current_row in
  let state'' = <| initial_cfa_state with cs_current_row = initial_row'; cs_initial_instructions_row = initial_row' |> in
  let state''' =
    evaluate_call_frame_instructions fi cie (*final_location*) state'' fde.fde_instructions in
  List.reverse (state'''.cs_current_row:: state'''.cs_previous_rows)



val evaluate_frame_info : dwarf -> evaluated_frame_info
let evaluate_frame_info (d: dwarf) : evaluated_frame_info =
  List.mapMaybe (fun fie -> match fie with FIE_fde fde -> Just (fde, (evaluate_fde d.d_frame_info fde)) | FIE_cie _ -> Nothing end) d.d_frame_info

let pp_evaluated_frame_info (efi: evaluated_frame_info) =
  String.concat "\n" (List.map pp_evaluated_fde efi)


  

(** ************************************************************ *)
(** **  pp of type info                                          *)
(** ************************************************************ *)

(* partial analysis and pp of type info - incomplete, but enough for some C code *)

(* analyse top level of C type structure, without recursing into type subterms *)
let strict s x =
  match x with
  | Just y -> y
  | Nothing ->
     Assert_extra.failwith ("analyse_type_info_die strict failure on \n" ^ s () 
                            ^ "\n")
  end 


let analyse_type_info_top c (d: dwarf) (r:bool(*recurse into members*)) (cupdie: cupdie) : c_type_top cupdie = 
  let (cu,parents,die) = cupdie in
  let mname = find_name_of_die d.d_str die in
  let mtyp = find_DW_AT_type_of_die c d cu d.d_str die in
  let s () = pp_die c cu.cu_header d.d_str true 0 false die in
  
  if die.die_abbreviation_declaration.ad_tag = tag_encode "DW_TAG_base_type" then
    let encoding =
      let n = strict s (find_natural_attribute_value_of_die c "DW_AT_encoding" die) in
      if not(List.any (fun (s,n')->n=n') base_type_attribute_encodings) then strict s Nothing else n in
      (* TODO: handle user encodings correctly *)
    let mbyte_size = find_natural_attribute_value_of_die c "DW_AT_byte_size" die in
    CT_base cupdie (strict s mname) encoding mbyte_size

  else if die.die_abbreviation_declaration.ad_tag = tag_encode "DW_TAG_pointer_type" then
    CT_pointer cupdie  mtyp

  else if die.die_abbreviation_declaration.ad_tag = tag_encode "DW_TAG_const_type" then
    CT_const cupdie mtyp

  else if die.die_abbreviation_declaration.ad_tag = tag_encode "DW_TAG_volatile_type" then
(*    CT_volatile cupdie (strict s mtyp')*)
    (* TODO: this is a temporary hack, while we figure out what DW_TAG_volatile without a DW_AT_type is supposed to mean *)
    match mtyp with
    | Just typ -> CT_volatile cupdie typ
    | Nothing -> CT_missing cupdie
    end 


  else if die.die_abbreviation_declaration.ad_tag = tag_encode "DW_TAG_restrict_type" then
    CT_restrict cupdie  (strict s mtyp)
      
  else if die.die_abbreviation_declaration.ad_tag = tag_encode "DW_TAG_typedef" then
    let decl =
      <|
      decl_file = Nothing; (* TODO *)
      decl_line = Nothing; (* TODO *)
      |> in 
    CT_typedef cupdie (strict s mname) (strict s mtyp) decl

  else if die.die_abbreviation_declaration.ad_tag = tag_encode "DW_TAG_array_type" then
    let dims =
      let subranges = List.filter (fun die' -> die'.die_abbreviation_declaration.ad_tag = tag_encode "DW_TAG_subrange_type") die.die_children in
      List.map
        (fun die' ->
          (*WAS: let mcount = find_natural_attribute_value_of_die c "DW_AT_count" die' in*)
          let mcount =
            match find_attribute_value "DW_AT_count" die' with
            | Nothing -> Nothing
            | Just av ->
               match maybe_natural_of_constant_attribute_value die' c av with
               | Nothing -> Nothing
               (* DWARF seems to sometimes use an AV_ref* attribute value for DW_AT_count, referring to a variable die, for a VLA length. In this case for the moment we will just forget the length information, which is what this clause does *) 
               | Just n -> Just n
               end
            end in         
          let msubrange_type = find_DW_AT_type_of_die c d cu d.d_str die' in
          (mcount, msubrange_type))
        subranges in 
    CT_array cupdie (strict s mtyp) dims

  else if die.die_abbreviation_declaration.ad_tag = tag_encode "DW_TAG_structure_type" || die.die_abbreviation_declaration.ad_tag = tag_encode "DW_TAG_union_type" then
    let atk = if die.die_abbreviation_declaration.ad_tag = tag_encode "DW_TAG_structure_type" then Atk_structure else Atk_union in
    let mbyte_size = find_natural_attribute_value_of_die c "DW_AT_byte_size" die in
    let decl =
      (<|
      decl_file = Nothing; (* TODO *)
      decl_line = Nothing; (* TODO *)
      |>) in 

    let members =
      if r then 
        let members_raw = List.filter (fun die' -> die'.die_abbreviation_declaration.ad_tag = tag_encode "DW_TAG_member") die.die_children in
        Just (List.map
          (fun die' ->
            let cupdie' = (cu,die::parents,die') in
            let mname' = find_name_of_die d.d_str die' in
            let typ' = strict s (find_DW_AT_type_of_die c d cu d.d_str die') in
            let mdata_member_location' =
              match atk with
              | Atk_structure -> Just (strict s (find_natural_attribute_value_of_die c "DW_AT_data_member_location" die'))
              | Atk_union -> (find_natural_attribute_value_of_die c "DW_AT_data_member_location" die') 
              end in 
            (cupdie',mname',typ',mdata_member_location'))
          members_raw)
      else
        Nothing in 

    CT_struct_union cupdie atk mname mbyte_size decl members

  else if die.die_abbreviation_declaration.ad_tag = tag_encode "DW_TAG_enumeration_type" then
    let mbyte_size = find_natural_attribute_value_of_die c "DW_AT_byte_size" die in
    let decl =
      <|
      decl_file = Nothing; (* TODO *)
      decl_line = Nothing; (* TODO *)
      |> in 
    let members =
      if r then
        let members_raw = List.filter (fun die' -> die'.die_abbreviation_declaration.ad_tag = tag_encode "DW_TAG_enumerator") die.die_children in
        Just (List.map
                (fun die' ->
                  let cupdie' = (cu,die::parents,die') in
                  let mname' = find_name_of_die d.d_str die' in
                  (*let _ = my_debug5 (s ()) in *)
                 let const_value = strict s (find_integer_attribute_value_of_die c "DW_AT_const_value" die') in (*let _ = my_debug5 "ok" in*)
                  (cupdie',mname',const_value))
                members_raw)
      else
        Nothing
    in
    
    CT_enumeration cupdie mname mtyp mbyte_size decl members

  else if die.die_abbreviation_declaration.ad_tag = tag_encode "DW_TAG_subroutine_type" then

  (*    let prototyped = strict s (find_flag_attribute_value_of_die "DW_AT_prototyped" die) in*)
    let prototyped = find_flag_attribute_value_of_die_default_false "DW_AT_prototyped" die in
    
    let mresult_type = mtyp in 
    
    let parameter_types = 
      let parameter_types_raw = List.filter (fun die' -> die'.die_abbreviation_declaration.ad_tag = tag_encode "DW_TAG_formal_parameter") die.die_children in
      (List.map
         (fun die' ->
           let cupdie' = (cu,die::parents,die') in
           let mname' = find_name_of_die d.d_str die' in
           let typ' = strict s (find_DW_AT_type_of_die c d cu d.d_str die') in
           typ')
         parameter_types_raw) in

    let (variable_parameter_list: bool) = List.any (fun die' -> die'.die_abbreviation_declaration.ad_tag = tag_encode "DW_TAG_unspecified_parameters") die.die_children in

    CT_subroutine cupdie prototyped mresult_type parameter_types variable_parameter_list

  else 
    
    Assert_extra.failwith ("analyse_type_info_top didn't recognise tag: " ^ pphex die.die_abbreviation_declaration.ad_tag ^ " for DIE " ^ pp_cupdie3 cupdie)


let rec analyse_type_info_deep (d: dwarf) (r:bool(*recurse_into_members*)) cupdie : c_type = 
  let c = p_context_of_d d in
  let (cu,parents,die) = cupdie in
  let (typ:c_type_top cupdie) = analyse_type_info_top c (d: dwarf) r cupdie in
  match typ with
  | CT_missing cupdie -> CT (CT_missing cupdie)
  | CT_base cupdie name encoding mbyte_size -> CT (CT_base cupdie name encoding mbyte_size) 
  | CT_pointer cupdie mtyp'  -> CT (CT_pointer cupdie (Maybe.map (analyse_type_info_deep d r) mtyp'))
  | CT_const cupdie mtyp'    -> CT (CT_const cupdie (Maybe.map (analyse_type_info_deep d r) mtyp'))
  | CT_volatile cupdie typ' ->  CT (CT_volatile cupdie (analyse_type_info_deep d r typ'))
  | CT_restrict cupdie typ' -> CT (CT_restrict cupdie (analyse_type_info_deep d r typ'))
  | CT_typedef cupdie name typ' decl -> CT (CT_typedef cupdie name (analyse_type_info_deep d r typ') decl)
  | CT_array cupdie typ' dims -> CT (CT_array cupdie (analyse_type_info_deep d r typ') 
     (List.map (fun (mcount,msubrange_typ) -> (mcount, (Maybe.map (analyse_type_info_deep d r) msubrange_typ))) dims))
  | CT_struct_union cupdie atk mname mbyte_size decl mmembers ->
     CT (CT_struct_union cupdie atk mname mbyte_size decl (Maybe.map (fun members -> (List.map (fun ((cupdie,mname,typ,mdata_member_location) as am) -> (cupdie,mname,(analyse_type_info_deep d false typ),mdata_member_location))members)) mmembers))
  | CT_enumeration cupdie mname mtyp' mbyte_size decl mmembers ->
     CT(CT_enumeration cupdie mname (Maybe.map (analyse_type_info_deep d r) mtyp') mbyte_size decl mmembers)
  | CT_subroutine cupdie prototyped mresult_type parameter_types variable_parameter_list ->
     CT (CT_subroutine cupdie prototyped (Maybe.map (analyse_type_info_deep d r) mresult_type) 
           (List.map (fun typ -> analyse_type_info_deep d r typ) parameter_types) variable_parameter_list)
  end

let find_DW_AT_type_of_die_deep d cupdie : maybe c_type =
  let c = p_context_of_d d in
  let (cu,parents,die) = cupdie in
  match find_reference_attribute_of_die c d cu d.d_str "DW_AT_type" die with
  | Nothing -> Nothing
  | Just cupdie' ->
     Just (analyse_type_info_deep d false cupdie')
  end

let find_DW_AT_type_of_die_deep_using_abstract_origin d cupdie : maybe c_type =
  let c = p_context_of_d d in
  let (cu,parents,die) = cupdie in
  match find_reference_attribute_using_abstract_origin c d cu d.d_str "DW_AT_type" die with
  | Nothing -> Nothing
  | Just cupdie' ->
     Just (analyse_type_info_deep d false cupdie')
  end
   
  
(* analyse and pp C type structure, but without going into the definitions of struct_union or enumeration types *)
let pp_struct_union_type_kind atk =
  match atk with
  | Atk_structure -> "struct"
  | Atk_union -> "union"
  end

let pp_mbyte_size mbyte_size = "size:" ^ match mbyte_size with | Just n -> show n | Nothing -> "?" end

(* pp the top-level structure of a C type, omitting struct_union-type and enum member definitions*)   
let pp_type_info_top (ppa:'a->string) (typ:c_type_top 'a) : string = 
  match typ with
  | CT_missing cupdie -> "missing at " ^ pp_cupdie cupdie 
  | CT_base cupdie name encoding mbyte_size -> 
     name ^ " (base type, " ^ match lookup_aB_a encoding base_type_attribute_encodings with Just s -> s | Nothing -> show encoding end ^ " " ^ pp_mbyte_size mbyte_size ^ ")"
  | CT_pointer cupdie mtyp'  -> "pointer("  ^ match mtyp' with | Just typ' -> ppa typ' | Nothing -> "no type" end ^ ")"
  | CT_const cupdie mtyp'    -> "const("    ^ match mtyp' with Just typ'->ppa typ' | Nothing -> "no type" end ^ ")"
  | CT_volatile cupdie typ' -> "volatile(" ^ ppa typ' ^ ")"
  | CT_restrict cupdie typ' -> "restrict(" ^ ppa typ' ^ ")"
  | CT_typedef cupdie name typ' decl -> "typedef("^name^"="^ppa typ' ^ ")"
  | CT_array cupdie typ' dims ->
     ppa typ' ^ String.concat "" (List.map (fun (mcount,msubrange_typ) -> "["^match mcount with | Just count -> show count | Nothing -> "no count" end ^"]") dims)
  | CT_struct_union cupdie atk mname mbyte_size decl mmembers -> pp_struct_union_type_kind atk ^ " " ^ (match mname with | Just s -> s | Nothing -> "noname" end) ^ pp_cupdie cupdie
  | CT_enumeration cupdie mname mtyp' mbyte_size decl mmembers -> "enum" ^ " " ^ (match mname with | Just s -> s | Nothing -> "noname" end) ^ pp_cupdie cupdie
  | CT_subroutine cupdie prototyped mresult_type parameter_types variable_parameter_list  ->
     "subroutine(" ^ (if prototyped then "prototyped" else "not-prototyped") ^ " " ^ (match mresult_type with Nothing -> "no type" | Just result_type -> ppa result_type end) ^ "(" ^ String.concat "," ((List.map ppa parameter_types) ++ (if variable_parameter_list then ["..."] else [])) ^ ")"
  end


let rec pp_type_info_deep (ctyp:c_type) : string = 
  let ppa = pp_type_info_deep in
  match ctyp with
  | CT typ -> 
     pp_type_info_top ppa typ
  end

let rec pp_type_info_die c (d: dwarf) cupdie : string = 
  let (typ:c_type_top cupdie) = analyse_type_info_top c (d: dwarf) false cupdie in
  let ppa = pp_type_info_die c d in
  pp_type_info_top ppa typ

   
let pp_struct_union_type_member c d (am:struct_union_member cupdie) : list string = 
  let (cupdie,mname,typ,mdata_member_location) = am in 
      [ "  ";
        (match mname with | Just s -> s | Nothing -> "noname" end);
        " @ " ^ (match mdata_member_location with Nothing -> "nodatamemberlocation" | Just data_member_location -> show data_member_location end);
        " : " ^ pp_type_info_die c d typ
      ]

let pp_struct_union_type_defn c d cupdie =
  let (typ:c_type_top cupdie) = analyse_type_info_top c (d: dwarf) true cupdie in
  match typ with 
  | CT_struct_union cupdie atk mname mbyte_size decl mmembers -> 
     (match mname with | Just s -> s | Nothing -> "noname" end) 
     ^ " " ^ pp_cupdie cupdie
     ^ " " ^ pp_mbyte_size mbyte_size ^ "\n"
     ^ pad_rows (match mmembers with Just members -> (List.map (pp_struct_union_type_member c d) members) | Nothing -> [] end)
  | _ ->
    Assert_extra.failwith "pp_struct_union_type_defn called on non-struct_union"
  end


let pp_struct_union_type_member' (am:struct_union_member c_type) : list string = 
  let (cupdie,mname,ctyp,mdata_member_location) = am in 
      [ "  ";
        (match mname with | Just s -> s | Nothing -> "noname" end);
        " @ " ^ (match mdata_member_location with Nothing -> "nodatamemberlocation" | Just data_member_location -> show data_member_location end);
        " : " ^ pp_type_info_deep ctyp
      ]

let pp_enum_type_member' (em:enumeration_member) : list string = 
  let (cupdie,mname,const_value) = em in 
      [ "  ";
        (match mname with | Just s -> s | Nothing -> "noname" end);
        " = " ^ show const_value
      ]
    
let pp_struct_union_type_defn' (ctyp: c_type) :string =
  let preamble mname kind cupdie mbyte_size = 
    (match mname with | Just s -> s | Nothing -> "noname" end) 
    ^ " " ^ kind
    ^ " " ^ pp_cupdie cupdie
    ^ " " ^ pp_mbyte_size mbyte_size in
  match ctyp with 
  | CT(CT_struct_union cupdie atk mname mbyte_size decl mmembers) -> 
     preamble mname (pp_struct_union_type_kind atk) cupdie mbyte_size ^ "\n" 
     ^ pad_rows (match mmembers with Just members -> (List.map (pp_struct_union_type_member') members) | Nothing -> [["warning: no members list"]] end)
  | CT(CT_enumeration cupdie mname mtyp mbyte_size decl mmembers) ->
     preamble mname "enum" cupdie mbyte_size
     ^ " " ^ (match mtyp with Just typ -> pp_type_info_deep typ | Nothing -> "no representation type" end)
     ^ "\n"
     ^ pad_rows (match mmembers with Just members -> (List.map (pp_enum_type_member') members) | Nothing -> [["warning: no members list"]] end)
  | _ ->
    Assert_extra.failwith "pp_struct_union_type_defn called on non-struct_union"
  end

   
   
(*
  match typ with
  | CT_base cupdie name encoding mbyte_size -> 
     name ^ " (base type, " ^ match lookup_aB_a encoding base_type_attribute_encodings with Just s -> s | Nothing -> show encoding end ^ " " ^ pp_mbyte_size mbyte_size ^ ")"
  | CT_pointer cupdie mtyp'  -> "pointer("  ^ match mtyp' with | Just typ' -> pp_type_info_die c d typ' | Nothing -> "no type" end ^ ")"
  | CT_const cupdie mtyp'    -> "const("    ^ match mtyp' with Just typ'->pp_type_info_die c d typ' | Nothing -> "no type" end ^ ")"
  | CT_volatile cupdie typ' -> "volatile(" ^ pp_type_info_die c d typ' ^ ")"
  | CT_restrict cupdie typ' -> "restrict(" ^ pp_type_info_die c d typ' ^ ")"
  | CT_typedef cupdie name typ' decl -> "typedef("^name^"="^pp_type_info_die c d typ' ^ ")"
  | CT_array cupdie typ' dims ->
     pp_type_info_die c d typ' ^ String.concat "" (List.map (fun (mcount,subrange_typ) -> "["^match mcount with | Just count -> show count | Nothing -> "no count" end ^"]") dims)
  | CT_struct_union cupdie atk mname mbyte_size decl members -> pp_struct_union_type_kind atk ^ " " ^ (match mname with | Just s -> s | Nothing -> "noname" end) ^ pp_cupdie cupdie
  | CT_enumeration cupdie mname mtyp' mbyte_size decl members -> "enum" ^ " " ^ (match mname with | Just s -> s | Nothing -> "noname" end) ^ pp_cupdie cupdie
  end
 *)
   
    
(* expect the die to have a DW_AT_type, and pp it *)

let pp_type_info_die_DW_AT_type c (d: dwarf) cu str die =    
  match find_DW_AT_type_of_die_using_abstract_origin c d cu str die with
  | Just (cu',parents',die') -> pp_type_info_die c (d: dwarf) (cu',parents',die')
  | Nothing -> "DW_AT_abstract origin failed"
  end 

  
                 
let struct_union_enum_types (d:dwarf) : list c_type =
  let cupdies = find_dies (fun die -> List.elem die.die_abbreviation_declaration.ad_tag [tag_encode "DW_TAG_structure_type"; tag_encode "DW_TAG_union_type"; tag_encode "DW_TAG_enumeration_type"]) d in
  List.map (analyse_type_info_deep (d: dwarf) true) cupdies


(*  
let pp_all_struct_union_enum_types c d : string =
  String.concat "\n\n" (List.map ((fun (cu,parents,die) -> pp_struct_union_type_defn c d (cu,parents,die))) (struct_union_type_dies d))
 *)
  
let pp_all_struct_union_enum_types' d : string =
  let ctyps : list c_type = struct_union_enum_types d in
  String.concat "" ((List.map   pp_struct_union_type_defn') ctyps)
    


   
(** ************************************************************ *)
(** **  analysis of location and frame data for reverse mapping  *)
(** ************************************************************ *)

(** analysis *)

(** simple-minded analysis of location *)

let analyse_locations_raw c (d: dwarf) =

  let (cuh_default : compilation_unit_header) = let cu = myhead d.d_compilation_units in cu.cu_header in

  (* find all DW_TAG_variable and DW_TAG_formal_parameter dies with a DW_AT_name attribute *)
  let tags = List.map tag_encode ["DW_TAG_variable"; "DW_TAG_formal_parameter"] in
  let dies : list (compilation_unit * (list die) * die) =
    find_dies
      (fun die ->
        List.elem die.die_abbreviation_declaration.ad_tag tags
          && has_attribute "DW_AT_name" die)
      d in

  String.concat ""
    (List.map
       (fun (cu,parents,die) ->

         let ats = List.zip
             die.die_abbreviation_declaration.ad_attribute_specifications
             die.die_attribute_values in

         let find_ats (s:string) = myfindNonPure (fun  (((at: natural), (af: natural)), ((pos: natural),(av:attribute_value))) -> attribute_encode s = at) ats in

         let ((_,_),(_,av_name)) = find_ats "DW_AT_name" in

         let name =
           match av_name with
           | AV_string bs -> string_of_byte_sequence bs
           | AV_strp n -> pp_debug_str_entry d.d_str n
           | _ -> "av_name AV not understood"
           end in


         let ((_,_),(_,av_location)) = find_ats "DW_AT_location" in

         let ppd_location =
           match av_location with
           | AV_exprloc n bs -> "    "^parse_and_pp_operations c cuh_default bs^"\n"
           | AV_block n bs -> "    "^parse_and_pp_operations c cuh_default bs^"\n"
           | AV_sec_offset n ->
               let location_list = myfindNonPure (fun (n',_)-> n'=n) d.d_loc in
               pp_location_list c cuh_default location_list
           | _ -> "av_location AV not understood"
           end in

         pp_tag_encoding die.die_abbreviation_declaration.ad_tag ^ " " ^ name ^ ":\n" ^ ppd_location ^ "\n" )

       dies)


(** more proper analysis of locations *)

(*  TODO: handle this:
In a variable entry representing the definition of a variable (that is, with no
DW_AT_declaration attribute) if no location attribute is present, or if the location attribute is
present but has an empty location description (as described in Section 2.6), the variable is
assumed to exist in the source code but not in the executable program (but see number 10,
below).
In a variable entry representing a non-defining declaration of a variable, the location
specified modifies the location specified by the defining declaration and only applies for the
scope of the variable entry; if no location is specified, then the location specified in the
defining declaration applies.
The location of a variable may be further specified with a DW_AT_segment attribute, if
appropriate.
*)


(*
if there's a DW_AT_location that's a location list (DW_FORM_sec_offset/AV_sec_offset) : use that for both the range(s) and location; interpret the range(s) wrt the applicable base address of the compilation unit

if there's a DW_AT_location that's a location expression (DW_FORM_exprloc/AV_exprloc or DW_block/AV_block), look for the closest enclosing range:
 - DW_AT_low_pc (AV_addr) and no DW_AT_high_pc or DW_AT_ranges: just the singleton address
 - DW_AT_low_pc (AV_addr) and DW_AT_high_pc (either an absolute AV_addr or an offset AV_constantN/AV_constant_SLEB128/AV_constantULEB128) : that range
 - DW_AT_ranges (DW_FORM_sec_offset/AV_sec_offset) : get a range list from .debug_ranges; interpret wrt the applicable base address of the compilation unit
 - for compilation units: a DW_AT_ranges together with a DW_AT_low_pc to specify the default base address to use in interpeting location and range lists

DW_OP_fbreg in location expressions evaluate the DW_AT_frame_base of
the closest enclosing function - which is either a location expression
or a location list (what happens if the ranges of that location list
don't cover where we are?)

For each variable and formal parameter that has a DW_AT_name, we'll calculate a list of pairs of a concrete (low,high) range and a location expression.
*)
let cu_base_address cu =
  match find_attribute_value "DW_AT_low_pc" cu.cu_die with
  | Just (AV_addr n) -> n
  | _ -> 0 (*Nothing*) (*Assert_extra.failwith "no cu DW_AT_low_pc"*)
  end


    
let range_of_die c cuh str (dranges: range_list_list) (cu_base_address: natural) (die: die) : maybe (list (natural * natural)) =
  match (find_attribute_value "DW_AT_low_pc" die, find_attribute_value "DW_AT_high_pc" die, find_attribute_value "DW_AT_ranges" die) with
  | (Just (AV_addr n),  Nothing,                       Nothing               ) -> Just [(n,n+1)]   (* unclear if this case is used? *)
  | (Just (AV_addr n1), Just (AV_addr n2),             Nothing               ) -> Just [(n1,n2)]
  | (Just (AV_addr n1), Just (AV_constant_ULEB128 n2), Nothing               ) -> Just [(n1, n1+n2)] (* should be mod all? *)
  | (Just (AV_addr n1), Just (AV_constant_SLEB128 i2), Nothing               ) -> Just [(n1, naturalFromInteger (integerFromNatural n1 + i2))] (* should be mod all? *)
  | (Just (AV_addr n1), Just (AV_constantN _ _),       Nothing               ) -> Assert_extra.failwith "AV_constantN in range_of_die"
        
  | (Just (AV_addr n1), Just (AV_block n bs),          Nothing               ) -> let n2 = natural_of_bytes c.endianness bs in Just [(n1, n1+n2)] (* should be mod all? *) (* signed or unsigned interp? *)
  | (_,                 Nothing,                       Just (AV_sec_offset n)) ->
      let rlis = Tuple.snd (match find_range_list dranges n with Just rlis->rlis | None -> Assert_extra.failwith ("find_range_list failed on AV_sec_offset n=" ^ show n ^ " for die\n" ^ pp_die c cuh str false 0 false die) end) in
      let nns = interpret_range_list cu_base_address rlis in
      Just nns
  | (Nothing,           Nothing,                       Nothing               ) -> Nothing
  | (_,                 _,                             _                     ) -> Just [] (*Assert_extra.failwith "unexpected attribute values in closest_enclosing_range"*)
end

let range_of_die_d (d:dwarf) cu (die: die) : maybe (list (natural * natural)) =
  let c = p_context_of_d d in
  range_of_die c cu.cu_header d.d_str d.d_ranges (cu_base_address cu) die     

let entry_address (die:die) : maybe natural =
  match (find_attribute_value "DW_AT_low_pc" die, find_attribute_value "DW_AT_entry_pc" die) with
  | (_, Just (AV_addr n)) -> Just n
  | (Just (AV_addr n), _) -> Just n    
  | (Nothing,Nothing) -> Nothing
  end                       
                                 
let rec closest_enclosing_range c cuh str (dranges: range_list_list) (cu_base_address: natural) (parents: list die) : maybe (list (natural * natural)) =
  match parents with
  | [] -> Nothing
  | die::parents' ->
      match range_of_die c cuh str dranges cu_base_address die with
      | ((Just x) as y) -> y
      | Nothing ->
          closest_enclosing_range c cuh str dranges cu_base_address parents'        
      end
  end

(*
If one of the DW_FORM_data<n> forms is used to represent a signed or unsigned integer, it
can be hard for a consumer to discover the context necessary to determine which
interpretation is intended. Producers are therefore strongly encouraged to use
DW_FORM_sdata or DW_FORM_udata for signed and unsigned integers respectively,
rather than DW_FORM_data<n>.
no kidding - if we get an AV_constantN for DW_AT_high_pc, should it be interpreted as signed or unsigned? *)


let rec closest_enclosing_frame_base dloc (base_address: natural) (parents: list die) : maybe attribute_value =
  match parents with
  | [] -> Nothing
  | die::parents' ->
      match find_attribute_value "DW_AT_frame_base" die with
      | Just av -> Just av
      | Nothing -> closest_enclosing_frame_base dloc base_address parents'
      end
  end




let interpreted_location_of_die c cuh str (dloc: location_list_list) (dranges: range_list_list) (base_address: natural) (parents: list die) (die: die) : maybe (list (natural * natural * single_location_description)) =

  (* for a simple location expression bs, we look in the enclosing die
  tree to find the associated pc range *)
  let location bs =
    match closest_enclosing_range c cuh str dranges base_address (die::parents) with
    | Just nns ->
        Just (List.map (fun (n1,n2) -> (n1,n2,bs)) nns)
    | Nothing ->
        (* if there is no such range, we take the full 0 - 0xfff.fff range*)
        Just [(0,(arithmetic_context_of_cuh cuh).ac_max,bs)]
    end in

  match find_attribute_value "DW_AT_location" die with
  | Just (AV_exprloc n bs) -> location bs
  | Just (AV_block n bs) -> location bs
  (* while for a location list, we take the associated pc range from
  each element of the list *)
  | Just (AV_sec_offset n) ->
      let (_,llis) = find_location_list dloc n in
      Just (interpret_location_list base_address llis)
  | Nothing -> Nothing
  end



val analyse_locations : dwarf -> analysed_location_data
let analyse_locations (d: dwarf) : analysed_location_data =

  let c = p_context_of_d d in

  (*  let (cuh_default : compilation_unit_header) = let cu = myhead d.d_compilation_units in cu.cu_header in*)

  (* find all DW_TAG_variable and DW_TAG_formal_parameter dies with a DW_AT_location attribute and either a DW_AT_name or a DW_abstract_origin *)
  (* (leaving formal parameters of inlined routines with a DW_AT_const_value to the future) *)
  let tags = List.map tag_encode ["DW_TAG_variable"; "DW_TAG_formal_parameter"] in
  let dies : list (compilation_unit * (list die) * die) =
    find_dies
      (fun die ->
        List.elem die.die_abbreviation_declaration.ad_tag tags
          && (has_attribute "DW_AT_name" die || has_attribute "DW_AT_abstract_origin" die)
          && has_attribute "DW_AT_location" die)
      d in

  List.map
    (fun (((cu:compilation_unit), (parents: list die), (die: die)) as x) ->
      let base_address = cu_base_address cu in
      let interpreted_locations : maybe (list (natural * natural * single_location_description)) =
        interpreted_location_of_die c cu.cu_header d.d_str d.d_loc d.d_ranges base_address parents die in
      (x,interpreted_locations)
    )
    dies



let pp_analysed_locations1 c cuh (nnls: list (natural * natural * single_location_description)) : string =
  String.concat ""
    (List.map
       (fun (n1,n2,bs) -> "  " ^ pphex n1 ^ "  " ^ pphex n2 ^ " " ^ parse_and_pp_operations c cuh bs)
       nnls)

let pp_analysed_locations2 c cuh mnnls =
  match mnnls with
  | Just nnls -> pp_analysed_locations1 c cuh nnls
  | Nothing -> "  <no locations>"
  end


(*   
let pp_analysed_locations3 c d str (als: analysed_location_data) : string =
  pad_rows 
    (List.map
       (fun ((cu,parents,die),mnnls) ->
         [" ";pp_die_abbrev_var c cu.cu_header str 0 false parents die
          ^ pp_type_info_die_DW_AT_type c d cu cu.cu_header str die;
          pp_analysed_locations2 c cu.cu_header mnnls]
       )
       als
    )

let pp_analysed_location_data (d: dwarf) (als: analysed_location_data) : string =
  let c = p_context_of_d d in
(*  let cu = myhead d.d_compilation_units in 
  let (cuh_default : compilation_unit_header) = cu.cu_header in
 *)
  pp_analysed_locations3 c (*HACK*) d d.d_str als
 *)


let pp_analysed_locations3 c d str (removed:bool) (als: analysed_location_data) : list (bool(*removed?*) * (string(*name*) * string(*offset*) * string(*kind*)) * (unit->string)(*string*)(*type*) * string(*locations*) * (unit->string)(*parents*)) = 
  List.map
    (fun ((cu,parents,die1),mnnls) ->
      (removed,
       pp_die_abbrev_var c d cu str false parents die1, (*4.5s for only this*)
       (fun () -> pp_type_info_die_DW_AT_type c d cu str die1), (*12.2s for this and above*)
       pp_analysed_locations2 c cu.cu_header mnnls, (*12.4s for this and above*)
       (fun () -> pp_die_abbrev_var_parents c d cu str parents)) (*14.4s for this and above*)
    )
    als

let pp_analysed_locations3_diff c d str (als_old: analysed_location_data) (als_new: analysed_location_data) : list (bool(*removed?*) * (string(*name*) * string(*offset*) * string(*kind*)) * (unit->string)(*type*) * string(*locations*) *(unit->string)(*parents*)) = 
  (* maybe alpha sort these? *)
  let ppd_old = pp_analysed_locations3 c d str true als_old  in
  let ppd_new = pp_analysed_locations3 c d str false als_new in 

  (* the old entries that don't have a same-name new entry *)
  let ppd_gone = List.filter (fun (removed,(name,offset,kind),typ,locs,parents) -> not (List.any (fun (removed',(name',offset',kind'),typ',locs',parents') -> name=name') ppd_new)) ppd_old in

  (* the new entries, each preceded by any same-name old entries (this will display strangely if there's any variable shadowing...) *)
  let ppd_upd =
    List.concat
      (List.mapMaybe
         (fun ((removed,((name,offset,kind) as y),typ,locs,parents) as x) ->
           let same_name_old = (List.filter (fun (removed',(name',offset',kind'),typ',locs',parents') -> (name,offset)=(name',offset')) ppd_old) in
           match same_name_old with
           | [((removed',((name',offset',kind') as y'),typ',locs',parents') as x')] ->
              if (y,(*typ,*)locs) = (y',(*typ',*)locs') then 
                Nothing
              else
                Just (same_name_old ++ [x])
           | _ -> 
              Just (same_name_old ++ [x])
           end)
         ppd_new) in

  ppd_gone ++ ppd_upd

let pp_analysed_location_format (xs : list (bool(*removed?*) * (string(*name*) * string(*offset*) * string(*kind*)) * (unit->string)(*string*)(*type*) * string(*locations*) * (unit->string)(*parents*))) = 
  pad_rows 
    (List.map
       (fun ((removed,(name,offset,kind),typ,locs,parents) as x) ->
         [ (if removed then "-" else " ") ^ name
           ^ " (" ^ offset ^ "," ^ kind ^ ") "
           ^ typ ();
           locs;
           parents ()]
       )
       xs
    )

let pp_analysed_location_data (d: dwarf) (als: analysed_location_data) : string=
  let c = p_context_of_d d in
(*  let cu = myhead d.d_compilation_units in 
  let (cuh_default : compilation_unit_header) = cu.cu_header in
 *)
  pp_analysed_location_format (pp_analysed_locations3 c (*HACK*) d d.d_str false als)

let pp_analysed_location_data_diff (d: dwarf) (als_old: analysed_location_data) (als_new: analysed_location_data) : string=
  let c = p_context_of_d d in
(*  let cu = myhead d.d_compilation_units in 
  let (cuh_default : compilation_unit_header) = cu.cu_header in
 *)
  pp_analysed_location_format (pp_analysed_locations3_diff c (*HACK*) d d.d_str als_old als_new)
  


let pp_analysed_location_data_at_pc (d: dwarf) (alspc: analysed_location_data_at_pc) : string =
  String.concat "" (List.map
    (fun ((cu,parents,die),(n1,n2,sld,esl)) ->
      "          " ^
      let name =
        match find_name_of_die d.d_str die with
        | Just s ->  s
        | Nothing -> "<no name>\n"
        end in
      match esl with
      | Success sl ->
          name ^ " @ " ^ pp_single_location sl ^"\n"

      | Fail e -> name ^ " @ " ^ "<fail: " ^ e ^ ">\n"
      end
    )
    alspc)


  

val analysed_locations_at_pc : evaluation_context -> dwarf_static -> natural -> analysed_location_data_at_pc
let analysed_locations_at_pc
      (ev)
      (ds: dwarf_static)
      (pc: natural)
    : analysed_location_data_at_pc
  =
  let c : p_context = (<| endianness = ds.ds_dwarf.d_endianness |>) in
  
  let xs =
    List.mapMaybe
      (fun (cupd,mnns) ->
        match mnns with
        | Nothing -> Nothing
        | Just nns ->
            let nns' = List.filter (fun (n1,n2,sld) -> pc >= n1 && pc < n2) nns in
            match nns' with
            | [] -> Nothing
            | _ -> Just (cupd,nns')
            end
        end)
      ds.ds_analysed_location_data
  in
  
  List.concat
    (List.map
       (fun ((cu,parents,die),nns) ->
         let ac = arithmetic_context_of_cuh cu.cu_header in
         let base_address = cu_base_address cu in
         let mfbloc : maybe attribute_value =
           closest_enclosing_frame_base ds.ds_dwarf.d_loc base_address parents in
         List.map
           (fun (n1,n2,sld) ->
             let el : error single_location =
               evaluate_location_description_bytes c ds.ds_dwarf.d_loc ds.ds_evaluated_frame_info cu.cu_header ac ev mfbloc pc sld in
             ((cu,parents,die),(n1,n2,sld,el))
           )
           nns
       )
       xs)

val names_of_address : dwarf -> analysed_location_data_at_pc -> natural -> list string
let names_of_address
    (d: dwarf)
    (alspc: analysed_location_data_at_pc)
    (address: natural)
    : list string
    =
  List.mapMaybe
    (fun ((cu,parents,die),(n1,n2,sld,esl)) ->
      match esl with
      | Success (SL_simple (SL_memory_address a)) ->
          if a=address then
            match find_name_of_die d.d_str die with
            | Just s -> Just s
            | Nothing -> Nothing
            end
          else
            Nothing
      | Success _ ->  Nothing (* just suppress? *)
      | Fail e -> Nothing (* just suppress? *)
      end
    )
    alspc


val filtered_analysed_location_data : dwarf_static -> natural -> analysed_location_data
let filtered_analysed_location_data ds pc = 
  List.mapMaybe
    (fun (cupd,mnns) ->
      match mnns with
      | Nothing -> Nothing
      | Just nns ->
         let nns' = List.filter (fun (n1,n2,sld) -> pc >= n1 && pc < n2) nns in
         match nns' with
         | [] -> Nothing (*Just (cupd,Nothing)*)
         | _::_ -> Just (cupd,Just nns')
         end
     end)
    ds.ds_analysed_location_data

(** ********************************************************************** *)
(** **  estimate source-file line extents of each (non-inlined) subprogram *)
(** ********************************************************************** *)

(* The line number info associates source-file line numbers to
   instruction addresses, but doesn't identify which subprogram those
   line numbers come from.  To recover that, we can use the
   DW_TAG_subprogram die DW_AT_decl_file and DW_AT_decl_line info,
   which gives the start of each subprogram.  For C, function
   definitions cannot be nested, so we can estimate their line-number
   extents as from their start to the start of the next.  Note that
   this might be wrong if there are (eg) macro definitions between C
   functions. Because of the lack of nesting, for C, just taking the
   top-level DW_TAG_subprogram dies of each compilation unit should be
   basically ok, and seems also to exclude inlined instances of
   subprograms (which otherwise we could exclude by discarding any
   with an abstract origin). However, those top-level subprograms are
   not necessarily all from the "primary" file of the subprogram, and
   conceivably some functions in the file might not be included in
   that compilation unit but appear in another.  We'll therefore take
   all top-level subprograms from all compilation units, partition by
   file (up to equality of (compilation directory, include directory,
   and path)), and then sort.  This assumes that the directory and
   path strings from the line number info for different compilation
   units are nicely comparable.

   We also have to identify the compilation unit referred to by a line
   number file entry that's been reported from the line-number
   info. The DW_TAG_compile_unit DW_AT_name appears to be the path
   concatentation (inserting a "/", not just the string concatenation)
   of the lnfe_directory_index's string and the lnfe_path of one the
   lnfe's of the line number header pointed to by the compilation
   unit's DW_AT_stmt_list, but not necessarily any particular such
   lnfe.*)


  
let subprogram_line_extents_compilation_unit d cu : list (string * unpacked_file_entry * natural) =
  let c = p_context_of_d d in
  let subprogram_dies = List.filter (fun die' -> die'.die_abbreviation_declaration.ad_tag = tag_encode "DW_TAG_subprogram") cu.cu_die.die_children in

  let lnp = line_number_program_of_compilation_unit d cu in
  let lnh = lnp.lnp_header in

  List.mapMaybe
    (fun die -> 
      match (find_name_of_die d.d_str die,
             find_natural_attribute_value_of_die c "DW_AT_decl_file" die, 
             find_natural_attribute_value_of_die c "DW_AT_decl_line" die) with
      | (Just name, Just file, Just line) -> 
         Just (name, unpack_file_entry lnh file, line)
      | (_,_,_) ->
         Nothing
      end)
    subprogram_dies

(* lookup in an association list and also return the list with that entry (if any) removed *)
val extract : forall 'b 'c. Eq 'b => 'b -> list ('b * 'c) -> (maybe 'c) * list ('b * 'c)
let rec extract y yzs =
  match yzs with
  | [] -> (Nothing, [])
  | (y',z')::yzs' ->
     if y'=y then
       (Just z', yzs')
     else
       let (result,yzs'') = extract y yzs' in
       (result, (y',z')::yzs'')
  end

(* partition a list by the result of f, removing duplicates and sorting each partition by lt *)   
val partitionby: forall 'a 'b. Eq 'a , Eq 'b => ('a -> 'b) -> ('a -> 'a -> bool) -> list 'a -> list ('b * list 'a) -> list ('b * list 'a)
let rec partitionby f lt xs acc =
  match xs with
  | [] -> acc
  | x::xs' ->
     let y = f x in 
     let (result, acc') = extract y acc in
     let acc'' = 
       match result with
       | Just xs'' ->
          if List.elem x xs'' then acc else ((y, Sorting.insertBy lt x xs'')::acc')
       | Nothing ->
          (y,[x])::acc
       end in
     partitionby f lt xs' acc''
   end     
  
let subprogram_line_extents d : list (unpacked_file_entry * list (string * unpacked_file_entry * natural) ) =
  let subprograms : list (string * unpacked_file_entry * natural) = 
    List.concatMap (subprogram_line_extents_compilation_unit d) d.d_compilation_units in
  partitionby (fun (name, ufe, line) -> ufe) (fun (name,ufe,line) -> fun (name',ufe',line') -> line < line') subprograms []

let pp_subprograms sles = 
  String.concat "\n"
    (List.map 
       (fun (ufe,sles') ->
         pp_ufe ufe ^ "\n"
         ^ String.concat "" (List.map (fun (name, ufe, line) -> "  " ^ show line ^ "  " ^ name  ^ "\n") sles'))
       sles)

let rec find_by_line line sles line_last name_last =
  match sles with
  | [] -> name_last
  | (name',ufe',line') :: sles' ->
     if line >= line_last && line < line' then name_last else find_by_line line sles' line' name'
  end

let subprogram_at_line subprogram_line_extents (ufe:unpacked_file_entry) (line:natural) : string =
  match List.lookup ufe subprogram_line_extents with
  | Nothing -> "no matching unpacked_file_entry"
  | Just sles -> find_by_line line sles 0 "file preamble"
  end
     
  
  
  

(** ************************************************************ *)
(** **  pull out subprograms                                     *)
(** ************************************************************ *)
(*
val analyse_subprograms : dwarf -> analysed_location_data
let analyse_subprograms (d: dwarf) : analysed_location_data =

  let c = p_context_of_d d in

  let (cuh_default : compilation_unit_header) = let cu = myhead d.d_compilation_units in cu.cu_header in

  (* find all DW_TAG_subprogram dies *)
  let tags = List.map tag_encode ["DW_TAG_subprogram"] in
  let dies : list (compilation_unit * (list die) * die) =
    find_dies
      (fun die ->
        List.elem die.die_abbreviation_declaration.ad_tag tags
          && has_attribute "DW_AT_name" die
          && has_attribute "DW_AT_location" die)
      d in

  List.map
    (fun (((cu:compilation_unit), (parents: list die), (die: die)) as x) ->

      let name =
        match find_name_of_die d.d_str die with
        | Just s ->  s
        | Nothing -> "<no name>\n"
        end in

      let entry_point : maybe attribute_value =
        match find_attribute_value "DW_AT_entry_pc" die with
        | Nothing -> Nothing
        | 
       
     let base_address = cu_base_address cu in
      let interpreted_locations : maybe (list (natural * natural * single_location_description)) =
        interpreted_location_of_die c cuh_default d.d_loc d.d_ranges base_address parents die in
      (x,interpreted_locations)
    )
    dies
 *)

  
(** ************************************************************ *)
(** **  evaluation of line-number info                           *)
(** ************************************************************ *)

let initial_line_number_registers (lnh: line_number_header) : line_number_registers =
    <|
    lnr_address = 0;
    lnr_op_index = 0;
    lnr_file = 1;
    lnr_line = 1;
    lnr_column = 0;
    lnr_is_stmt = lnh.lnh_default_is_stmt;
    lnr_basic_block = false;
    lnr_end_sequence = false;
    lnr_prologue_end = false;
    lnr_epilogue_begin = false;
    lnr_isa = 0;
    lnr_discriminator =0;
  |>

let evaluate_line_number_operation
    (lnh: line_number_header)
    ((s: line_number_registers), (lnrs: list line_number_registers))
    (lno: line_number_operation)
    : line_number_registers * list line_number_registers =

  let new_address s operation_advance = (s.lnr_address +
      lnh.lnh_minimum_instruction_length *
         ((s.lnr_op_index + operation_advance)/lnh.lnh_maximum_operations_per_instruction)) mod (range_address 8) (* TODO: this should be taken from the compilation unit header address_size for DWARF<=4 or the line number header for DWARF5*)  in
  let new_op_index s operation_advance =
    (s.lnr_op_index + operation_advance) mod lnh.lnh_maximum_operations_per_instruction in

  match lno with
  | DW_LN_special adjusted_opcode ->
      let operation_advance = adjusted_opcode / lnh.lnh_line_range in
      let line_increment = lnh.lnh_line_base + integerFromNatural (adjusted_opcode mod lnh.lnh_line_range) in
      let s' =
        <| s with
         lnr_line = partialNaturalFromInteger ((integerFromNatural s.lnr_line) + line_increment);
         lnr_address = new_address s operation_advance;
         lnr_op_index = new_op_index s operation_advance;
      |> in
      let lnrs' = s'::lnrs in
      let s'' =
        <| s' with
           lnr_basic_block = false;
           lnr_prologue_end = false;
           lnr_epilogue_begin = false;
           lnr_discriminator = 0;
        |> in
      (s'', lnrs')
  | DW_LNS_copy                   ->
      let lnrs' = s::lnrs in
      let s' =
        <| s with
           lnr_basic_block = false;
           lnr_prologue_end = false;
           lnr_epilogue_begin = false;
           lnr_discriminator = 0;
        |> in
      (s', lnrs')
  | DW_LNS_advance_pc operation_advance ->
      let s' =
        <| s with
         lnr_address = new_address s operation_advance;
         lnr_op_index = new_op_index s operation_advance;
      |> in
      (s', lnrs)
  | DW_LNS_advance_line line_increment ->
      let s' = <| s with lnr_line = partialNaturalFromInteger ((integerFromNatural s.lnr_line) + line_increment) |> in (s', lnrs)
  | DW_LNS_set_file n             ->
      let s' = <| s with lnr_file = n |> in (s', lnrs)
  | DW_LNS_set_column n           ->
      let s' = <| s with lnr_column = n |> in (s', lnrs)
  | DW_LNS_negate_stmt            ->
      let s' = <| s with lnr_is_stmt = not s.lnr_is_stmt |> in (s', lnrs)
  | DW_LNS_set_basic_block        ->
      let s' = <| s with lnr_basic_block = true |> in (s', lnrs)
  | DW_LNS_const_add_pc           ->
      let opcode = 255 in
      let adjusted_opcode = opcode - lnh.lnh_opcode_base in
      let operation_advance = adjusted_opcode / lnh.lnh_line_range in
      let s' =
        <| s with
         lnr_address = new_address s operation_advance;
         lnr_op_index = new_op_index s operation_advance;
      |> in
      (s', lnrs)
  | DW_LNS_fixed_advance_pc n     ->
      let s' =
        <| s with
         lnr_address = s.lnr_address + n;
         lnr_op_index = 0;
      |> in
      (s', lnrs)
  | DW_LNS_set_prologue_end       ->
      let s' = <| s with lnr_prologue_end = true |> in (s', lnrs)
  | DW_LNS_set_epilogue_begin     ->
      let s' = <| s with lnr_epilogue_begin = true |> in (s', lnrs)
  | DW_LNS_set_isa n              ->
      let s' = <| s with lnr_isa = n |> in (s', lnrs)
  | DW_LNE_end_sequence           ->
      let s' = <| s with lnr_end_sequence = true |> in
      let lnrs' = s' :: lnrs in
      let s'' = initial_line_number_registers lnh in
      (s'', lnrs')
  | DW_LNE_set_address n          ->
      let s' =
        <| s with
         lnr_address = n;
         lnr_op_index = 0;
      |> in
      (s', lnrs)
  | DW_LNE_define_file s n1 n2 n3 ->
      Assert_extra.failwith "DW_LNE_define_file not implemented"  (*TODO: add to file list in header - but why is this in the spec? *)
  | DW_LNE_set_discriminator n    ->
      let s' = <| s with lnr_discriminator = n |> in (s', lnrs)
  end

let rec evaluate_line_number_operations
    (lnh: line_number_header)
    ((s: line_number_registers), (lnrs: list line_number_registers))
    (lnos: list line_number_operation)
    : line_number_registers * list line_number_registers =
  match lnos with
  | [] -> (s,lnrs)
  | lno :: lnos' ->
      let (s',lnrs') =
        evaluate_line_number_operation lnh (s,lnrs) lno in
      evaluate_line_number_operations lnh (s',lnrs') lnos'
  end

let evaluate_line_number_program
    (lnp:line_number_program)
    : list line_number_registers =
  List.reverse (Tuple.snd (evaluate_line_number_operations lnp.lnp_header ((initial_line_number_registers lnp.lnp_header),[]) lnp.lnp_operations))


let evaluated_line_info_of_compilation_unit d cu evaluated_line_info =
  let c = p_context_of_d d in
  let offset = line_number_offset_of_compilation_unit c cu in
  match List.find (fun (lnh,lnrs) -> lnh.lnh_offset = offset) evaluated_line_info with
  | Nothing -> Assert_extra.failwith "compilation unit line number offset not found"
  | Just (lnh,lnrs) ->lnrs
  end


let pp_line_number_registers lnr =
  ""
  ^ "address = " ^        pphex lnr.lnr_address       ^ "\n"
  ^ "op_index = " ^       show lnr.lnr_op_index       ^ "\n"
  ^ "file = " ^           show lnr.lnr_file           ^ "\n"
  ^ "line = " ^           show lnr.lnr_line           ^ "\n"
  ^ "column = " ^         show lnr.lnr_column         ^ "\n"
  ^ "is_stmt = " ^        show lnr.lnr_is_stmt        ^ "\n"
  ^ "basic_block = " ^    show lnr.lnr_basic_block    ^ "\n"
  ^ "end_sequence = " ^   show lnr.lnr_end_sequence   ^ "\n"
  ^ "prologue_end = " ^   show lnr.lnr_prologue_end   ^ "\n"
  ^ "epilogue_begin = " ^ show lnr.lnr_epilogue_begin ^ "\n"
  ^ "isa = " ^            show lnr.lnr_isa            ^ "\n"
  ^ "discriminator = " ^  pphex lnr.lnr_discriminator ^ "\n"

let pp_line_number_registers_tight lnr : list string =
  [
   pphex lnr.lnr_address       ;
   show lnr.lnr_op_index       ;
   show lnr.lnr_file           ;
   show lnr.lnr_line           ;
   show lnr.lnr_column         ;
   show lnr.lnr_is_stmt        ;
   show lnr.lnr_basic_block    ;
   show lnr.lnr_end_sequence   ;
   show lnr.lnr_prologue_end   ;
   show lnr.lnr_epilogue_begin ;
   show lnr.lnr_isa            ;
   pphex lnr.lnr_discriminator
 ]

let pp_line_number_registerss lnrs =
  pad_rows
    (
     ["address"; "op_index"; "file"; "line"; "column"; "is_stmt"; "basic_block"; "end_sequence"; "prologue_end"; "epilogue_begin"; "isa"; "discriminator"]
     ::
       (List.map pp_line_number_registers_tight lnrs)
    )

let pp_evaluated_line_info (eli: evaluated_line_info) : string =
  String.concat "\n" (List.map (fun (lnh,lnrs) -> pp_line_number_header lnh ^ "\n" ^ pp_line_number_registerss lnrs) eli)

(* readef example:
Decoded dump of debug contents of section .debug_line:

CU: /var/local/stephen/work/devel/rsem/ppcmem2/system/tests-adhoc/simple-malloc/test-concurrent.c:
File name                            Line number    Starting address
test-concurrent.c                             11            0x400144

test-concurrent.c                             12            0x40014c
test-concurrent.c                             13            0x400154
test-concurrent.c                             14            0x400158
test-concurrent.c                             17            0x400160

/var/local/stephen/work/devel/rsem/ppcmem2/system/tests-adhoc/simple-malloc/../thread_start_aarch64.h:
thread_start_aarch64.h                        34            0x400168
thread_start_aarch64.h                        36            0x400174

/var/local/stephen/work/devel/rsem/ppcmem2/system/tests-adhoc/simple-malloc/test-concurrent.c:
test-concurrent.c                             19            0x400174

test-concurrent.c                             20            0x40017c
test-concurrent.c                             22            0x400180

CU: /var/local/stephen/work/devel/rsem/ppcmem2/system/tests-adhoc/simple-malloc/malloc.c:
...
*)



let source_lines_of_address (ds:dwarf_static) (a: natural) : list ( unpacked_file_entry * natural * line_number_registers * string (*function*)) =
  List.concat
    (List.map
       (fun (lnh, lnrs) ->
         myfiltermaybe
           (fun lnr ->
             if a = lnr.lnr_address && not lnr.lnr_end_sequence then
               Just (unpack_file_entry lnh lnr.lnr_file, lnr.lnr_line, lnr, subprogram_at_line ds.ds_subprogram_line_extents (unpack_file_entry lnh lnr.lnr_file) lnr.lnr_line)
             else
               Nothing)
           lnrs
       )
    ds.ds_evaluated_line_info
    )



  
(** ************************************************************ *)
(** **  collecting all the statically calculated analysis info   *)
(** ************************************************************ *)

val extract_dwarf_static : elf_file -> maybe dwarf_static
let extract_dwarf_static f1 =
  match extract_dwarf f1 with
  | Nothing -> Nothing
  | Just dwarf ->
     (*let _ = my_debug5 (pp_dwarf dwarf) in *)

      let ald : analysed_location_data =
        analyse_locations dwarf in
      let efi : evaluated_frame_info =
        evaluate_frame_info dwarf in
      let eli : evaluated_line_info =
        List.map (fun lnp -> (lnp.lnp_header, evaluate_line_number_program lnp)) dwarf.d_line_info in
      let sle = subprogram_line_extents dwarf in
      let ds =
        <|
        ds_dwarf = dwarf;
        ds_analysed_location_data = ald;
        ds_evaluated_frame_info = efi;
        ds_evaluated_line_info = eli;
        ds_subprogram_line_extents = sle;
        |> in
      Just ds
  end



(** ************************************************************ *)
(** **  collect simple die tree view                             *)
(** ************************************************************ *)

let decl_of_die d subprogram_line_extents cu die : maybe (unpacked_file_entry * nat (*line*)  * string (*subprogram name*)) = 
  let c = p_context_of_d d in
  let lnp = line_number_program_of_compilation_unit d cu in
  let lnh = lnp.lnp_header in
  match (find_natural_attribute_value_of_die c "DW_AT_decl_file" die, 
            find_natural_attribute_value_of_die c "DW_AT_decl_line" die) with
  | (Just file, Just line) -> 
     let ufe = unpack_file_entry lnh file in
     let subprogram_name = subprogram_at_line subprogram_line_extents ufe line in 
     Just (ufe, natFromNatural line, subprogram_name)
  | (_,_) ->
     Nothing
  end

let call_site_of_die d subprogram_line_extents cu die : maybe (unpacked_file_entry * nat (*line*) * string (*subprogram name*)) = 
  let c = p_context_of_d d in
  let lnp = line_number_program_of_compilation_unit d cu in
  let lnh = lnp.lnp_header in
  match (find_natural_attribute_value_of_die c "DW_AT_call_file" die, 
            find_natural_attribute_value_of_die c "DW_AT_call_line" die) with
  | (Just file, Just line) -> 
     let ufe = unpack_file_entry lnh file in
     let subprogram_name = subprogram_at_line subprogram_line_extents ufe line in 
     Just (ufe, natFromNatural line, subprogram_name)
  | (_,_) ->
     Nothing
  end

   
let mk_sdt_unspecified_parameter (d:dwarf) subprogram_line_extents cu parents die : maybe sdt_unspecified_parameter =
  if not(List.elem die.die_abbreviation_declaration.ad_tag [tag_encode "DW_TAG_unspecified_parameters"])
  then Nothing
  else Just ()

   
(*
let strict_msvfp x e s z =
  match x with
  | Just y -> y
  | Nothing ->
     Assert_extra.failwith ("mk_sdt_variable_or_formal_parameter strict failure " ^ e ^ " on \n" ^ s z ^ "\n")
  end
 *)
let rec mk_sdt_variable_or_formal_parameter (d:dwarf) subprogram_line_extents cu parents die : maybe sdt_variable_or_formal_parameter =
  if not(List.elem die.die_abbreviation_declaration.ad_tag [tag_encode "DW_TAG_variable"; tag_encode "DW_TAG_formal_parameter"])
  then Nothing
  else

    let c = p_context_of_d d in
    (*    let s (cu,parents,die) = pp_die c cu.cu_header d.d_str true 0 false die in*)

    let cupdie = (cu,parents,die) in
    let kind = if die.die_abbreviation_declaration.ad_tag = tag_encode "DW_TAG_variable" then  SVPK_var else if die.die_abbreviation_declaration.ad_tag = tag_encode "DW_TAG_formal_parameter" then SVPK_param else Assert_extra.failwith ("unreachable bad kind") in

    (* find aDW_AT_specification die, if it exists. TODO: how should this interact with abstract origins? *)
    let mcupdie_spec = find_reference_attribute_of_die c d cu d.d_str "DW_AT_specification" die in
    
    Just (
    <|
    svfp_cupdie = cupdie;
    svfp_kind = kind;
    (*    svfp_name = strict_msvfp (find_name_of_die_using_abstract_origin_and_spec c d cu d.d_str die mcupdie_spec) "no name" s cupdie;*)
    svfp_name = match (find_name_of_die_using_abstract_origin_and_spec c d cu d.d_str die mcupdie_spec) with Just name -> name | Nothing -> "no name" end;
    svfp_type =  (*strict_msvfp*) (find_DW_AT_type_of_die_deep_using_abstract_origin d cupdie) (*"no type" s cupdie*);
    svfp_abstract_origin =
      match find_reference_attribute_of_die c d cu d.d_str "DW_AT_abstract_origin" die with
      | Nothing ->
         Nothing 
      | Just ((cu',parents',die') as cupdie') ->
         mk_sdt_variable_or_formal_parameter d subprogram_line_extents cu' parents' die'
    end;
    svfp_const_value = find_integer_attribute_value_of_die c "DW_AT_const_value" die;
    svfp_external = match find_flag_attribute_value_of_die_using_abstract_origin d "DW_AT_external" cupdie with Just b -> b | Nothing -> false end;
    svfp_declaration = match find_flag_attribute_value_of_die_using_abstract_origin d "DW_AT_declaration" cupdie with Just b -> b | Nothing -> false end;
    svfp_locations =
      let base_address = cu_base_address cu in
      let interpreted_locations : maybe (list (natural * natural * single_location_description)) =
        interpreted_location_of_die c cu.cu_header d.d_str d.d_loc d.d_ranges base_address parents die in
      Maybe.map (fun nnbss -> List.map (fun (n1,n2,bs) -> (n1,n2,parse_operations_bs c cu.cu_header bs)) nnbss) interpreted_locations;
    svfp_decl = decl_of_die d subprogram_line_extents cu die;
    |> )
   
let strict_mss x e s z =
  match x with
  | Just y -> y
  | Nothing ->
     Assert_extra.failwith ("mk_sdt_subroutine strict failure " ^ e ^ " on \n" ^ s z ^ "\n")
  end
   
let rec mk_sdt_subroutine (d:dwarf) subprogram_line_extents (cu:compilation_unit) parents (die:die) : maybe sdt_subroutine =
  if not(List.elem die.die_abbreviation_declaration.ad_tag [tag_encode "DW_TAG_subprogram"; tag_encode "DW_TAG_inlined_subroutine"])
  then Nothing
  else
    let c = p_context_of_d d in
    (* let s (cu,parents,die) : string = pp_die c cu.cu_header d.d_str true 0 false die in*)
    
    let cupdie = (cu, parents, die) in
    let parents' = die::parents in
    let kind = if die.die_abbreviation_declaration.ad_tag = tag_encode "DW_TAG_subprogram" then SSK_subprogram else if die.die_abbreviation_declaration.ad_tag = tag_encode "DW_TAG_inlined_subroutine" then SSK_inlined_subroutine else Assert_extra.failwith ("unreachable bad kind") in
    Just (
        <|
        ss_cupdie = cupdie;
        ss_name = (*strict_mss ( *)find_name_of_die_using_abstract_origin c d cu d.d_str die(* ) "no name" s cupdie;*);
        ss_kind = kind;
        ss_call_site = call_site_of_die d subprogram_line_extents cu die; 
        ss_abstract_origin =
          match find_reference_attribute_of_die c d cu d.d_str "DW_AT_abstract_origin" die with
          | Nothing ->
             Nothing 
          | Just ((cu',parents',die') as cupdie') ->
             mk_sdt_subroutine d subprogram_line_extents cu' parents' die'
          end;
        ss_type = find_DW_AT_type_of_die_deep(*_using_abstract_origin*) d cupdie;
        ss_vars = List.mapMaybe (mk_sdt_variable_or_formal_parameter d subprogram_line_extents cu parents') die.die_children; 
        ss_unspecified_parameters = List.mapMaybe (mk_sdt_unspecified_parameter d subprogram_line_extents cu parents') die.die_children; 
        ss_entry_address = entry_address die;
        ss_pc_ranges = range_of_die_d d cu die;
        ss_subroutines  = List.mapMaybe (mk_sdt_subroutine d subprogram_line_extents cu parents') die.die_children; 
        ss_lexical_blocks = List.mapMaybe (mk_sdt_lexical_block d subprogram_line_extents cu parents') die.die_children; 
        ss_decl = decl_of_die d subprogram_line_extents cu die; 
        ss_noreturn = match find_flag_attribute_value_of_die_using_abstract_origin d "DW_AT_noreturn" cupdie with Just b -> b | Nothing -> false end;
        ss_external = match find_flag_attribute_value_of_die_using_abstract_origin d "DW_AT_external" cupdie with Just b -> b | Nothing -> false end;
        |> )

  and mk_sdt_lexical_block (d:dwarf) subprogram_line_extents (cu:compilation_unit) parents (die:die) : maybe sdt_lexical_block =
  if not (die.die_abbreviation_declaration.ad_tag = tag_encode "DW_TAG_lexical_block")
  then Nothing
  else
    let c = p_context_of_d d in
    (*let s (cu,parents,die) : string = pp_die c cu.cu_header d.d_str true 0 false die in*)
    
    let cupdie = (cu, parents, die) in
    let parents' = die::parents in
    Just (
        <|
        slb_cupdie = cupdie;
        slb_vars = List.mapMaybe (mk_sdt_variable_or_formal_parameter d subprogram_line_extents cu parents') die.die_children; 
        slb_pc_ranges = range_of_die_d d cu die;
        slb_subroutines  = List.mapMaybe (mk_sdt_subroutine d subprogram_line_extents cu parents') die.die_children; 
        slb_lexical_blocks = List.mapMaybe (mk_sdt_lexical_block d subprogram_line_extents cu parents') die.die_children; 
        |> )

   
let strict_mscu x e s z =
  match x with
  | Just y -> y
  | Nothing ->
     Assert_extra.failwith ("mk_sdt_compilation_unit strict failure " ^ e ^ " on \n" ^ s z ^ "\n")
  end

let mk_sdt_compilation_unit (d:dwarf) subprogram_line_extents (cu:compilation_unit) : sdt_compilation_unit =
    let c = p_context_of_d d in
    let s (cu,(parents:list die),die) : string = pp_die c cu.cu_header d.d_str true 0 false die in
    let cupdie = (cu, [], cu.cu_die) in
    
    let parents' = [cu.cu_die] in
    <|
    scu_cupdie = (cu, [], cu.cu_die);
    scu_name = strict_mscu (find_name_of_die d.d_str cu.cu_die) "no name" s cupdie;
    scu_subroutines = List.mapMaybe (mk_sdt_subroutine d subprogram_line_extents cu parents') cu.cu_die.die_children; 
    scu_vars = List.mapMaybe (mk_sdt_variable_or_formal_parameter d subprogram_line_extents cu parents') cu.cu_die.die_children;
    scu_pc_ranges = range_of_die_d d cu cu.cu_die;
    |>

   
let mk_sdt_dwarf (d:dwarf) subprogram_line_extents : sdt_dwarf =
  <| sd_compilation_units = List.map (mk_sdt_compilation_unit d subprogram_line_extents) d.d_compilation_units;
|>

(* **** verbose pp of simple die tree view *************** *)

let pp_sdt_unspecified_parameter (level:natural) (sup:sdt_unspecified_parameter) : string =
  indent_level true level ^ "unspecified parameters" ^ "\n"

let pp_parsed_single_location_description (level:natural) ((n1:natural), (n2:natural), (ops:list operation)) : string = 
  let indent = indent_level true level in
  indent
  ^ pphex n1 
  ^ " " ^ pphex n2
  ^ " (" ^ pp_operations ops ^")"
  ^"\n"

let pp_pc_ranges (level:natural) (rso:maybe (list (natural*natural))) =
  match rso with
  | Nothing -> "none\n"
  | Just rs ->
      let indent = indent_level true level in
      "\n" ^ String.concat "" (List.map (fun (n1,n2) -> indent ^ pphex n1 ^ " " ^ pphex n2 ^ "\n") rs)
  end

let pp_sdt_maybe x f = match x with Nothing -> "none\n" | Just y -> f y end
let pp_sdt_maybe' f x = pp_sdt_maybe x f
let pp_sdt_list xs f = match xs with [] -> "none\n" | _ -> "\n" ^ String.concat "" ((List.map f) xs) end
   
let pp_sdt_variable_or_formal_parameter (level:natural) (svfp: sdt_variable_or_formal_parameter) : string =
  let indent = indent_level true level in
  ""
  ^ indent ^ "name:"        ^ svfp.svfp_name ^ "\n"
  ^ indent ^ "cupdie:"      ^ pp_cupdie3 svfp.svfp_cupdie ^ "\n"
  ^ indent ^ "kind:"        ^ (match svfp.svfp_kind with SVPK_var -> "var" | SVPK_param -> "param" end) ^ "\n" 
  ^ indent ^ "type:"        ^ pp_sdt_maybe' pp_type_info_deep svfp.svfp_type ^ "\n"
  ^ indent ^ "const_value:" ^ show svfp.svfp_const_value ^ "\n"
  ^ indent ^ "external:"    ^ show svfp.svfp_external ^ "\n"
  ^ indent ^ "declaration:" ^ show svfp.svfp_declaration ^ "\n"
  ^ indent ^ "locations:"   ^ pp_sdt_maybe svfp.svfp_locations (fun locs -> "\n" ^ String.concat "" (List.map (pp_parsed_single_location_description (level+1)) locs))
  ^ indent ^ "decl:"        ^ pp_sdt_maybe svfp.svfp_decl (fun ud -> "\n" ^ indent_level true (level+1) ^ pp_ud ud ^ "\n")
  ^ "\n"   

let rec pp_sdt_subroutine (level:natural) (ss:sdt_subroutine) : string = 
  let indent = indent_level true level in
  ""
  ^ indent ^ "name:"                   ^ pp_sdt_maybe ss.ss_name (fun name -> name ^ "\n")
  ^ indent ^ "cupdie:"                 ^ pp_cupdie3 ss.ss_cupdie ^ "\n"
  ^ indent ^ "kind:"                   ^ (match ss.ss_kind with SSK_subprogram -> "subprogram" | SSK_inlined_subroutine -> "inlined subroutine" end) ^ "\n" 
  ^ indent ^ "call site:"              ^ pp_sdt_maybe ss.ss_call_site (fun ud -> "\n" ^ indent_level true (level+1) ^ pp_ud ud ^ "\n")
  ^ indent ^ "abstract origin:"        ^ pp_sdt_maybe ss.ss_abstract_origin (pp_sdt_subroutine (level+1))
  ^ indent ^ "type:"                   ^ pp_sdt_maybe ss.ss_type (fun typ -> pp_type_info_deep typ ^"\n")
  ^ indent ^ "vars:"                   ^ pp_sdt_list ss.ss_vars (pp_sdt_variable_or_formal_parameter (level+1))
  ^ indent ^ "unspecified_parameters:" ^ pp_sdt_list ss.ss_unspecified_parameters (pp_sdt_unspecified_parameter (level+1))
  ^ indent ^ "entry address: "         ^ pp_sdt_maybe ss.ss_entry_address (fun n -> pphex n^"\n")
  ^ indent ^ "pc ranges:"              ^ pp_pc_ranges (level+1) ss.ss_pc_ranges
  ^ indent ^ "subroutines:"            ^ pp_sdt_list ss.ss_subroutines (pp_sdt_subroutine (level+1))
  ^ indent ^ "lexical_blocks:"         ^ pp_sdt_list ss.ss_lexical_blocks (pp_sdt_lexical_block (level+1))
  ^ indent ^ "decl:"                   ^ pp_sdt_maybe ss.ss_decl (fun ud -> "\n" ^ indent_level true (level+1) ^ pp_ud ud ^ "\n")
  ^ indent ^ "noreturn:"               ^ show ss.ss_noreturn ^ "\n"
  ^ indent ^ "external:"               ^ show ss.ss_external ^"\n"
  ^ "\n"   

and pp_sdt_lexical_block (level:natural) (lb:sdt_lexical_block) : string = 
  let indent = indent_level true level in
  ""
  ^ indent ^ "cupdie:"         ^ pp_cupdie3 lb.slb_cupdie ^ "\n"
  ^ indent ^ "pc ranges:"      ^ pp_pc_ranges (level+1) lb.slb_pc_ranges
  ^ indent ^ "vars:"           ^ pp_sdt_list lb.slb_vars (pp_sdt_variable_or_formal_parameter (level+1))
  ^ indent ^ "subroutines :"   ^ pp_sdt_list lb.slb_subroutines (pp_sdt_subroutine (level+1))
  ^ indent ^ "lexical_blocks:" ^ pp_sdt_list lb.slb_lexical_blocks (pp_sdt_lexical_block (level+1))
  ^ "\n"   

let pp_sdt_compilation_unit (level:natural) (cu:sdt_compilation_unit) : string = 
  let indent = indent_level true level in
  ""
  ^ indent ^ "name:"         ^ cu.scu_name ^ "\n"
  ^ indent ^ "cupdie:"       ^ pp_cupdie3 cu.scu_cupdie ^ "\n"
  ^ indent ^ "pc ranges:"    ^ pp_pc_ranges (level+1) cu.scu_pc_ranges
  ^ indent ^ "vars:"         ^ pp_sdt_list cu.scu_vars (pp_sdt_variable_or_formal_parameter (level+1))
  ^ indent ^ "subroutines :" ^ pp_sdt_list cu.scu_subroutines (pp_sdt_subroutine (level+1))
  ^ "\n"
  
let pp_sdt_dwarf (sdt_d:sdt_dwarf) : string =
  let indent_level = 0 in 
  String.concat "" (List.map (pp_sdt_compilation_unit indent_level) sdt_d.sd_compilation_units)

(* **** concise pp of simple die tree view *************** *)

(* **************** global vars ************* *)
  
let pp_sdt_concise_variable_or_formal_parameter (level:natural) (svfp: sdt_variable_or_formal_parameter) : string =
  let indent = indent_level true level in
  ""
  ^ indent
  (*  ^ indent ^ "cupdie:" ^  pp_cupdie3 svfp.svfp_cupdie ^ "\n"*)
  (*^ indent ^ "name:" ^*) ^ svfp.svfp_name ^ "  "
  (*^ indent ^ "kind:" *) ^  (match svfp.svfp_kind with SVPK_var -> "var" | SVPK_param -> "param" end) ^ "  " 
  (*^ indent ^ "type:" *) ^  pp_sdt_maybe' pp_type_info_deep svfp.svfp_type ^ "  "
  (*^ indent ^ "const_value:"*) ^  match svfp.svfp_const_value with | Nothing -> "" | Just v -> "const:"^show v ^ "  " end 
  (*^ indent ^ "external:" ^  show svfp.svfp_external ^ "\n"*)
  (*^ indent ^ "declaration:" ^  show svfp.svfp_declaration ^ "\n"*)
(*^ indent ^ "locations:" *) ^ (match svfp.svfp_locations with Nothing -> "no locations\n" | Just locs -> "\n" ^ String.concat "" (List.map (pp_parsed_single_location_description (level+1)) locs) end)
(*  ^ indent ^ "decl:" ^ (match svfp.svfp_decl with Nothing -> "none\n" | Just ((ufe,line) as ud) -> "\n" ^ indent_level true (level+1) ^ pp_ufe ufe ^ " " ^ show line ^ "\n" end)*)

let pp_sdt_globals_compilation_unit (level:natural) (cu:sdt_compilation_unit) : string = 
  let indent = indent_level true level in
  ""
  (*  ^ indent ^ "cupdie:" ^  pp_cupdie3 cu.scu_cupdie ^ "\n"*)
  ^ indent ^ (*"name:" ^*)  cu.scu_name ^ "\n"
  (*  ^ indent ^ "vars:" ^  "\n"*) ^ String.concat "" (List.map (pp_sdt_concise_variable_or_formal_parameter (level+1)) cu.scu_vars)
(*  ^ indent ^ "subroutines :" ^  (match cu.scu_subroutines with | [] -> "none\n" | sus -> "\n" ^ String.concat "\n" (List.map  (pp_sdt_subroutine (level+1)) sus) end) *)

let pp_sdt_globals_dwarf (sdt_d:sdt_dwarf) : string =
  let indent_level = 0 in 
  String.concat "" (List.map (pp_sdt_globals_compilation_unit indent_level) sdt_d.sd_compilation_units)

(* ******************  local vars *************** *)
  
let rec pp_sdt_locals_subroutine (level:natural) (ss:sdt_subroutine) : string = 
  let indent = indent_level true level in
  ""
    ^ indent (*^ "name:"                   ^*) ^ pp_sdt_maybe ss.ss_name (fun name -> name ^ "\n")
  (*  ^ indent ^ "cupdie:"                 ^ pp_cupdie3 ss.ss_cupdie ^ "\n"*)
  ^ indent ^ "kind:"                   ^ (match ss.ss_kind with SSK_subprogram -> "subprogram" | SSK_inlined_subroutine -> "inlined subroutine" end) ^ "\n" 
  ^ indent ^ "entry address: "         ^ pp_sdt_maybe ss.ss_entry_address (fun n -> pphex n^"\n")
  ^ indent ^ "call site:"              ^ pp_sdt_maybe ss.ss_call_site (fun ud -> "\n" ^ indent_level true (level+1) ^ pp_ud ud ^ "\n")
  ^ indent ^ "abstract origin:"        ^ pp_sdt_maybe ss.ss_abstract_origin (fun s -> "\n" ^ pp_sdt_locals_subroutine (level+1) s)
  (*  ^ indent ^ "type:"                   ^ pp_sdt_maybe ss.ss_type (fun typ -> pp_type_info_deep typ ^"\n" end)*)
  ^ indent ^ "vars:"                   ^ pp_sdt_list ss.ss_vars (pp_sdt_concise_variable_or_formal_parameter (level+1))
  ^ indent ^ "unspecified_parameters:" ^ pp_sdt_list ss.ss_unspecified_parameters (pp_sdt_unspecified_parameter (level+1))
  (*  ^ indent ^ "pc ranges:"              ^ pp_pc_ranges (level+1) ss.ss_pc_ranges*)
  ^ indent ^ "subroutines:"            ^ pp_sdt_list ss.ss_subroutines (pp_sdt_locals_subroutine (level+1))
  ^ indent ^ "lexical_blocks:"         ^ pp_sdt_list ss.ss_lexical_blocks (pp_sdt_locals_lexical_block (level+1))
  (*  ^ indent ^ "decl:"                   ^ pp_sdt_maybe ss.ss_decl (fun ((ufe,line) as ud) -> "\n" ^ indent_level true (level+1) ^ pp_ufe ufe ^ " " ^ show line ^ "\n" end)*)
  (*  ^ indent ^ "noreturn:"               ^ show ss.ss_noreturn ^ "\n"*)
  (*  ^ indent ^ "external:"               ^ show ss.ss_external ^"\n"*)
  ^ "\n"   

and pp_sdt_locals_lexical_block (level:natural) (lb:sdt_lexical_block) : string = 
  let indent = indent_level true level in
  ""
  (*  ^ indent ^ "cupdie:"         ^ pp_cupdie3 lb.slb_cupdie ^ "\n"*)
  ^ indent ^ "vars:"           ^ pp_sdt_list lb.slb_vars (pp_sdt_concise_variable_or_formal_parameter (level+1))
  (*  ^ indent ^ "pc ranges:"      ^ pp_pc_ranges (level+1) lb.slb_pc_ranges*)
  ^ indent ^ "subroutines :"   ^ pp_sdt_list lb.slb_subroutines (pp_sdt_locals_subroutine (level+1))
  ^ indent ^ "lexical_blocks:" ^ pp_sdt_list lb.slb_lexical_blocks (pp_sdt_locals_lexical_block (level+1))
  ^ "\n"   

let pp_sdt_locals_compilation_unit (level:natural) (cu:sdt_compilation_unit) : string = 
  let indent = indent_level true level in
  ""
  ^ indent (*^ "name:"         *) ^ cu.scu_name ^ "\n"
  (*  ^ indent ^ "cupdie:"       ^ pp_cupdie3 cu.scu_cupdie ^ "\n"*)
  ^ indent ^ "vars:"         ^ pp_sdt_list cu.scu_vars (pp_sdt_concise_variable_or_formal_parameter (level+1))
  ^ indent ^ "subroutines :" ^ pp_sdt_list cu.scu_subroutines (pp_sdt_locals_subroutine (level+1))

let pp_sdt_locals_dwarf (sdt_d:sdt_dwarf) : string =
  let indent_level = 0 in 
  String.concat "" (List.map (pp_sdt_locals_compilation_unit indent_level) sdt_d.sd_compilation_units)
  
(** ************************************************************ *)
(** **  analysis of inlined_subroutine data                      *)
(** ************************************************************ *)

(* old version, directly over die tree *)
(*  
let strict_ais x e s z =
  match x with
  | Just y -> y
  | Nothing ->
     Assert_extra.failwith ("analyse_inlined_subroutine strict failure " ^ e ^ " on \n" ^ s z ^ "\n")
  end
  
val analyse_inlined_subroutines : dwarf -> inlined_subroutine_data
let analyse_inlined_subroutines (d: dwarf) : inlined_subroutine_data =

  let c = p_context_of_d d in
  
  let s (cu,parents,die) = pp_die c cu.cu_header d.d_str true 0 false die in

  let inlined_subroutines : list (compilation_unit * (list die) * die) =
    find_dies
      (fun die ->
        die.die_abbreviation_declaration.ad_tag = tag_encode "DW_TAG_inlined_subroutine")
      d in
  
  List.map
    (fun (((cu:compilation_unit), (parents: list die), (die: die)) as inlined_subroutine) ->
      
      let ((cu',parents,die') as abstract_origin) : compilation_unit * (list die) * die = 
        strict_ais (find_reference_attribute_of_die c d cu d.d_str "DW_AT_abstract_origin" die)
          "no abstract origin" s inlined_subroutine  in
      let name : string =
        strict_ais (find_name_of_die d.d_str die')
          "no abstract origin name" s abstract_origin in
      let call_file : unpacked_file_entry = 
        let file_index = strict_ais (find_natural_attribute_value_of_die c "DW_AT_call_file" die) "no DW_AT_call_file" s inlined_subroutine in
        unpack_file_entry (line_number_program_of_compilation_unit d cu).lnp_header file_index in
        (*        match filename d cu file_index with | Just s -> s | Nothing -> "none" end in*)
      let call_line : natural = strict_ais (find_natural_attribute_value_of_die c "DW_AT_call_line" die) "no DW_AT_call_line" s inlined_subroutine  in
      let pc_ranges : list (natural*natural) = 
        strict_ais (closest_enclosing_range c d.d_ranges (cu_base_address cu) [die](*deliberately ignore parents*))
          "no pc ranges" s inlined_subroutine in
      let const_params =
        List.mapMaybe (fun die'' ->
            if die''.die_abbreviation_declaration.ad_tag = tag_encode "DW_TAG_formal_parameter" then
              match find_reference_attribute_of_die c d cu d.d_str "DW_AT_abstract_origin" die'' with
              | Nothing -> Nothing
              | Just abstract_origin' ->
                 match find_integer_attribute_value_of_die c "DW_AT_const_value" die'' with
                 | Nothing -> Nothing
                 | Just n ->
                    Just (<|
                          iscp_abstract_origin = abstract_origin';
                          iscp_value = n;
                        |>)
                 end
              end
            else
              Nothing 
          ) die.die_children in
      <|
      is_inlined_subroutine = inlined_subroutine;
      is_abstract_origin = abstract_origin;
      is_name = name;
      is_call_file = call_file;
      is_call_line = call_line;
      is_pc_ranges = pc_ranges;
      is_const_params = const_params;
      |>
    )
    inlined_subroutines
 *)
  
(* new version, over simple-die-tree view, but still producing the previous old-style datastructure *)

let analyse_inlined_subroutines_sdt_const_param (svfp:sdt_variable_or_formal_parameter) : maybe inlined_subroutine_const_param =
  match (svfp.svfp_kind, svfp.svfp_abstract_origin, svfp.svfp_const_value) with
  | (SVPK_param, Just svfp', Just n) ->
     Just (<|
           iscp_abstract_origin = svfp'.svfp_cupdie;
           iscp_value = n;
           |>)
  | _ ->
     Nothing
  end

let rec analyse_inlined_subroutines_sdt_subroutine (sdt_parents: list sdt_subroutine) (ss:sdt_subroutine) : list inlined_subroutine =
  let this : list inlined_subroutine = 
  match (ss.ss_kind, ss.ss_abstract_origin) with
  | (SSK_inlined_subroutine, Just ss') ->
     let ((call_file:unpacked_file_entry),(call_line:natural)) =
       match ss.ss_call_site with 
       | Just (((ufe,line,subprogram_name) as ud):unpacked_decl) ->
          (ufe,naturalFromNat line)
       | Nothing ->
          Assert_extra.failwith "analyse_inlined_subroutines_sdt_subroutine found no ss_call_site"
      end in
    let pc_ranges = match ss.ss_pc_ranges with | Just pc_ranges -> pc_ranges | Nothing -> Assert_extra.failwith "analyse_inlined_subroutines_sdt_subroutine found no ss_pc_ranges"   end in
    let const_params = List.mapMaybe analyse_inlined_subroutines_sdt_const_param ss.ss_vars in
    [ (<|
            is_inlined_subroutine = ss.ss_cupdie;
          is_abstract_origin = ss'.ss_cupdie;
          is_inlined_subroutine_sdt = ss;
          is_inlined_subroutine_sdt_parents = sdt_parents;
          is_name = match ss.ss_name with Just name->name | Nothing -> "no name" end;
          is_call_file = call_file;
          is_call_line = call_line;
          is_pc_ranges = pc_ranges;
          is_const_params = const_params;
          |>
      )]
   | (SSK_inlined_subroutine, Nothing) ->
      Assert_extra.failwith "analyse_inlined_subroutines_sdt_subroutine found SSK_inlined_subroutine without ss_abstract_origin"
   | _ ->
      []
   end in
   let sdt_parents' = ss::sdt_parents in

   this 
   ++ List.concatMap (analyse_inlined_subroutines_sdt_subroutine sdt_parents') ss.ss_subroutines
   ++ List.concatMap (analyse_inlined_subroutines_sdt_lexical_block sdt_parents') ss.ss_lexical_blocks


and analyse_inlined_subroutines_sdt_lexical_block sdt_parents (lb:sdt_lexical_block) : list inlined_subroutine =
  List.concatMap (analyse_inlined_subroutines_sdt_subroutine sdt_parents) lb.slb_subroutines
  ++ List.concatMap (analyse_inlined_subroutines_sdt_lexical_block sdt_parents) lb.slb_lexical_blocks

let analyse_inlined_subroutines_sdt_compilation_unit (cu:sdt_compilation_unit) : list inlined_subroutine =
  List.concatMap (analyse_inlined_subroutines_sdt_subroutine []) cu.scu_subroutines

let analyse_inlined_subroutines_sdt_dwarf (sd: sdt_dwarf) : list inlined_subroutine =
  List.concatMap analyse_inlined_subroutines_sdt_compilation_unit sd.sd_compilation_units

  
let analyse_inlined_subroutine_by_range (is:inlined_subroutine) : inlined_subroutine_data_by_range =
  let n_ranges = List.length is.is_pc_ranges in 
  List.mapi (fun i -> fun (n1,n2) -> ((n1,n2),(naturalFromNat i, naturalFromNat n_ranges),is)) is.is_pc_ranges


let is_lt ((n1,n2),(m,n),is) ((n1',n2'),(m',n'),is') = n1 < n1' || (n1 = n1' && n2 > n2')
  
let analyse_inlined_subroutines_by_range (iss:inlined_subroutine_data) : inlined_subroutine_data_by_range =
  Sorting.sortBy is_lt (List.concat (List.map analyse_inlined_subroutine_by_range iss))

(* pp the inlined_subroutine tree structure.  Technically these die offsets each also need the compilation-unit offset to be globally unique, but that's locally constant *)
let rec pp_inlined_subroutine_parents (ds:list die) : string =
  match ds with
  | [] -> ""
  | die::ds' ->
     if die.die_abbreviation_declaration.ad_tag = tag_encode "DW_TAG_inlined_subroutine" then
       pp_pos die.die_offset ^ ":" ^ pp_inlined_subroutine_parents ds'
     else if die.die_abbreviation_declaration.ad_tag = tag_encode "DW_TAG_lexical_block" then "<lexical_block>:" ^ pp_inlined_subroutine_parents ds'
     else if die.die_abbreviation_declaration.ad_tag = tag_encode "DW_TAG_subprogram" then ""
     else "<surprising ad_tag in " ^ pp_pos die.die_offset ^ ": " ^ pphex die.die_abbreviation_declaration.ad_tag ^ ">"
  end 
       
  
let pp_inlined_subroutine_header ds is = 
  is.is_name
  ^ " inlined from " ^ (subprogram_at_line ds.ds_subprogram_line_extents is.is_call_file is.is_call_line) ^ ":" ^ show is.is_call_line ^ " (" ^ (pp_ufe_brief is.is_call_file) ^ ")" 
  ^ " "
  ^ let (cu,parents,die) = is.is_inlined_subroutine in
    pp_inlined_subroutine_parents (die::parents)
  
let pp_inlined_subroutine_const_params d is =
  let c = p_context_of_d d in
  match is.is_const_params with
  | [] -> ""
  | _ ->
     String.concat ""
       (List.map
          (fun iscp ->
            let fake_als : analysed_location_data = [(iscp.iscp_abstract_origin,Nothing)] in
            let fake_diff = pp_analysed_locations3_diff c (*HACK*) d d.d_str [] fake_als in
            let const_in_place_of_locs = 
              List.map
                (fun (removed,(name,offset,kind),typ,locs,parents) ->
                  (removed,(name,offset,kind),typ,"const="^show iscp.iscp_value,parents))
                fake_diff in
            pp_analysed_location_format const_in_place_of_locs
          )
          is.is_const_params)
  end
  
let pp_inlined_subroutine ds is =
  pp_inlined_subroutine_header ds is ^ "\n"
  ^ String.concat "" (List.map (fun (n1,n2) -> "  " ^ pphex n1 ^ " " ^ pphex n2 ^ "\n") is.is_pc_ranges)
  ^ pp_inlined_subroutine_const_params ds.ds_dwarf is 

let pp_inlined_subroutines ds iss =
  String.concat "" (List.map (pp_inlined_subroutine ds) iss)           


let pp_inlined_subroutine_by_range ds ((n1,n2),((m:natural),(n:natural)),is) =
  pphex n1 ^ " " ^ pphex n2 ^ " "
  ^ (if n<>1 then "("^show m^" of "^show n^") " else "")
  ^  pp_inlined_subroutine_header ds is 
  ^"\n"
  ^ (if m=0 then pp_inlined_subroutine_const_params ds.ds_dwarf is else "")

let pp_inlined_subroutines_by_range ds iss =
  String.concat "" (List.map (pp_inlined_subroutine_by_range ds) iss)           

(** ************************************************************ *)
(** **  pp of text section                                       *)
(** ************************************************************ *)

(* assume 4-byte ARM instructions *)


let rec words_of_byte_sequence (addr:natural) (bs:byte_sequence) (acc:list (natural * natural)) : list (natural * natural) =
  match read_4_bytes_be bs with
  | Success ((b0,b1,b2,b3), bs') ->
     let i : natural = natural_of_byte b0 + 256*natural_of_byte b1 + 65536*natural_of_byte b2 + 65536*256*natural_of_byte b3 in
     words_of_byte_sequence (addr+4) bs' ((addr,i)::acc)
  | Fail _ -> List.reverse acc
  end

let pp_instruction ((addr:natural),(i:natural)) =
  hex_string_of_big_int_pad8 addr ^ "  " ^ hex_string_of_big_int_pad8 i ^ "\n"
  
val pp_text_section : elf_file -> string
let pp_text_section f =
  let (p_context, addr, bs) = extract_text f in
  let instructions : list (natural * natural) = words_of_byte_sequence addr bs [] in
  String.concat "" (List.map pp_instruction instructions)  

(** ************************************************************ *)
(** **  top level for main_elf  ******************************** *)
(** ************************************************************ *)

val harness_string_of_elf_like_objdump : elf_file -> byte_sequence -> string
let harness_string_of_elf_like_objdump f1 bs =
  let mds = extract_dwarf_static f1 in
  match mds with
  | Nothing -> "<no dwarf information extracted>"
  | Just ds ->
   "" (*pp_text_section f1*)
   ^ pp_dwarf_like_objdump ds.ds_dwarf
  end

    
val harness_string_of_elf : elf_file -> byte_sequence -> string
let harness_string_of_elf f1 bs =
let mds = extract_dwarf_static f1 in
  match mds with
  | Nothing -> "<no dwarf information extracted>"
  | Just ds ->
     let sdt_d = mk_sdt_dwarf ds.ds_dwarf ds.ds_subprogram_line_extents in 

     "* emacs outline-mode configuration -*-outline-*-   C-c C-{t,a,d,e}"
     ^  "" (*pp_text_section f1*)
     ^ pp_dwarf ds.ds_dwarf
     (*   ^ analyse_locations_raw c d    *)
     
     ^ "************** evaluation of frame data *************************\n"
     ^ pp_evaluated_frame_info ds.ds_evaluated_frame_info
     ^ "************** analysis of location data *************************\n"
     ^ pp_analysed_location_data ds.ds_dwarf ds.ds_analysed_location_data
     ^ "************** line info *************************\n"
     ^ pp_evaluated_line_info ds.ds_evaluated_line_info
     
     ^ "************** inlined subroutine info *************************\n"
     ^ let iss = analyse_inlined_subroutines_sdt_dwarf sdt_d in
       pp_inlined_subroutines ds iss 
       ^ "************** inlined subroutine info by range *************************\n"
       ^ pp_inlined_subroutines_by_range ds (analyse_inlined_subroutines_by_range iss)
       ^ "************** subprogram line-number extent info *************************\n"
       ^ pp_subprograms ds.ds_subprogram_line_extents
       ^ "************** simple die tree *************************\n"
       ^        pp_sdt_dwarf sdt_d
       ^  "************** simple die tree globals *************************\n"
       ^  pp_sdt_globals_dwarf sdt_d
       ^  "************** simple die tree locals *************************\n"
       ^  pp_sdt_locals_dwarf sdt_d


end


val harness_string_of_elf64_debug_info_section : elf64_file -> byte_sequence -> (*(natural -> string) -> (natural -> string) -> (natural -> string) -> elf64_header -> elf64_section_header_table -> string_table -> *) string
let {ocaml} harness_string_of_elf64_debug_info_section f1 bs0 (*os proc usr hdr sht stbl*) =
  harness_string_of_elf (ELF_File_64 f1) bs0

val harness_string_of_elf32_debug_info_section : elf32_file -> byte_sequence -> (* (natural -> string) -> (natural -> string) -> (natural -> string) -> elf32_header -> elf32_section_header_table -> string_table ->*) string
let {ocaml} harness_string_of_elf32_debug_info_section f1 bs0 (*os proc usr hdr sht stbl*) =
  harness_string_of_elf (ELF_File_32 f1) bs0



val harness_string_of_elf64_like_objdump : elf64_file -> byte_sequence -> (*(natural -> string) -> (natural -> string) -> (natural -> string) -> elf64_header -> elf64_section_header_table -> string_table -> *) string
let {ocaml} harness_string_of_elf64_like_objdump f1 bs0 (*os proc usr hdr sht stbl*) =
  harness_string_of_elf_like_objdump (ELF_File_64 f1) bs0

val harness_string_of_elf32_like_objdump : elf32_file -> byte_sequence -> (* (natural -> string) -> (natural -> string) -> (natural -> string) -> elf32_header -> elf32_section_header_table -> string_table ->*) string
let {ocaml} harness_string_of_elf32_like_objdump f1 bs0 (*os proc usr hdr sht stbl*) =
  harness_string_of_elf_like_objdump (ELF_File_32 f1) bs0

    
