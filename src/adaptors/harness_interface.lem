open import Basic_classes
open import Bool
open import Function
open import Maybe
open import Num
open import String

open import Byte_sequence
open import Error
open import Hex_printing
open import Missing_pervasives
open import Show

open import Default_printing

open import Endianness
open import String_table

open import Elf_dynamic
open import Elf_file
open import Elf_header
open import Elf_program_header_table
open import Elf_relocation
open import Elf_section_header_table
open import Elf_symbol_table
open import Elf_types_native_uint

open import Gnu_ext_dynamic
open import Gnu_ext_section_header_table
open import Gnu_ext_section_to_segment_mapping
open import Gnu_ext_symbol_versioning

val concatS' : list string -> string -> string
let rec concatS' ss accum =
  match ss with
    | []    -> accum
    | s::ss -> concatS' ss (accum^s)
  end

val concatS : list string -> string
let concatS ss = concatS' ss ""

val harness_string_of_elf32_file_header : elf32_header -> string
let {ocaml} harness_string_of_elf32_file_header hdr =
  unlines [
    "ELF Header:"
  ; "  Magic:" ^ "   "                           ^ unsafe_hex_string_of_uc_list (hdr.elf32_ident)
  ; "  Class:" ^ "                             " ^ string_of_elf_file_class (get_elf32_file_class hdr)
  ; "  Data:" ^ "                              " ^ string_of_elf_data_encoding (get_elf32_data_encoding hdr)
  ; "  Version:" ^ "                           " ^ string_of_elf_version_number (get_elf32_version_number hdr)
  ; "  OS/ABI:" ^ "                            " ^ string_of_elf_osabi_version (const "Architecture defined") (get_elf32_osabi hdr)
  ; "  ABI Version:" ^ "                       " ^ show (get_elf32_abi_version hdr)
  ; "  Type:" ^ "                              " ^ string_of_elf_file_type default_os_specific_print default_proc_specific_print (natural_of_elf32_half hdr.elf32_type)
  ; "  Machine:" ^ "                           " ^ string_of_elf_machine_architecture (natural_of_elf32_half hdr.elf32_machine)
  ; "  Version:" ^ "                           " ^ "0x" ^ unsafe_hex_string_of_natural 1 (natural_of_elf32_word hdr.elf32_version)
  ; "  Entry point address:" ^ "               " ^ "0x" ^ unsafe_hex_string_of_natural 1 (natural_of_elf32_addr hdr.elf32_entry)
  ; "  Start of program headers:" ^ "          " ^ show hdr.elf32_phoff ^ " (bytes into file)"
  ; "  Start of section headers:" ^ "          " ^ show hdr.elf32_shoff ^ " (bytes into file)"
  ; "  Flags:" ^ "                             " ^ "0x" ^ unsafe_hex_string_of_natural 1 (natural_of_elf32_word hdr.elf32_flags)
  ; "  Size of this header:" ^ "               " ^ show hdr.elf32_ehsize ^ " (bytes)"
  ; "  Size of program headers:" ^ "           " ^ show hdr.elf32_phentsize ^ " (bytes)"
  ; "  Number of program headers:" ^ "         " ^ show hdr.elf32_phnum
  ; "  Size of section headers:" ^ "           " ^ show hdr.elf32_shentsize ^ " (bytes)"
  ; "  Number of section headers:" ^ "         " ^ show hdr.elf32_shnum
  ; "  Section header string table index:" ^ " " ^ show hdr.elf32_shstrndx
  ]

val harness_string_of_elf64_file_header : elf64_header -> string
let {ocaml} harness_string_of_elf64_file_header hdr =
  unlines [
    "ELF Header:"
  ; "  Magic:" ^ "   "                           ^ unsafe_hex_string_of_uc_list (hdr.elf64_ident)
  ; "  Class:" ^ "                             " ^ string_of_elf_file_class (get_elf64_file_class hdr)
  ; "  Data:" ^ "                              " ^ string_of_elf_data_encoding (get_elf64_data_encoding hdr)
  ; "  Version:" ^ "                           " ^ string_of_elf_version_number (get_elf64_version_number hdr)
  ; "  OS/ABI:" ^ "                            " ^ string_of_elf_osabi_version (const "Architecture defined") (get_elf64_osabi hdr)
  ; "  ABI Version:" ^ "                       " ^ show (get_elf64_abi_version hdr)
  ; "  Type:" ^ "                              " ^ string_of_elf_file_type default_os_specific_print default_proc_specific_print (natural_of_elf64_half hdr.elf64_type)
  ; "  Machine:" ^ "                           " ^ string_of_elf_machine_architecture (natural_of_elf64_half hdr.elf64_machine)
  ; "  Version:" ^ "                           " ^ "0x" ^ unsafe_hex_string_of_natural 1 (natural_of_elf64_word hdr.elf64_version)
  ; "  Entry point address:" ^ "               " ^ "0x" ^ unsafe_hex_string_of_natural 1 (natural_of_elf64_addr hdr.elf64_entry)
  ; "  Start of program headers:" ^ "          " ^ show hdr.elf64_phoff ^ " (bytes into file)"
  ; "  Start of section headers:" ^ "          " ^ show hdr.elf64_shoff ^ " (bytes into file)"
  ; "  Flags:" ^ "                             " ^ "0x" ^ unsafe_hex_string_of_natural 1 (natural_of_elf64_word hdr.elf64_flags)
  ; "  Size of this header:" ^ "               " ^ show hdr.elf64_ehsize ^ " (bytes)"
  ; "  Size of program headers:" ^ "           " ^ show hdr.elf64_phentsize ^ " (bytes)"
  ; "  Number of program headers:" ^ "         " ^ show hdr.elf64_phnum
  ; "  Size of section headers:" ^ "           " ^ show hdr.elf64_shentsize ^ " (bytes)"
  ; "  Number of section headers:" ^ "         " ^ show hdr.elf64_shnum
  ; "  Section header string table index:" ^ " " ^ show hdr.elf64_shstrndx
  ]

val harness_string_of_elf32_program_header_table_entry : (natural -> string) -> (natural -> string) -> byte_sequence -> elf32_program_header_table_entry -> string
let {ocaml} harness_string_of_elf32_program_header_table_entry os proc bs0 pent =
  let typ = string_of_segment_type os proc (natural_of_elf32_word pent.elf32_p_type) in
  let typ_s =
    let len = 15 - String.stringLength typ in
      if len <= 0 then
        ""
      else
        concatS (replicate (naturalFromNat len) " ")
  in
  concatS [
    "  "
  ; typ ; typ_s
  ; "0x" ^ unsafe_hex_string_of_natural 6 (natural_of_elf32_off pent.elf32_p_offset)
  ; " "
  ; "0x" ^ unsafe_hex_string_of_natural 8 (natural_of_elf32_addr pent.elf32_p_vaddr)
  ; " "
  ; "0x" ^ unsafe_hex_string_of_natural 8 (natural_of_elf32_addr pent.elf32_p_paddr)
  ; " "
  ; "0x" ^ unsafe_hex_string_of_natural 5 (natural_of_elf32_word pent.elf32_p_filesz)
  ; " "
  ; "0x" ^ unsafe_hex_string_of_natural 5 (natural_of_elf32_word pent.elf32_p_memsz)
  ; " "
  ; string_of_elf_segment_permissions (natural_of_elf32_word pent.elf32_p_flags)
  ; " "
  ; "0x" ^ unsafe_hex_string_of_natural 1 (natural_of_elf32_word pent.elf32_p_align)
  ] ^
    if natural_of_elf32_word pent.elf32_p_type = elf_pt_interp then
      match Elf_program_header_table.get_elf32_requested_interpreter pent bs0 with
        | Fail f    -> "\n      [Requesting program interpreter: " ^ f ^ "]"
        | Success s -> "\n      [Requesting program interpreter: " ^ s ^ "]"
      end
    else
      ""

val harness_string_of_elf64_program_header_table_entry : (natural -> string) -> (natural -> string) -> byte_sequence -> elf64_program_header_table_entry -> string
let {ocaml} harness_string_of_elf64_program_header_table_entry os proc bs0 pent =
  let typ = string_of_segment_type os proc (natural_of_elf64_word pent.elf64_p_type) in
  let typ_s =
    let len = 15 - String.stringLength typ in
      if len <= 0 then
        ""
      else
        concatS (replicate (naturalFromNat len) " ")
  in
  concatS [
    "  "
  ; typ ; typ_s
  ; "0x" ^ unsafe_hex_string_of_natural 6 (natural_of_elf64_off pent.elf64_p_offset)
  ; " "
  ; "0x" ^ unsafe_hex_string_of_natural 16 (natural_of_elf64_addr pent.elf64_p_vaddr)
  ; " "
  ; "0x" ^ unsafe_hex_string_of_natural 16 (natural_of_elf64_addr pent.elf64_p_paddr)
  ; " "
  ; "0x" ^ unsafe_hex_string_of_natural 6 (natural_of_elf64_xword pent.elf64_p_filesz)
  ; " "
  ; "0x" ^ unsafe_hex_string_of_natural 6 (natural_of_elf64_xword pent.elf64_p_memsz)
  ; " "
  ; string_of_elf_segment_permissions (natural_of_elf64_word pent.elf64_p_flags)
  ; " "
  ; "0x" ^ unsafe_hex_string_of_natural 1 (natural_of_elf64_xword pent.elf64_p_align)
  ] ^
    if natural_of_elf64_word pent.elf64_p_type = elf_pt_interp then
      match Elf_program_header_table.get_elf64_requested_interpreter pent bs0 with
        | Fail f    -> "\n      [Requesting program interpreter: " ^ f ^ "]"
        | Success s -> "\n      [Requesting program interpreter: " ^ s ^ "]"
      end
    else
      ""

val harness_string_of_efl32_pht : (natural -> string) -> (natural -> string) -> elf32_program_header_table -> byte_sequence -> string
let {ocaml} harness_string_of_elf32_pht os proc pht bs0 =
    "  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align\n" ^
      unlines (List.map (harness_string_of_elf32_program_header_table_entry os proc bs0) pht)

val harness_string_of_efl64_pht : (natural -> string) -> (natural -> string) -> elf64_program_header_table -> byte_sequence -> string
let {ocaml} harness_string_of_elf64_pht os proc pht bs0 =
    "  Type           Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align\n" ^
      unlines (List.map (harness_string_of_elf64_program_header_table_entry os proc bs0) pht)

val harness_string_of_elf32_segment_section_mappings : elf32_header -> elf32_program_header_table -> elf32_section_header_table -> string_table -> string
let {ocaml} harness_string_of_elf32_segment_section_mappings hdr pht sht stbl =
  let map =
    List.mapi (fun i -> fun pent ->
      let mapping =
        match get_elf32_section_to_segment_mapping hdr sht pent elf32_section_in_segment stbl with
          | Fail err   -> ["ERR: " ^ err]
          | Success mp -> intercalate " " mp
        end
      in
      let str =
        let temp = concatS mapping in
          if temp = "" then
            temp
          else
            temp ^ " "
      in
        concatS [
          "   " ^ hex_string_of_nat_pad2 i
        ; "     "
        ; str
        ]
    ) pht
  in
    concatS (intercalate "\n" map)

val harness_string_of_elf64_segment_section_mappings : elf64_header -> elf64_program_header_table -> elf64_section_header_table -> string_table -> string
let {ocaml} harness_string_of_elf64_segment_section_mappings hdr pht sht stbl =
  let map =
    List.mapi (fun i -> fun pent ->
      let mapping =
        match get_elf64_section_to_segment_mapping hdr sht pent elf64_section_in_segment stbl with
          | Fail err   -> ["ERR: " ^ err]
          | Success mp -> intercalate " " mp
        end
      in
      let str =
        let temp = concatS mapping in
          if temp = "" then
            temp
          else
            temp ^ " "
      in
        concatS [
          "   " ^ hex_string_of_nat_pad2 i
        ; "     "
        ; str
        ]
    ) pht
  in
    concatS (intercalate "\n" map)

val harness_string_of_elf32_program_headers : (natural -> string) -> (natural -> string) -> elf32_header -> elf32_program_header_table -> elf32_section_header_table -> string_table -> byte_sequence -> string
let {ocaml} harness_string_of_elf32_program_headers os proc hdr pht sht stbl bs0 =
  let pht_len = List.length pht in
    if pht_len = 0 then
      "\nThere are no program headers in this file."
    else
      unlines [
        ""
      ; "Elf file type is " ^ string_of_elf_file_type default_os_specific_print default_proc_specific_print (natural_of_elf32_half hdr.elf32_type)
      ; "Entry point " ^ "0x" ^ unsafe_hex_string_of_natural 1 (natural_of_elf32_addr hdr.elf32_entry)
      ; "There are " ^ show (List.length pht) ^ " program headers, starting at offset " ^ show hdr.elf32_phoff
      ; ""
      ; "Program Headers:"
      ; harness_string_of_elf32_pht os proc pht bs0
      ; ""
      ; " Section to Segment mapping:"
      ; "  Segment Sections..."
      ; harness_string_of_elf32_segment_section_mappings hdr pht sht stbl
      ]

val harness_string_of_elf64_program_headers : (natural -> string) -> (natural -> string) -> elf64_header -> elf64_program_header_table -> elf64_section_header_table -> string_table -> byte_sequence -> string
let {ocaml} harness_string_of_elf64_program_headers os proc hdr pht sht stbl bs0 =
  let pht_len = List.length pht in
    if pht_len = 0 then
      "\nThere are no program headers in this file."
    else
      unlines [
        ""
      ; "Elf file type is " ^ string_of_elf_file_type default_os_specific_print default_proc_specific_print (natural_of_elf64_half hdr.elf64_type)
      ; "Entry point " ^ "0x" ^ unsafe_hex_string_of_natural 1 (natural_of_elf64_addr hdr.elf64_entry)
      ; "There are " ^ show (List.length pht) ^ " program headers, starting at offset " ^ show hdr.elf64_phoff
      ; ""
      ; "Program Headers:"
      ; harness_string_of_elf64_pht os proc pht bs0
      ; ""
      ; " Section to Segment mapping:"
      ; "  Segment Sections..."
      ; harness_string_of_elf64_segment_section_mappings hdr pht sht stbl
      ]

val harness_sht32_flag_legend : string
let {ocaml} harness_sht32_flag_legend =
  "\nKey to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings)
  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)
  O (extra OS processing required) o (OS specific), p (processor specific)"

val harness_sht64_flag_legend : natural -> string
let {ocaml} harness_sht64_flag_legend mach =
  if mach = elf_ma_x86_64 ||
     mach = elf_ma_l10m ||
     mach = elf_ma_k10m then
    "\nKey to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), l (large)
  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)
  O (extra OS processing required) o (OS specific), p (processor specific)"
  else
    "\nKey to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings)
  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)
  O (extra OS processing required) o (OS specific), p (processor specific)"

val harness_string_of_elf32_sht : (natural -> string) -> (natural -> string) -> (natural -> string) -> elf32_section_header_table -> string_table -> string
let {ocaml} harness_string_of_elf32_sht os proc usr sht stbl =
  "  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al\n" ^
  unlines (List.mapi (fun i -> fun sec ->
    let is =
      let temp = show i in
        if stringLength temp = 1 then
          " " ^ temp
        else
          temp
    in
    let str = "  [" ^ is ^ "]" in
    let ((gap : string), name) =
      match String_table.get_string_at (natural_of_elf32_word sec.elf32_sh_name) stbl with
        | Fail err   -> ("", "ERR " ^ err)
        | Success nm ->
          if natural_of_elf32_word sec.elf32_sh_type = sht_null then
            let gap = List.foldr (^) " " (Missing_pervasives.replicate 17 " ") in
            (gap, "")
          else
            let glen = naturalFromNat (17 - String.stringLength nm) in
            let gap = List.foldr (^) " " (Missing_pervasives.replicate glen " ") in
              (gap, nm)
      end
    in
    let str = str ^ " " ^ name ^ gap in
    let typ = string_of_section_type os proc usr (natural_of_elf32_word sec.elf32_sh_type) in
    let str = str ^ typ in
    let (gap, addr) =
      let mx  = naturalFromNat (15 - String.stringLength typ) in
      let gap = List.foldr (^) " " (Missing_pervasives.replicate mx " ") in
        (gap, unsafe_hex_string_of_natural 8 (natural_of_elf32_addr sec.elf32_sh_addr))
    in
    let str = str ^ gap ^ addr in
    let off = unsafe_hex_string_of_natural 6 (natural_of_elf32_off sec.elf32_sh_offset) in
    let str = str ^ " " ^ off in
    let size = unsafe_hex_string_of_natural 6 (natural_of_elf32_word sec.elf32_sh_size) in
    let str = str ^ " " ^ size in
    let es  = unsafe_hex_string_of_natural 2 (natural_of_elf32_word sec.elf32_sh_entsize) in
    let str = str ^ " " ^ es in
    let flg = string_of_section_flags os proc (natural_of_elf32_word sec.elf32_sh_flags) in
    let str = str ^ " " ^ flg in
    let (gap, lnk) =
      let l  = show (natural_of_elf32_word sec.elf32_sh_link) in
      let gp = naturalFromNat (2 - String.stringLength l) in
      let gp = List.foldr (^) " " (replicate gp " ") in
        (gp, l)
    in
    let str = str ^ gap ^ lnk in
    let (gap, info) =
      let i  = show (natural_of_elf32_word sec.elf32_sh_info) in
      let gp = naturalFromNat (3 - String.stringLength i) in
      let gp = List.foldr (^) " " (replicate gp " ") in
        (gp, i)
    in
    let str = str ^ gap ^ info in
    let (gap, align) =
      let a  = show (natural_of_elf32_word sec.elf32_sh_addralign) in
      let gp = naturalFromNat (2 - String.stringLength a) in
      let gp = List.foldr (^) " " (replicate gp " ") in
        (gp, a)
    in
    let str = str ^ gap ^ align in
      str) sht)

val harness_string_of_elf64_sht : (natural -> string) -> (natural -> string) -> (natural -> string) -> elf64_section_header_table -> string_table -> string
let {ocaml} harness_string_of_elf64_sht os proc usr sht stbl =
  "  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al\n" ^
  unlines (List.mapi (fun i -> fun sec ->
    let is =
      let temp = show i in
        if stringLength temp = 1 then
          " " ^ temp
        else
          temp
    in
    let str = "  [" ^ is ^ "]" in
    let ((gap : string), name) =
      match String_table.get_string_at (natural_of_elf64_word sec.elf64_sh_name) stbl with
        | Fail err   -> ("", "ERR " ^ err)
        | Success nm ->
          if natural_of_elf64_word sec.elf64_sh_type = sht_null then
            let gap = List.foldr (^) " " (Missing_pervasives.replicate 17 " ") in
            (gap, "")
          else
            let glen = naturalFromNat (17 - String.stringLength nm) in
            let gap = List.foldr (^) " " (Missing_pervasives.replicate glen " ") in
              (gap, nm)
      end
    in
    let str = str ^ " " ^ name ^ gap in
    let typ = string_of_section_type os proc usr (natural_of_elf64_word sec.elf64_sh_type) in
    let str = str ^ typ in
    let (gap, addr) =
      let mx  = naturalFromNat (15 - String.stringLength typ) in
      let gap = List.foldr (^) " " (Missing_pervasives.replicate mx " ") in
        (gap, unsafe_hex_string_of_natural 16 (natural_of_elf64_addr sec.elf64_sh_addr))
    in
    let str = str ^ gap ^ addr in
    let off = unsafe_hex_string_of_natural 6 (natural_of_elf64_off sec.elf64_sh_offset) in
    let str = str ^ " " ^ off in
    let size = unsafe_hex_string_of_natural 6 (natural_of_elf64_xword sec.elf64_sh_size) in
    let str = str ^ " " ^ size in
    let es  = unsafe_hex_string_of_natural 2 (natural_of_elf64_xword sec.elf64_sh_entsize) in
    let str = str ^ " " ^ es in
    let flg = string_of_section_flags os proc (natural_of_elf64_xword sec.elf64_sh_flags) in
    let str = str ^ " " ^ flg in
    let (gap, lnk) =
      let l  = show (natural_of_elf64_word sec.elf64_sh_link) in
      let gp = naturalFromNat (2 - String.stringLength l) in
      let gp = List.foldr (^) " " (replicate gp " ") in
        (gp, l)
    in
    let str = str ^ gap ^ lnk in
    let (gap, info) =
      let i  = show (natural_of_elf64_word sec.elf64_sh_info) in
      let gp = naturalFromNat (3 - String.stringLength i) in
      let gp = List.foldr (^) " " (replicate gp " ") in
        (gp, i)
    in
    let str = str ^ gap ^ info in
    let (gap, align) =
      let a  = show (natural_of_elf64_xword sec.elf64_sh_addralign) in
      let gp = naturalFromNat (2 - String.stringLength a) in
      let gp = List.foldr (^) " " (replicate gp " ") in
        (gp, a)
    in
    let str = str ^ gap ^ align in
      str) sht)


val harness_string_of_elf32_section_headers : (natural -> string) -> (natural -> string) -> (natural -> string) -> elf32_header -> elf32_section_header_table -> string_table -> string
let {ocaml} harness_string_of_elf32_section_headers os proc usr hdr sht stbl =
  unlines [
    "There are " ^ show (List.length sht) ^ " section headers, starting at offset 0x" ^ unsafe_hex_string_of_natural 0 (natural_of_elf32_off hdr.elf32_shoff) ^ ":"
  ; ""
  ; "Section Headers:"
  ; harness_string_of_elf32_sht os proc usr sht stbl
  ] ^ harness_sht32_flag_legend

val harness_string_of_elf64_section_headers : (natural -> string) -> (natural -> string) -> (natural -> string) -> elf64_header -> elf64_section_header_table -> string_table -> string
let {ocaml} harness_string_of_elf64_section_headers os proc usr hdr sht stbl =
  unlines [
    "There are " ^ show (List.length sht) ^ " section headers, starting at offset 0x" ^ unsafe_hex_string_of_natural 0 (natural_of_elf64_off hdr.elf64_shoff) ^ ":"
  ; ""
  ; "Section Headers:"
  ; harness_string_of_elf64_sht os proc usr sht stbl
  ] ^ harness_sht64_flag_legend (natural_of_elf64_half hdr.elf64_machine)

val harness_string_of_elf32_reloc_entry : (natural -> string) -> elf32_section_header_table ->
  elf32_symbol_table -> string_table -> string_table -> elf32_relocation -> string
let {ocaml} harness_string_of_elf32_reloc_entry os sht symtab stbl sechdr_stbl rel =
  let off  = natural_of_elf32_addr rel.elf32_r_offset in
  let inf  = natural_of_elf32_word rel.elf32_r_info in
  let typ  = Missing_pervasives.unsafe_string_take 22 (os 0) in (* FIXME *)
  let typs =
    let len = naturalFromNat (22 - String.stringLength typ) in
      concatS (replicate len " ")
  in
  let idx  = 0 in (* FIXME *)
    match List.index symtab (unsafe_nat_of_natural idx) with
      | Nothing  -> "harness_string_of_elf32_reloc_entry: Nothing returned"
      | Just sym ->
        let (nm, value, symtyp, secthdr)  =
          match List.index symtab (unsafe_nat_of_natural idx) with
            | Nothing  -> (stn_undef, 0, 0, 0)
            | Just sym -> (natural_of_elf32_word sym.elf32_st_name,
                natural_of_elf32_addr sym.elf32_st_value, get_elf32_symbol_type sym,
                  natural_of_elf32_half sym.elf32_st_shndx)
          end
        in
          if symtyp = stt_section then
            let vlu = " " ^ unsafe_hex_string_of_natural 8 value in
            let nm =
              match List.index sht (unsafe_nat_of_natural secthdr) with
                | Nothing   -> "XXX"
                | Just shdr ->
                  match String_table.get_string_at (natural_of_elf32_word shdr.elf32_sh_name) sechdr_stbl with
                    | Fail    f -> f
                    | Success n -> n
                 end
              end
            in
              concatS [
                unsafe_hex_string_of_natural 8 off
              ; "  "
              ; unsafe_hex_string_of_natural 8 inf
              ; " "
              ; typ
              ; typs
              ; vlu
              ; "   "
              ; nm
              ]
            else if nm = stn_undef then
              concatS [
                unsafe_hex_string_of_natural 8 off
              ; "  "
              ; unsafe_hex_string_of_natural 8 inf
              ; " "
              ; typ
              ; typs
              ]
            else
              let vlu = " " ^ unsafe_hex_string_of_natural 8 (natural_of_elf32_addr sym.elf32_st_value) in
              let nm =
                match String_table.get_string_at nm stbl with
                  | Fail    f -> f
                  | Success n -> n
                end
              in
                concatS [
                  unsafe_hex_string_of_natural 8 off
                ; "  "
                ; unsafe_hex_string_of_natural 8 inf
                ; " "
                ; typ
                ; typs
                ; vlu
                ; "   "
                ; nm
                ]
    end

val harness_string_of_elf64_reloc_a_entry : (natural -> string) -> elf64_symbol_table ->
  elf64_section_header_table -> string_table -> string_table -> elf64_relocation_a -> string
let {ocaml} harness_string_of_elf64_reloc_a_entry os symtab sht stbl sechdr_stbl rel =
  let off    = natural_of_elf64_addr  rel.elf64_ra_offset in
  let inf    = natural_of_elf64_xword rel.elf64_ra_info in
  let add    = integer_of_elf64_sxword rel.elf64_ra_addend in
  let typ    = Missing_pervasives.unsafe_string_take 22 (os 0) in (*FIXME *)
  let typs   =
    let len = naturalFromNat (22 - String.stringLength typ) in
      concatS (replicate len " ")
  in
  let idx  = 0 in (* FIXME *)
  let (nm, value, symtyp, secthdr)  =
    match List.index symtab (unsafe_nat_of_natural idx) with
      | Nothing  -> (stn_undef, 0, 0, 0)
      | Just sym -> (natural_of_elf64_word sym.elf64_st_name,
        natural_of_elf64_addr sym.elf64_st_value, get_elf64_symbol_type sym,
          natural_of_elf64_half sym.elf64_st_shndx)
    end
  in
    if symtyp = stt_section then
      let vlu = " " ^ unsafe_hex_string_of_natural 16 value in
      let nm =
        match List.index sht (unsafe_nat_of_natural secthdr) with
          | Nothing   -> "XXX"
          | Just shdr ->
            match String_table.get_string_at (natural_of_elf64_word shdr.elf64_sh_name) sechdr_stbl with
              | Fail    f -> f
              | Success n -> n
            end
        end
      in
        concatS [
          unsafe_hex_string_of_natural 16 off
        ; "  "
        ; unsafe_hex_string_of_natural 16 inf
        ; " "
        ; typ
        ; typs
        ; vlu
        ; " "
        ; nm
        ; " + "
        ; hex_string_of_big_int_no_padding' add
        ]
    else if nm = stn_undef then
      concatS [
        unsafe_hex_string_of_natural 16 off
      ; "  "
      ; unsafe_hex_string_of_natural 16 inf
      ; " "
      ; typ
      ; typs
      ; "                    "
      ; hex_string_of_big_int_no_padding' add
      ]
    else
      let vlu = " " ^ unsafe_hex_string_of_natural 16 value in
      let nm =
        match String_table.get_string_at nm stbl with
          | Fail    f -> f
          | Success n -> n
        end
      in
        concatS [
          unsafe_hex_string_of_natural 16 off
        ; "  "
        ; unsafe_hex_string_of_natural 16 inf
        ; " "
        ; typ
        ; typs
        ; vlu
        ; " "
        ; nm
        ; " + "
        ; hex_string_of_big_int_no_padding' add
        ]

val harness_string_of_elf32_relocs' : endianness -> (natural -> string) -> elf32_file -> elf32_section_header_table ->
  elf32_section_header_table -> string_table -> string_table -> byte_sequence -> string
let {ocaml} harness_string_of_elf32_relocs' endian os f1 sht_relocs sht shdr stbl bs0 =
  let rels =
    mapM (fun ent ->
      let off = natural_of_elf32_off  ent.elf32_sh_offset in
      let siz = natural_of_elf32_word ent.elf32_sh_size in
      let lnk = natural_of_elf32_word ent.elf32_sh_link in
        Byte_sequence.offset_and_cut off siz bs0 >>= fun rels ->
        Elf_relocation.read_elf32_relocation_section' endian rels >>= fun sect ->
        Elf_file.get_elf32_symbol_table_by_index f1 lnk >>= fun symtab ->
        return (sect, ent, symtab)
    ) sht_relocs
  >>=
    mapM (fun (rels, ent, symtab) ->
      let nm  = natural_of_elf32_word ent.elf32_sh_name in
      let off = unsafe_hex_string_of_natural 0 (natural_of_elf32_off ent.elf32_sh_offset) in
      let len = show (List.length rels) in
      String_table.get_string_at nm shdr >>= fun nm ->
      let hdr = "Relocation section '" ^ nm ^ "' at offset 0x" ^ off ^ " contains " ^ len ^ " entries:\n" in
      let ttl = " Offset     Info    Type                Sym. Value  Symbol's Name\n" in
      let body = concatS (intercalate "\n" (List.map (harness_string_of_elf32_reloc_entry os sht symtab stbl shdr) rels)) in
      return (hdr ^ ttl ^ body))
  in
    match rels with
      | Fail err -> err
      | Success s -> concatS (intercalate "\n\n" s)
    end

val harness_string_of_elf64_relocs' : endianness -> (natural -> string) -> elf64_file ->
  elf64_section_header_table -> elf64_section_header_table ->
  string_table -> string_table -> byte_sequence -> string
let {ocaml} harness_string_of_elf64_relocs' endian os f1 reloc_sht sht shdr stbl bs0 =
  let rels =
    mapM (fun ent ->
      let off = natural_of_elf64_off  ent.elf64_sh_offset in
      let siz = natural_of_elf64_xword ent.elf64_sh_size in
      let lnk = natural_of_elf64_word ent.elf64_sh_link in
        Byte_sequence.offset_and_cut off siz bs0 >>= fun rels ->
        Elf_relocation.read_elf64_relocation_a_section' endian rels >>= fun sect ->
        Elf_file.get_elf64_symbol_table_by_index f1 lnk >>= fun symtab ->
        return (sect, ent, symtab)
    ) reloc_sht
  >>=
    mapM (fun (rels, ent, symtab) ->
      let nm  = natural_of_elf64_word ent.elf64_sh_name in
      let off = unsafe_hex_string_of_natural 0 (natural_of_elf64_off ent.elf64_sh_offset) in
      let len = show (List.length rels) in
      String_table.get_string_at nm shdr >>= fun nm ->
      let hdr = "Relocation section '" ^ nm ^ "' at offset 0x" ^ off ^ " contains " ^ len ^ " entries:\n" in
      let ttl = "    Offset             Info             Type               Symbol's Value  Symbol's Name + Addend\n" in
      let body = concatS (intercalate "\n" (List.map (harness_string_of_elf64_reloc_a_entry os symtab sht stbl shdr) rels)) in
      return (hdr ^ ttl ^ body))
  in
    match rels with
      | Fail err -> err
      | Success s -> concatS (intercalate "\n\n" s)
    end

val harness_string_of_elf32_relocs : elf32_file -> (natural -> string) -> byte_sequence -> string
let {ocaml} harness_string_of_elf32_relocs f1 os bs0 =
  let hdr       = f1.elf32_file_header in
  let sht       = f1.elf32_file_section_header_table in
  let endian    = get_elf32_header_endianness hdr in
  let rel_secs  = List.filter (fun x ->
    x.elf32_sh_type = elf32_word_of_natural sht_rel) sht in
  if List.length rel_secs = 0 then
    "\nThere are no relocations in this file."
  else
    match get_elf32_file_symbol_string_table f1 with
      | Fail err     -> err
      | Success stbl ->
      match get_elf32_file_section_header_string_table f1 with
        | Fail err     -> err
        | Success shdr -> "\n" ^ harness_string_of_elf32_relocs' endian os f1 rel_secs sht shdr stbl bs0
      end
    end

val harness_string_of_elf64_relocs : elf64_file -> (natural -> string) -> byte_sequence -> string
let {ocaml} harness_string_of_elf64_relocs f1 os bs0 =
  let hdr       = f1.elf64_file_header in
  let sht       = f1.elf64_file_section_header_table in
  let endian    = get_elf64_header_endianness hdr in
  let rel_secs  = List.filter (fun x ->
    x.elf64_sh_type = elf64_word_of_natural sht_rela) sht in
  if List.length rel_secs = 0 then
    "\nThere are no relocations in this file."
  else
    match get_elf64_file_symbol_string_table f1 with
      | Fail err     -> err
      | Success stbl ->
      match get_elf64_file_section_header_string_table f1 with
        | Fail err     -> err
        | Success shdr -> "\n" ^ harness_string_of_elf64_relocs' endian os f1 rel_secs sht shdr stbl bs0
      end
    end

val harness_string_of_elf32_symbol_table_entry : nat -> (natural -> string) ->
  (natural -> string) -> byte_sequence -> string_table -> elf32_symbol_table_entry -> string
let {ocaml} harness_string_of_elf32_symbol_table_entry num os proc bs0 stbl ent =
  let vlu = unsafe_hex_string_of_natural 8 (natural_of_elf32_addr ent.elf32_st_value) in
  let siz = show (natural_of_elf32_word ent.elf32_st_size) in
  let siz_pad =
    let pad = 5 - stringLength siz in
    if pad = 0 then
      ""
    else
      concatS (replicate (naturalFromNat pad) " ")
  in
  let typ = string_of_symbol_type (get_elf32_symbol_type ent) os proc in
  let bnd = string_of_symbol_binding (get_elf32_symbol_binding ent) os proc in
  let bnd_pad =
    let pad  = 6 - stringLength typ in
    if pad = 0 then
      ""
    else
      concatS (replicate (naturalFromNat pad) " ")
  in
  let vis = string_of_symbol_visibility (natural_of_unsigned_char ent.elf32_st_other) in
  let vis_pad =
    let pad  = 6 - stringLength bnd in
    if pad = 0 then
      ""
    else
      concatS (replicate (naturalFromNat pad) " ")
  in
  let ndx =
    let tmp = natural_of_elf32_half ent.elf32_st_shndx in
      if tmp = shn_undef then
        "UND"
      else if tmp = shn_abs then
        "ABS"
      else
        show tmp
  in
  let ndx_pad =
    let pad = 3 - stringLength ndx in
    if pad = 0 then
      ""
    else
      concatS (replicate (naturalFromNat pad) " ")
  in
  let nm =
    let idx = natural_of_elf32_word ent.elf32_st_name in
      if idx = 0 then
        ""
      else
        match String_table.get_string_at idx stbl with
          | Fail err -> err
          | Success s -> s
        end
  in
  let sym = "" in
  let num =
    let temp = show num in
    let pad  = 3 - stringLength temp in
      if pad = 0 then
        temp
      else
        let spcs = concatS (replicate (naturalFromNat pad) " ") in
          spcs ^ temp
  in
    concatS [
      "   "
    ; num ^ ":"
    ; " "
    ; vlu
    ; " "
    ; siz_pad; siz
    ; " "
    ; typ
    ; "  "
    ; bnd_pad; bnd
    ; " "
    ; vis_pad; vis
    ; "  "
    ; ndx_pad; ndx
    ; " "
    ; nm
    ; sym
    ]

val harness_string_of_elf32_syms' : endianness -> (natural -> string) -> (natural -> string) -> elf32_file -> elf32_section_header_table -> elf32_section_header_table -> string_table -> byte_sequence -> string
let {ocaml} harness_string_of_elf32_syms' endian os proc f1 filtered_sht sht shdr bs0 =
  let rels =
    mapM (fun ent ->
      let off = natural_of_elf32_off  ent.elf32_sh_offset in
      let siz = natural_of_elf32_word ent.elf32_sh_size in
      let lnk = natural_of_elf32_word ent.elf32_sh_link in
      let typ = natural_of_elf32_word ent.elf32_sh_type in
        Byte_sequence.offset_and_cut off siz bs0 >>= fun syms ->
        Elf_symbol_table.read_elf32_symbol_table endian syms >>= fun sect ->
        Elf_file.get_elf32_string_table_by_index f1 lnk >>= fun strtab ->
        return (sect, ent, strtab, typ)
    ) filtered_sht >>= fun sects ->
    mapM (fun (syms, ent, strtab, typ) ->
      let nm  = natural_of_elf32_word ent.elf32_sh_name in
      let len = show (List.length syms) in
      String_table.get_string_at nm shdr >>= fun nm ->
      let hdr = "Symbol table '" ^ nm ^ "' contains " ^ len ^ " entries:\n" in
      let ttl = "   Num:    Value  Size Type    Bind   Vis      Ndx Name\n" in
      let body = concatS (intercalate "\n" (List.mapi (fun n ->
        harness_string_of_elf32_symbol_table_entry n os proc bs0 strtab) syms))
      in
      return (hdr ^ ttl ^ body)) sects
  in
    match rels with
      | Fail err -> err
      | Success s -> concatS (intercalate "\n\n" s)
    end

val harness_string_of_elf32_syms : elf32_file -> (natural -> string) -> (natural -> string) -> byte_sequence -> string
let {ocaml} harness_string_of_elf32_syms f1 os proc bs0 =
  let hdr = f1.elf32_file_header in
  let sht = f1.elf32_file_section_header_table in
  let endian = get_elf32_header_endianness hdr in
  let sym_secs = List.filter (fun x ->
    x.elf32_sh_type = elf32_word_of_natural sht_dynsym ||
    x.elf32_sh_type = elf32_word_of_natural sht_symtab) sht
  in
  if List.length sym_secs = 0 then
    "\nThere are no symbols in this file."
  else
    match get_elf32_file_section_header_string_table f1 with
      | Fail err     -> err
      | Success shdr ->
        "\n" ^
        harness_string_of_elf32_syms' endian os proc f1 sym_secs sht shdr bs0
    end

val harness_string_of_elf64_symbol_table_entry : nat -> (natural -> string) -> (natural -> string) -> string_table -> elf64_symbol_table_entry -> string
let {ocaml} harness_string_of_elf64_symbol_table_entry num os proc stbl ent =
  let vlu = unsafe_hex_string_of_natural 16 (natural_of_elf64_addr ent.elf64_st_value) in
  let siz = show (natural_of_elf64_xword ent.elf64_st_size) in
  let siz_pad =
    let pad = 5 - stringLength siz in
    if pad = 0 then
      ""
    else
      concatS (replicate (naturalFromNat pad) " ")
  in
  let typ = string_of_symbol_type (get_elf64_symbol_type ent) os proc in
  let bnd = string_of_symbol_binding (get_elf64_symbol_binding ent) os proc in
  let bnd_pad =
    let pad  = 8 - stringLength typ in
    if pad = 0 then
      ""
    else
      concatS (replicate (naturalFromNat pad) " ")
  in
  let vis = string_of_symbol_visibility (natural_of_unsigned_char ent.elf64_st_other) in
  let vis_pad =
    let pad  = 6 - stringLength bnd in
    if pad = 0 then
      ""
    else
      concatS (replicate (naturalFromNat pad) " ")
  in
  let ndx =
    let tmp = natural_of_elf64_half ent.elf64_st_shndx in
      if tmp = shn_undef then
        "UND"
      else if tmp = shn_abs then
        "ABS"
      else
        show tmp
  in
  let ndx_pad =
    let pad = 3 - stringLength ndx in
    if pad = 0 then
      ""
    else
      concatS (replicate (naturalFromNat pad) " ")
  in
  let nm =
    let idx = natural_of_elf64_word ent.elf64_st_name in
      if idx = 0 then
        ""
      else
        match String_table.get_string_at idx stbl with
          | Fail err -> err
          | Success s -> s
        end
  in
  let num =
    let temp = show num in
    let pad  = 3 - stringLength temp in
      if pad = 0 then
        temp
      else
        let spcs = concatS (replicate (naturalFromNat pad) " ") in
          spcs ^ temp
  in
    concatS [
      "   "
    ; num ^ ":"
    ; " "
    ; vlu
    ; " "
    ; siz_pad; siz
    ; " "
    ; typ
    ; bnd_pad; bnd
    ; " "
    ; vis_pad; vis
    ; "  "
    ; ndx_pad; ndx
    ; " "
    ; nm
    ]


val harness_string_of_elf64_syms' : endianness -> (natural -> string) -> (natural -> string) -> elf64_file -> elf64_section_header_table -> elf64_section_header_table -> string_table -> byte_sequence -> string
let {ocaml} harness_string_of_elf64_syms' endian os proc f1 filtered_sht sht shdr bs0 =
  let rels =
    mapM (fun ent ->
      let off = natural_of_elf64_off  ent.elf64_sh_offset in
      let siz = natural_of_elf64_xword ent.elf64_sh_size in
      let lnk = natural_of_elf64_word ent.elf64_sh_link in
      let typ = natural_of_elf64_word ent.elf64_sh_type in
        Byte_sequence.offset_and_cut off siz bs0 >>= fun syms ->
        Elf_symbol_table.read_elf64_symbol_table endian syms >>= fun sect ->
        Elf_file.get_elf64_string_table_by_index f1 lnk >>= fun strtab ->
        return (sect, ent, strtab, typ)
    ) filtered_sht
  >>=
    mapM (fun (syms, ent, strtab, typ) ->
      let nm  = natural_of_elf64_word ent.elf64_sh_name in
      let len = show (List.length syms) in
      String_table.get_string_at nm shdr >>= fun nm ->
      let hdr = "Symbol table '" ^ nm ^ "' contains " ^ len ^ " entries:\n" in
      let ttl = "   Num:    Value          Size Type    Bind   Vis      Ndx Name\n" in
      let body = concatS (intercalate "\n" (List.mapi (fun n ->
        harness_string_of_elf64_symbol_table_entry n os proc strtab) syms))
      in
      return (hdr ^ ttl ^ body))
  in
    match rels with
      | Fail err -> err
      | Success s -> concatS (intercalate "\n\n" s)
    end

   
val harness_string_of_elf64_syms : elf64_file -> (natural -> string) -> (natural -> string) -> byte_sequence -> string
let {ocaml} harness_string_of_elf64_syms f1 os proc bs0 =
  let hdr = f1.elf64_file_header in
  let sht = f1.elf64_file_section_header_table in
  let endian = get_elf64_header_endianness hdr in
  let sym_secs = List.filter (fun x ->
    x.elf64_sh_type = elf64_word_of_natural sht_dynsym ||
    x.elf64_sh_type = elf64_word_of_natural sht_symtab) sht
  in
  if List.length sym_secs = 0 then
    "\nThere are no symbols in this file."
  else
    match get_elf64_file_section_header_string_table f1 with
      | Fail err     -> err
      | Success shdr ->
        "\n" ^
        harness_string_of_elf64_syms' endian os proc f1 sym_secs sht shdr bs0
    end



(* convenient symbol table extractor for read-dwarf *)
(*
  val read_dwarf_symbol_table_of_elf64_syms' : endianness -> (natural -> string) -> (natural -> string) -> elf64_file -> elf64_section_header_table -> elf64_section_header_table -> string_table -> byte_sequence -> list (string * natural)
let {ocaml} read_dwarf_symbol_table_of_elf64_syms' endian os proc f1 filtered_sht sht shdr bs0 =
  let rels =
    mapM (fun ent ->
      let off = natural_of_elf64_off  ent.elf64_sh_offset in
      let siz = natural_of_elf64_xword ent.elf64_sh_size in
      let lnk = natural_of_elf64_word ent.elf64_sh_link in
      let typ = natural_of_elf64_word ent.elf64_sh_type in
        Byte_sequence.offset_and_cut off siz bs0 >>= fun syms ->
        Elf_symbol_table.read_elf64_symbol_table endian syms >>= fun sect ->
        Elf_file.get_elf64_string_table_by_index f1 lnk >>= fun strtab ->
        return (sect, ent, strtab, typ)
    ) filtered_sht
  >>=
    mapM (fun (syms, ent, strtab, typ) ->
      let nm  = natural_of_elf64_word ent.elf64_sh_name in
      let len = show (List.length syms) in
      String_table.get_string_at nm shdr >>= fun nm ->
      let hdr = "Symbol table '" ^ nm ^ "' contains " ^ len ^ " entries:\n" in
      let ttl = "   Num:    Value          Size Type    Bind   Vis      Ndx Name\n" in
      let body = concatS (intercalate "\n" (List.mapi (fun n ->
        read_dwarf_symbol_table_of_elf64_symbol_table_entry n os proc strtab) syms))
      in
      return (hdr ^ ttl ^ body))
  in
    match rels with
      | Fail err -> err
      | Success s -> concatS (intercalate "\n\n" s)
    end

val read_dwarf_symbol_table_of_elf64_syms : elf64_file -> (natural -> string) -> (natural -> string) -> byte_sequence -> string
let {ocaml} read_dwarf_symbol_table_of_elf64_syms f1 os proc bs0 =
  let hdr = f1.elf64_file_header in
  let sht = f1.elf64_file_section_header_table in
  let endian = get_elf64_header_endianness hdr in
  let sym_secs = List.filter (fun x ->
    x.elf64_sh_type = elf64_word_of_natural sht_dynsym ||
    x.elf64_sh_type = elf64_word_of_natural sht_symtab) sht
  in
  if List.length sym_secs = 0 then
    [] (*"\nThere are no symbols in this file."*)
  else
    match get_elf64_file_section_header_string_table f1 with
      | Fail err     -> err
      | Success shdr ->
(*        "\n" ^ *)
        read_dwarf_symbol_table_of_elf64_syms' endian os proc f1 sym_secs sht shdr bs0
    end
*)
(* end *)

  
val string_of_unix_time : natural -> string
declare ocaml target_rep function string_of_unix_time = `Ml_bindings.string_of_unix_time`

val string_of_dyn_value : forall 'addr 'size. dyn_value 'addr 'size ->
  ('addr -> string) -> ('size -> string) -> string
let {ocaml} string_of_dyn_value dyn addr size =
  match dyn with
    | Address a  -> addr a
    | Size    s  -> size s
    | FName   f  -> f
    | Path    p  -> p
    | SOName  f  -> "Library soname: [" ^ f ^ "]"
    | RPath   p  -> "Library rpath: [" ^ p ^ "]"
    | RunPath p  -> "Library runpath: [" ^ p ^ "]"
    | Flags   f  -> string_of_dt_flag f
    | Flags1  f  -> "Flags: " ^ gnu_string_of_dt_flag_1 f
    | Ignored    -> ""
    | Checksum s -> "0x" ^ unsafe_hex_string_of_natural 0 s
    | Library l  -> "Shared library: [" ^ l ^ "]"
    | Numeric n  -> show n
    | RelType r  -> string_of_rel_type r
    | Timestamp t -> string_of_unix_time t
    | Null       -> "0x0"
  end

val string_of_elf32_dyn_value : elf32_dyn_value -> string
let {ocaml} string_of_elf32_dyn_value dyn =
  string_of_dyn_value
    dyn
    (fun a -> "0x" ^ unsafe_hex_string_of_natural 0 (natural_of_elf32_addr a))
    (fun s -> show s ^ " (bytes)")

val string_of_elf64_dyn_value : elf64_dyn_value -> string
let {ocaml} string_of_elf64_dyn_value dyn =
  string_of_dyn_value
    dyn
    (fun a -> "0x" ^ unsafe_hex_string_of_natural 0 (natural_of_elf64_addr a))
    (fun s -> show s ^ " (bytes)")

val harness_string_of_elf32_dyn_entry : bool -> elf32_dyn -> (natural -> bool) -> (natural -> string) ->
  (elf32_dyn -> string_table -> error elf32_dyn_value) ->
    (elf32_dyn -> string_table -> error elf32_dyn_value) -> string_table -> string
let {ocaml} harness_string_of_elf32_dyn_entry shared_object dyn os_additional_tags typ os_dyn proc_dyn stbl =
  let tag = unsafe_hex_string_of_natural 8 (naturalFromInteger (integer_of_elf32_sword dyn.elf32_dyn_tag)) in
  let typ = "(" ^ typ (naturalFromInteger (integer_of_elf32_sword dyn.elf32_dyn_tag)) ^ ")" in
  let vlu =
    match get_value_of_elf32_dyn shared_object dyn os_additional_tags os_dyn proc_dyn stbl with
      | Fail    f -> f
      | Success v -> string_of_elf32_dyn_value v
    end
  in
  let vlu_pad =
    let pad = 29 - stringLength typ in
    if pad = 0 then
      ""
    else
      let reps = replicate (naturalFromNat pad) " " in
      concatS reps
  in
    concatS [
      " "
    ; "0x" ^ tag
    ; " "
    ; typ
    ; vlu_pad; vlu
    ]

val harness_string_of_elf32_dynamic_section' : elf32_file -> elf32_program_header_table_entry ->
    byte_sequence -> (natural -> bool) -> (natural -> error tag_correspondence) ->
    (natural -> error tag_correspondence) -> (natural -> string) ->
      (elf32_dyn -> string_table -> error elf32_dyn_value) ->
        (elf32_dyn -> string_table -> error elf32_dyn_value) -> string
let {ocaml} harness_string_of_elf32_dynamic_section' f1 dyn bs0 os_additional_ranges os proc os_print os_dyn proc_dyn =
  let endian = get_elf32_header_endianness f1.elf32_file_header in
  let sht = f1.elf32_file_section_header_table in
  let off = natural_of_elf32_off dyn.elf32_p_offset in
  let siz = natural_of_elf32_word dyn.elf32_p_filesz in
  let shared_object = is_elf32_shared_object_file f1.elf32_file_header in
  let res =
    Byte_sequence.offset_and_cut off siz bs0 >>= fun rel ->
    obtain_elf32_dynamic_section_contents f1 os_additional_ranges os proc bs0 >>= fun dyns ->
    get_string_table_of_elf32_dyn_section endian dyns sht bs0 >>= fun stbl ->
    return (List.map (fun x -> harness_string_of_elf32_dyn_entry shared_object x os_additional_ranges os_print os_dyn proc_dyn stbl) dyns)
  in
    match res with
      | Fail    f -> f
      | Success s ->
        let off = unsafe_hex_string_of_natural 0 off in
        let entries = show (List.length s) in
        concatS [
          "\n"
        ; "Dynamic section at offset 0x" ^ off ^ " contains " ^ entries ^ " entries:\n"
        ; "  Tag        Type                         Name/Value\n"
        ; concatS (intercalate "\n" s)
        ]
    end

val harness_string_of_elf32_dynamic_section : elf32_file -> byte_sequence ->
  (natural -> bool) -> (natural -> error tag_correspondence) ->
    (natural -> error tag_correspondence) -> (natural -> string) ->
      (elf32_dyn -> string_table -> error elf32_dyn_value) ->
        (elf32_dyn -> string_table -> error elf32_dyn_value) -> string
let {ocaml} harness_string_of_elf32_dynamic_section f1 bs0 os_additional_ranges os proc os_print os_dyn proc_dyn =
  let pht = f1.elf32_file_program_header_table in
  let dyn =
    List.filter (fun x ->
      x.elf32_p_type = elf32_word_of_natural elf_pt_dynamic
    ) pht
  in
  let print_msg = is_elf32_shared_object_file f1.elf32_file_header ||
    is_elf32_executable_file f1.elf32_file_header
  in
    match dyn with
      | []  ->
        if print_msg then
          "\nThere is no dynamic section in this file."
        else
          ""
      | [x] -> harness_string_of_elf32_dynamic_section' f1 x bs0 os_additional_ranges os proc os_print os_dyn proc_dyn
      | _   -> "Multiple dynamic sections detected."
    end

val harness_string_of_elf64_dyn_entry : bool -> elf64_dyn -> (natural -> bool) -> (natural -> string) ->
  (elf64_dyn -> string_table -> error elf64_dyn_value) ->
    (elf64_dyn -> string_table -> error elf64_dyn_value) -> string_table -> string
let {ocaml} harness_string_of_elf64_dyn_entry shared_object dyn os_additional_ranges typ os_dyn proc_dyn stbl =
  let tag = unsafe_hex_string_of_natural 16 (naturalFromInteger (integer_of_elf64_sxword dyn.elf64_dyn_tag)) in
  let typ = "(" ^ typ (naturalFromInteger (integer_of_elf64_sxword dyn.elf64_dyn_tag)) ^ ")" in
  let vlu =
    match get_value_of_elf64_dyn shared_object dyn os_additional_ranges os_dyn proc_dyn stbl with
      | Fail    f -> f
      | Success v -> string_of_elf64_dyn_value v
    end
  in
  let vlu_pad =
    let pad = 21 - stringLength typ in
    if pad = 0 then
      ""
    else
      let reps = replicate (naturalFromNat pad) " " in
      concatS reps
  in
    concatS [
      " "
    ; "0x" ^ tag
    ; " "
    ; typ
    ; vlu_pad; vlu
    ]

val harness_string_of_elf64_dynamic_section' : elf64_file -> elf64_program_header_table_entry ->
    byte_sequence -> (natural -> bool) -> (natural -> error tag_correspondence) ->
    (natural -> error tag_correspondence) -> (natural -> string) ->
      (elf64_dyn -> string_table -> error elf64_dyn_value) ->
        (elf64_dyn -> string_table -> error elf64_dyn_value) -> string
let {ocaml} harness_string_of_elf64_dynamic_section' f1 dyn bs0 os_additional_ranges os proc os_print os_dyn proc_dyn =
  let endian = get_elf64_header_endianness f1.elf64_file_header in
  let sht = f1.elf64_file_section_header_table in
  let off = natural_of_elf64_off dyn.elf64_p_offset in
  let siz = natural_of_elf64_xword dyn.elf64_p_filesz in
  let shared_object = is_elf64_shared_object_file f1.elf64_file_header in
  let res =
    Byte_sequence.offset_and_cut off siz bs0 >>= fun rel ->
    obtain_elf64_dynamic_section_contents f1 os_additional_ranges os proc bs0 >>= fun dyns ->
    get_string_table_of_elf64_dyn_section endian dyns sht bs0 >>= fun stbl ->
    return (List.map (fun x -> harness_string_of_elf64_dyn_entry shared_object x os_additional_ranges os_print os_dyn proc_dyn stbl) dyns)
  in
    match res with
      | Fail    f -> f
      | Success s ->
        let off = unsafe_hex_string_of_natural 0 off in
        let entries = show (List.length s) in
        concatS [
          "\n"
        ; "Dynamic section at offset 0x" ^ off ^ " contains " ^ entries ^ " entries:\n"
        ; "  Tag        Type                         Name/Value\n"
        ; concatS (intercalate "\n" s)
        ]
    end

val harness_string_of_elf64_dynamic_section : elf64_file -> byte_sequence ->
  (natural -> bool) -> (natural -> error tag_correspondence) ->
    (natural -> error tag_correspondence) -> (natural -> string) ->
      (elf64_dyn -> string_table -> error elf64_dyn_value) ->
        (elf64_dyn -> string_table -> error elf64_dyn_value) -> string
let {ocaml} harness_string_of_elf64_dynamic_section f1 bs0 os_additional_ranges os proc os_print os_dyn proc_dyn =
  let pht = f1.elf64_file_program_header_table in
  let print_msg = is_elf64_shared_object_file f1.elf64_file_header ||
    is_elf64_executable_file f1.elf64_file_header
  in
  let dyn =
    List.filter (fun x ->
      x.elf64_p_type = elf64_word_of_natural elf_pt_dynamic
    ) pht
  in
    match dyn with
      | []  ->
        if print_msg then
          "\nThere is no dynamic section in this file."
        else
          ""
      | [x] -> harness_string_of_elf64_dynamic_section' f1 x bs0 os_additional_ranges os proc os_print os_dyn proc_dyn
      | _   -> "Multiple dynamic sections detected."
    end
